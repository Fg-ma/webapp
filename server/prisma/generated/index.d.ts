
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model affiliates_relations
 * 
 */
export type affiliates_relations = $Result.DefaultSelection<Prisma.$affiliates_relationsPayload>
/**
 * Model collections
 * 
 */
export type collections = $Result.DefaultSelection<Prisma.$collectionsPayload>
/**
 * Model collections_content
 * 
 */
export type collections_content = $Result.DefaultSelection<Prisma.$collections_contentPayload>
/**
 * Model contacts
 * 
 */
export type contacts = $Result.DefaultSelection<Prisma.$contactsPayload>
/**
 * Model contacts_pictures
 * 
 */
export type contacts_pictures = $Result.DefaultSelection<Prisma.$contacts_picturesPayload>
/**
 * Model content
 * 
 */
export type content = $Result.DefaultSelection<Prisma.$contentPayload>
/**
 * Model conversations
 * 
 */
export type conversations = $Result.DefaultSelection<Prisma.$conversationsPayload>
/**
 * Model conversations_members
 * 
 */
export type conversations_members = $Result.DefaultSelection<Prisma.$conversations_membersPayload>
/**
 * Model conversations_messages_logs
 * 
 */
export type conversations_messages_logs = $Result.DefaultSelection<Prisma.$conversations_messages_logsPayload>
/**
 * Model conversations_pictures
 * 
 */
export type conversations_pictures = $Result.DefaultSelection<Prisma.$conversations_picturesPayload>
/**
 * Model entities
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type entities = $Result.DefaultSelection<Prisma.$entitiesPayload>
/**
 * Model entities_content
 * 
 */
export type entities_content = $Result.DefaultSelection<Prisma.$entities_contentPayload>
/**
 * Model entities_dislikes
 * 
 */
export type entities_dislikes = $Result.DefaultSelection<Prisma.$entities_dislikesPayload>
/**
 * Model entities_likes
 * 
 */
export type entities_likes = $Result.DefaultSelection<Prisma.$entities_likesPayload>
/**
 * Model entities_references
 * 
 */
export type entities_references = $Result.DefaultSelection<Prisma.$entities_referencesPayload>
/**
 * Model groups
 * 
 */
export type groups = $Result.DefaultSelection<Prisma.$groupsPayload>
/**
 * Model groups_members
 * 
 */
export type groups_members = $Result.DefaultSelection<Prisma.$groups_membersPayload>
/**
 * Model images
 * 
 */
export type images = $Result.DefaultSelection<Prisma.$imagesPayload>
/**
 * Model images_data
 * 
 */
export type images_data = $Result.DefaultSelection<Prisma.$images_dataPayload>
/**
 * Model individuals
 * 
 */
export type individuals = $Result.DefaultSelection<Prisma.$individualsPayload>
/**
 * Model organizations
 * 
 */
export type organizations = $Result.DefaultSelection<Prisma.$organizationsPayload>
/**
 * Model organizations_members
 * 
 */
export type organizations_members = $Result.DefaultSelection<Prisma.$organizations_membersPayload>
/**
 * Model profile_pictures
 * 
 */
export type profile_pictures = $Result.DefaultSelection<Prisma.$profile_picturesPayload>
/**
 * Model sheets
 * 
 */
export type sheets = $Result.DefaultSelection<Prisma.$sheetsPayload>
/**
 * Model sheets_data
 * 
 */
export type sheets_data = $Result.DefaultSelection<Prisma.$sheets_dataPayload>
/**
 * Model sheets_thumbnails
 * 
 */
export type sheets_thumbnails = $Result.DefaultSelection<Prisma.$sheets_thumbnailsPayload>
/**
 * Model tables
 * 
 */
export type tables = $Result.DefaultSelection<Prisma.$tablesPayload>
/**
 * Model tables_members
 * 
 */
export type tables_members = $Result.DefaultSelection<Prisma.$tables_membersPayload>
/**
 * Model tables_messages_logs
 * 
 */
export type tables_messages_logs = $Result.DefaultSelection<Prisma.$tables_messages_logsPayload>
/**
 * Model tables_pictures
 * 
 */
export type tables_pictures = $Result.DefaultSelection<Prisma.$tables_picturesPayload>
/**
 * Model tables_tabletops
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type tables_tabletops = $Result.DefaultSelection<Prisma.$tables_tabletopsPayload>
/**
 * Model tables_tabletops_data
 * 
 */
export type tables_tabletops_data = $Result.DefaultSelection<Prisma.$tables_tabletops_dataPayload>
/**
 * Model user_credentials
 * 
 */
export type user_credentials = $Result.DefaultSelection<Prisma.$user_credentialsPayload>
/**
 * Model videos
 * 
 */
export type videos = $Result.DefaultSelection<Prisma.$videosPayload>
/**
 * Model videos_data
 * 
 */
export type videos_data = $Result.DefaultSelection<Prisma.$videos_dataPayload>
/**
 * Model videos_thumbnails
 * 
 */
export type videos_thumbnails = $Result.DefaultSelection<Prisma.$videos_thumbnailsPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Affiliates_relations
 * const affiliates_relations = await prisma.affiliates_relations.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Affiliates_relations
   * const affiliates_relations = await prisma.affiliates_relations.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.affiliates_relations`: Exposes CRUD operations for the **affiliates_relations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Affiliates_relations
    * const affiliates_relations = await prisma.affiliates_relations.findMany()
    * ```
    */
  get affiliates_relations(): Prisma.affiliates_relationsDelegate<ExtArgs>;

  /**
   * `prisma.collections`: Exposes CRUD operations for the **collections** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Collections
    * const collections = await prisma.collections.findMany()
    * ```
    */
  get collections(): Prisma.collectionsDelegate<ExtArgs>;

  /**
   * `prisma.collections_content`: Exposes CRUD operations for the **collections_content** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Collections_contents
    * const collections_contents = await prisma.collections_content.findMany()
    * ```
    */
  get collections_content(): Prisma.collections_contentDelegate<ExtArgs>;

  /**
   * `prisma.contacts`: Exposes CRUD operations for the **contacts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contacts.findMany()
    * ```
    */
  get contacts(): Prisma.contactsDelegate<ExtArgs>;

  /**
   * `prisma.contacts_pictures`: Exposes CRUD operations for the **contacts_pictures** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts_pictures
    * const contacts_pictures = await prisma.contacts_pictures.findMany()
    * ```
    */
  get contacts_pictures(): Prisma.contacts_picturesDelegate<ExtArgs>;

  /**
   * `prisma.content`: Exposes CRUD operations for the **content** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contents
    * const contents = await prisma.content.findMany()
    * ```
    */
  get content(): Prisma.contentDelegate<ExtArgs>;

  /**
   * `prisma.conversations`: Exposes CRUD operations for the **conversations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversations.findMany()
    * ```
    */
  get conversations(): Prisma.conversationsDelegate<ExtArgs>;

  /**
   * `prisma.conversations_members`: Exposes CRUD operations for the **conversations_members** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations_members
    * const conversations_members = await prisma.conversations_members.findMany()
    * ```
    */
  get conversations_members(): Prisma.conversations_membersDelegate<ExtArgs>;

  /**
   * `prisma.conversations_messages_logs`: Exposes CRUD operations for the **conversations_messages_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations_messages_logs
    * const conversations_messages_logs = await prisma.conversations_messages_logs.findMany()
    * ```
    */
  get conversations_messages_logs(): Prisma.conversations_messages_logsDelegate<ExtArgs>;

  /**
   * `prisma.conversations_pictures`: Exposes CRUD operations for the **conversations_pictures** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations_pictures
    * const conversations_pictures = await prisma.conversations_pictures.findMany()
    * ```
    */
  get conversations_pictures(): Prisma.conversations_picturesDelegate<ExtArgs>;

  /**
   * `prisma.entities`: Exposes CRUD operations for the **entities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Entities
    * const entities = await prisma.entities.findMany()
    * ```
    */
  get entities(): Prisma.entitiesDelegate<ExtArgs>;

  /**
   * `prisma.entities_content`: Exposes CRUD operations for the **entities_content** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Entities_contents
    * const entities_contents = await prisma.entities_content.findMany()
    * ```
    */
  get entities_content(): Prisma.entities_contentDelegate<ExtArgs>;

  /**
   * `prisma.entities_dislikes`: Exposes CRUD operations for the **entities_dislikes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Entities_dislikes
    * const entities_dislikes = await prisma.entities_dislikes.findMany()
    * ```
    */
  get entities_dislikes(): Prisma.entities_dislikesDelegate<ExtArgs>;

  /**
   * `prisma.entities_likes`: Exposes CRUD operations for the **entities_likes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Entities_likes
    * const entities_likes = await prisma.entities_likes.findMany()
    * ```
    */
  get entities_likes(): Prisma.entities_likesDelegate<ExtArgs>;

  /**
   * `prisma.entities_references`: Exposes CRUD operations for the **entities_references** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Entities_references
    * const entities_references = await prisma.entities_references.findMany()
    * ```
    */
  get entities_references(): Prisma.entities_referencesDelegate<ExtArgs>;

  /**
   * `prisma.groups`: Exposes CRUD operations for the **groups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.groups.findMany()
    * ```
    */
  get groups(): Prisma.groupsDelegate<ExtArgs>;

  /**
   * `prisma.groups_members`: Exposes CRUD operations for the **groups_members** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups_members
    * const groups_members = await prisma.groups_members.findMany()
    * ```
    */
  get groups_members(): Prisma.groups_membersDelegate<ExtArgs>;

  /**
   * `prisma.images`: Exposes CRUD operations for the **images** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Images
    * const images = await prisma.images.findMany()
    * ```
    */
  get images(): Prisma.imagesDelegate<ExtArgs>;

  /**
   * `prisma.images_data`: Exposes CRUD operations for the **images_data** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Images_data
    * const images_data = await prisma.images_data.findMany()
    * ```
    */
  get images_data(): Prisma.images_dataDelegate<ExtArgs>;

  /**
   * `prisma.individuals`: Exposes CRUD operations for the **individuals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Individuals
    * const individuals = await prisma.individuals.findMany()
    * ```
    */
  get individuals(): Prisma.individualsDelegate<ExtArgs>;

  /**
   * `prisma.organizations`: Exposes CRUD operations for the **organizations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organizations.findMany()
    * ```
    */
  get organizations(): Prisma.organizationsDelegate<ExtArgs>;

  /**
   * `prisma.organizations_members`: Exposes CRUD operations for the **organizations_members** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations_members
    * const organizations_members = await prisma.organizations_members.findMany()
    * ```
    */
  get organizations_members(): Prisma.organizations_membersDelegate<ExtArgs>;

  /**
   * `prisma.profile_pictures`: Exposes CRUD operations for the **profile_pictures** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profile_pictures
    * const profile_pictures = await prisma.profile_pictures.findMany()
    * ```
    */
  get profile_pictures(): Prisma.profile_picturesDelegate<ExtArgs>;

  /**
   * `prisma.sheets`: Exposes CRUD operations for the **sheets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sheets
    * const sheets = await prisma.sheets.findMany()
    * ```
    */
  get sheets(): Prisma.sheetsDelegate<ExtArgs>;

  /**
   * `prisma.sheets_data`: Exposes CRUD operations for the **sheets_data** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sheets_data
    * const sheets_data = await prisma.sheets_data.findMany()
    * ```
    */
  get sheets_data(): Prisma.sheets_dataDelegate<ExtArgs>;

  /**
   * `prisma.sheets_thumbnails`: Exposes CRUD operations for the **sheets_thumbnails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sheets_thumbnails
    * const sheets_thumbnails = await prisma.sheets_thumbnails.findMany()
    * ```
    */
  get sheets_thumbnails(): Prisma.sheets_thumbnailsDelegate<ExtArgs>;

  /**
   * `prisma.tables`: Exposes CRUD operations for the **tables** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tables
    * const tables = await prisma.tables.findMany()
    * ```
    */
  get tables(): Prisma.tablesDelegate<ExtArgs>;

  /**
   * `prisma.tables_members`: Exposes CRUD operations for the **tables_members** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tables_members
    * const tables_members = await prisma.tables_members.findMany()
    * ```
    */
  get tables_members(): Prisma.tables_membersDelegate<ExtArgs>;

  /**
   * `prisma.tables_messages_logs`: Exposes CRUD operations for the **tables_messages_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tables_messages_logs
    * const tables_messages_logs = await prisma.tables_messages_logs.findMany()
    * ```
    */
  get tables_messages_logs(): Prisma.tables_messages_logsDelegate<ExtArgs>;

  /**
   * `prisma.tables_pictures`: Exposes CRUD operations for the **tables_pictures** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tables_pictures
    * const tables_pictures = await prisma.tables_pictures.findMany()
    * ```
    */
  get tables_pictures(): Prisma.tables_picturesDelegate<ExtArgs>;

  /**
   * `prisma.tables_tabletops`: Exposes CRUD operations for the **tables_tabletops** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tables_tabletops
    * const tables_tabletops = await prisma.tables_tabletops.findMany()
    * ```
    */
  get tables_tabletops(): Prisma.tables_tabletopsDelegate<ExtArgs>;

  /**
   * `prisma.tables_tabletops_data`: Exposes CRUD operations for the **tables_tabletops_data** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tables_tabletops_data
    * const tables_tabletops_data = await prisma.tables_tabletops_data.findMany()
    * ```
    */
  get tables_tabletops_data(): Prisma.tables_tabletops_dataDelegate<ExtArgs>;

  /**
   * `prisma.user_credentials`: Exposes CRUD operations for the **user_credentials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_credentials
    * const user_credentials = await prisma.user_credentials.findMany()
    * ```
    */
  get user_credentials(): Prisma.user_credentialsDelegate<ExtArgs>;

  /**
   * `prisma.videos`: Exposes CRUD operations for the **videos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videos
    * const videos = await prisma.videos.findMany()
    * ```
    */
  get videos(): Prisma.videosDelegate<ExtArgs>;

  /**
   * `prisma.videos_data`: Exposes CRUD operations for the **videos_data** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videos_data
    * const videos_data = await prisma.videos_data.findMany()
    * ```
    */
  get videos_data(): Prisma.videos_dataDelegate<ExtArgs>;

  /**
   * `prisma.videos_thumbnails`: Exposes CRUD operations for the **videos_thumbnails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videos_thumbnails
    * const videos_thumbnails = await prisma.videos_thumbnails.findMany()
    * ```
    */
  get videos_thumbnails(): Prisma.videos_thumbnailsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.10.2
   * Query Engine version: 5a9203d0590c951969e85a7d07215503f4672eb9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    affiliates_relations: 'affiliates_relations',
    collections: 'collections',
    collections_content: 'collections_content',
    contacts: 'contacts',
    contacts_pictures: 'contacts_pictures',
    content: 'content',
    conversations: 'conversations',
    conversations_members: 'conversations_members',
    conversations_messages_logs: 'conversations_messages_logs',
    conversations_pictures: 'conversations_pictures',
    entities: 'entities',
    entities_content: 'entities_content',
    entities_dislikes: 'entities_dislikes',
    entities_likes: 'entities_likes',
    entities_references: 'entities_references',
    groups: 'groups',
    groups_members: 'groups_members',
    images: 'images',
    images_data: 'images_data',
    individuals: 'individuals',
    organizations: 'organizations',
    organizations_members: 'organizations_members',
    profile_pictures: 'profile_pictures',
    sheets: 'sheets',
    sheets_data: 'sheets_data',
    sheets_thumbnails: 'sheets_thumbnails',
    tables: 'tables',
    tables_members: 'tables_members',
    tables_messages_logs: 'tables_messages_logs',
    tables_pictures: 'tables_pictures',
    tables_tabletops: 'tables_tabletops',
    tables_tabletops_data: 'tables_tabletops_data',
    user_credentials: 'user_credentials',
    videos: 'videos',
    videos_data: 'videos_data',
    videos_thumbnails: 'videos_thumbnails'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'affiliates_relations' | 'collections' | 'collections_content' | 'contacts' | 'contacts_pictures' | 'content' | 'conversations' | 'conversations_members' | 'conversations_messages_logs' | 'conversations_pictures' | 'entities' | 'entities_content' | 'entities_dislikes' | 'entities_likes' | 'entities_references' | 'groups' | 'groups_members' | 'images' | 'images_data' | 'individuals' | 'organizations' | 'organizations_members' | 'profile_pictures' | 'sheets' | 'sheets_data' | 'sheets_thumbnails' | 'tables' | 'tables_members' | 'tables_messages_logs' | 'tables_pictures' | 'tables_tabletops' | 'tables_tabletops_data' | 'user_credentials' | 'videos' | 'videos_data' | 'videos_thumbnails'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      affiliates_relations: {
        payload: Prisma.$affiliates_relationsPayload<ExtArgs>
        fields: Prisma.affiliates_relationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.affiliates_relationsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$affiliates_relationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.affiliates_relationsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$affiliates_relationsPayload>
          }
          findFirst: {
            args: Prisma.affiliates_relationsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$affiliates_relationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.affiliates_relationsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$affiliates_relationsPayload>
          }
          findMany: {
            args: Prisma.affiliates_relationsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$affiliates_relationsPayload>[]
          }
          create: {
            args: Prisma.affiliates_relationsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$affiliates_relationsPayload>
          }
          createMany: {
            args: Prisma.affiliates_relationsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.affiliates_relationsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$affiliates_relationsPayload>
          }
          update: {
            args: Prisma.affiliates_relationsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$affiliates_relationsPayload>
          }
          deleteMany: {
            args: Prisma.affiliates_relationsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.affiliates_relationsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.affiliates_relationsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$affiliates_relationsPayload>
          }
          aggregate: {
            args: Prisma.Affiliates_relationsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAffiliates_relations>
          }
          groupBy: {
            args: Prisma.affiliates_relationsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Affiliates_relationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.affiliates_relationsCountArgs<ExtArgs>,
            result: $Utils.Optional<Affiliates_relationsCountAggregateOutputType> | number
          }
        }
      }
      collections: {
        payload: Prisma.$collectionsPayload<ExtArgs>
        fields: Prisma.collectionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.collectionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$collectionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.collectionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$collectionsPayload>
          }
          findFirst: {
            args: Prisma.collectionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$collectionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.collectionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$collectionsPayload>
          }
          findMany: {
            args: Prisma.collectionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$collectionsPayload>[]
          }
          create: {
            args: Prisma.collectionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$collectionsPayload>
          }
          createMany: {
            args: Prisma.collectionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.collectionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$collectionsPayload>
          }
          update: {
            args: Prisma.collectionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$collectionsPayload>
          }
          deleteMany: {
            args: Prisma.collectionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.collectionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.collectionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$collectionsPayload>
          }
          aggregate: {
            args: Prisma.CollectionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCollections>
          }
          groupBy: {
            args: Prisma.collectionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CollectionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.collectionsCountArgs<ExtArgs>,
            result: $Utils.Optional<CollectionsCountAggregateOutputType> | number
          }
        }
      }
      collections_content: {
        payload: Prisma.$collections_contentPayload<ExtArgs>
        fields: Prisma.collections_contentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.collections_contentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$collections_contentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.collections_contentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$collections_contentPayload>
          }
          findFirst: {
            args: Prisma.collections_contentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$collections_contentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.collections_contentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$collections_contentPayload>
          }
          findMany: {
            args: Prisma.collections_contentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$collections_contentPayload>[]
          }
          create: {
            args: Prisma.collections_contentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$collections_contentPayload>
          }
          createMany: {
            args: Prisma.collections_contentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.collections_contentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$collections_contentPayload>
          }
          update: {
            args: Prisma.collections_contentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$collections_contentPayload>
          }
          deleteMany: {
            args: Prisma.collections_contentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.collections_contentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.collections_contentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$collections_contentPayload>
          }
          aggregate: {
            args: Prisma.Collections_contentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCollections_content>
          }
          groupBy: {
            args: Prisma.collections_contentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Collections_contentGroupByOutputType>[]
          }
          count: {
            args: Prisma.collections_contentCountArgs<ExtArgs>,
            result: $Utils.Optional<Collections_contentCountAggregateOutputType> | number
          }
        }
      }
      contacts: {
        payload: Prisma.$contactsPayload<ExtArgs>
        fields: Prisma.contactsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.contactsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contactsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.contactsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>
          }
          findFirst: {
            args: Prisma.contactsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contactsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.contactsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>
          }
          findMany: {
            args: Prisma.contactsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>[]
          }
          create: {
            args: Prisma.contactsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>
          }
          createMany: {
            args: Prisma.contactsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.contactsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>
          }
          update: {
            args: Prisma.contactsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>
          }
          deleteMany: {
            args: Prisma.contactsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.contactsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.contactsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>
          }
          aggregate: {
            args: Prisma.ContactsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContacts>
          }
          groupBy: {
            args: Prisma.contactsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContactsGroupByOutputType>[]
          }
          count: {
            args: Prisma.contactsCountArgs<ExtArgs>,
            result: $Utils.Optional<ContactsCountAggregateOutputType> | number
          }
        }
      }
      contacts_pictures: {
        payload: Prisma.$contacts_picturesPayload<ExtArgs>
        fields: Prisma.contacts_picturesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.contacts_picturesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contacts_picturesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.contacts_picturesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contacts_picturesPayload>
          }
          findFirst: {
            args: Prisma.contacts_picturesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contacts_picturesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.contacts_picturesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contacts_picturesPayload>
          }
          findMany: {
            args: Prisma.contacts_picturesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contacts_picturesPayload>[]
          }
          create: {
            args: Prisma.contacts_picturesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contacts_picturesPayload>
          }
          createMany: {
            args: Prisma.contacts_picturesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.contacts_picturesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contacts_picturesPayload>
          }
          update: {
            args: Prisma.contacts_picturesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contacts_picturesPayload>
          }
          deleteMany: {
            args: Prisma.contacts_picturesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.contacts_picturesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.contacts_picturesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contacts_picturesPayload>
          }
          aggregate: {
            args: Prisma.Contacts_picturesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContacts_pictures>
          }
          groupBy: {
            args: Prisma.contacts_picturesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Contacts_picturesGroupByOutputType>[]
          }
          count: {
            args: Prisma.contacts_picturesCountArgs<ExtArgs>,
            result: $Utils.Optional<Contacts_picturesCountAggregateOutputType> | number
          }
        }
      }
      content: {
        payload: Prisma.$contentPayload<ExtArgs>
        fields: Prisma.contentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.contentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.contentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contentPayload>
          }
          findFirst: {
            args: Prisma.contentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.contentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contentPayload>
          }
          findMany: {
            args: Prisma.contentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contentPayload>[]
          }
          create: {
            args: Prisma.contentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contentPayload>
          }
          createMany: {
            args: Prisma.contentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.contentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contentPayload>
          }
          update: {
            args: Prisma.contentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contentPayload>
          }
          deleteMany: {
            args: Prisma.contentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.contentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.contentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contentPayload>
          }
          aggregate: {
            args: Prisma.ContentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContent>
          }
          groupBy: {
            args: Prisma.contentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.contentCountArgs<ExtArgs>,
            result: $Utils.Optional<ContentCountAggregateOutputType> | number
          }
        }
      }
      conversations: {
        payload: Prisma.$conversationsPayload<ExtArgs>
        fields: Prisma.conversationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.conversationsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.conversationsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>
          }
          findFirst: {
            args: Prisma.conversationsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.conversationsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>
          }
          findMany: {
            args: Prisma.conversationsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>[]
          }
          create: {
            args: Prisma.conversationsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>
          }
          createMany: {
            args: Prisma.conversationsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.conversationsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>
          }
          update: {
            args: Prisma.conversationsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>
          }
          deleteMany: {
            args: Prisma.conversationsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.conversationsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.conversationsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>
          }
          aggregate: {
            args: Prisma.ConversationsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConversations>
          }
          groupBy: {
            args: Prisma.conversationsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConversationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.conversationsCountArgs<ExtArgs>,
            result: $Utils.Optional<ConversationsCountAggregateOutputType> | number
          }
        }
      }
      conversations_members: {
        payload: Prisma.$conversations_membersPayload<ExtArgs>
        fields: Prisma.conversations_membersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.conversations_membersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversations_membersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.conversations_membersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversations_membersPayload>
          }
          findFirst: {
            args: Prisma.conversations_membersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversations_membersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.conversations_membersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversations_membersPayload>
          }
          findMany: {
            args: Prisma.conversations_membersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversations_membersPayload>[]
          }
          create: {
            args: Prisma.conversations_membersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversations_membersPayload>
          }
          createMany: {
            args: Prisma.conversations_membersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.conversations_membersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversations_membersPayload>
          }
          update: {
            args: Prisma.conversations_membersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversations_membersPayload>
          }
          deleteMany: {
            args: Prisma.conversations_membersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.conversations_membersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.conversations_membersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversations_membersPayload>
          }
          aggregate: {
            args: Prisma.Conversations_membersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConversations_members>
          }
          groupBy: {
            args: Prisma.conversations_membersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Conversations_membersGroupByOutputType>[]
          }
          count: {
            args: Prisma.conversations_membersCountArgs<ExtArgs>,
            result: $Utils.Optional<Conversations_membersCountAggregateOutputType> | number
          }
        }
      }
      conversations_messages_logs: {
        payload: Prisma.$conversations_messages_logsPayload<ExtArgs>
        fields: Prisma.conversations_messages_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.conversations_messages_logsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversations_messages_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.conversations_messages_logsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversations_messages_logsPayload>
          }
          findFirst: {
            args: Prisma.conversations_messages_logsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversations_messages_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.conversations_messages_logsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversations_messages_logsPayload>
          }
          findMany: {
            args: Prisma.conversations_messages_logsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversations_messages_logsPayload>[]
          }
          create: {
            args: Prisma.conversations_messages_logsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversations_messages_logsPayload>
          }
          createMany: {
            args: Prisma.conversations_messages_logsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.conversations_messages_logsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversations_messages_logsPayload>
          }
          update: {
            args: Prisma.conversations_messages_logsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversations_messages_logsPayload>
          }
          deleteMany: {
            args: Prisma.conversations_messages_logsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.conversations_messages_logsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.conversations_messages_logsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversations_messages_logsPayload>
          }
          aggregate: {
            args: Prisma.Conversations_messages_logsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConversations_messages_logs>
          }
          groupBy: {
            args: Prisma.conversations_messages_logsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Conversations_messages_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.conversations_messages_logsCountArgs<ExtArgs>,
            result: $Utils.Optional<Conversations_messages_logsCountAggregateOutputType> | number
          }
        }
      }
      conversations_pictures: {
        payload: Prisma.$conversations_picturesPayload<ExtArgs>
        fields: Prisma.conversations_picturesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.conversations_picturesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversations_picturesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.conversations_picturesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversations_picturesPayload>
          }
          findFirst: {
            args: Prisma.conversations_picturesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversations_picturesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.conversations_picturesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversations_picturesPayload>
          }
          findMany: {
            args: Prisma.conversations_picturesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversations_picturesPayload>[]
          }
          create: {
            args: Prisma.conversations_picturesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversations_picturesPayload>
          }
          createMany: {
            args: Prisma.conversations_picturesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.conversations_picturesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversations_picturesPayload>
          }
          update: {
            args: Prisma.conversations_picturesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversations_picturesPayload>
          }
          deleteMany: {
            args: Prisma.conversations_picturesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.conversations_picturesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.conversations_picturesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$conversations_picturesPayload>
          }
          aggregate: {
            args: Prisma.Conversations_picturesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConversations_pictures>
          }
          groupBy: {
            args: Prisma.conversations_picturesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Conversations_picturesGroupByOutputType>[]
          }
          count: {
            args: Prisma.conversations_picturesCountArgs<ExtArgs>,
            result: $Utils.Optional<Conversations_picturesCountAggregateOutputType> | number
          }
        }
      }
      entities: {
        payload: Prisma.$entitiesPayload<ExtArgs>
        fields: Prisma.entitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.entitiesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.entitiesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload>
          }
          findFirst: {
            args: Prisma.entitiesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.entitiesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload>
          }
          findMany: {
            args: Prisma.entitiesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload>[]
          }
          create: {
            args: Prisma.entitiesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload>
          }
          createMany: {
            args: Prisma.entitiesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.entitiesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload>
          }
          update: {
            args: Prisma.entitiesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload>
          }
          deleteMany: {
            args: Prisma.entitiesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.entitiesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.entitiesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload>
          }
          aggregate: {
            args: Prisma.EntitiesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEntities>
          }
          groupBy: {
            args: Prisma.entitiesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EntitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.entitiesCountArgs<ExtArgs>,
            result: $Utils.Optional<EntitiesCountAggregateOutputType> | number
          }
        }
      }
      entities_content: {
        payload: Prisma.$entities_contentPayload<ExtArgs>
        fields: Prisma.entities_contentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.entities_contentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_contentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.entities_contentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_contentPayload>
          }
          findFirst: {
            args: Prisma.entities_contentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_contentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.entities_contentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_contentPayload>
          }
          findMany: {
            args: Prisma.entities_contentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_contentPayload>[]
          }
          create: {
            args: Prisma.entities_contentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_contentPayload>
          }
          createMany: {
            args: Prisma.entities_contentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.entities_contentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_contentPayload>
          }
          update: {
            args: Prisma.entities_contentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_contentPayload>
          }
          deleteMany: {
            args: Prisma.entities_contentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.entities_contentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.entities_contentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_contentPayload>
          }
          aggregate: {
            args: Prisma.Entities_contentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEntities_content>
          }
          groupBy: {
            args: Prisma.entities_contentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Entities_contentGroupByOutputType>[]
          }
          count: {
            args: Prisma.entities_contentCountArgs<ExtArgs>,
            result: $Utils.Optional<Entities_contentCountAggregateOutputType> | number
          }
        }
      }
      entities_dislikes: {
        payload: Prisma.$entities_dislikesPayload<ExtArgs>
        fields: Prisma.entities_dislikesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.entities_dislikesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_dislikesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.entities_dislikesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_dislikesPayload>
          }
          findFirst: {
            args: Prisma.entities_dislikesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_dislikesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.entities_dislikesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_dislikesPayload>
          }
          findMany: {
            args: Prisma.entities_dislikesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_dislikesPayload>[]
          }
          create: {
            args: Prisma.entities_dislikesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_dislikesPayload>
          }
          createMany: {
            args: Prisma.entities_dislikesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.entities_dislikesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_dislikesPayload>
          }
          update: {
            args: Prisma.entities_dislikesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_dislikesPayload>
          }
          deleteMany: {
            args: Prisma.entities_dislikesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.entities_dislikesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.entities_dislikesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_dislikesPayload>
          }
          aggregate: {
            args: Prisma.Entities_dislikesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEntities_dislikes>
          }
          groupBy: {
            args: Prisma.entities_dislikesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Entities_dislikesGroupByOutputType>[]
          }
          count: {
            args: Prisma.entities_dislikesCountArgs<ExtArgs>,
            result: $Utils.Optional<Entities_dislikesCountAggregateOutputType> | number
          }
        }
      }
      entities_likes: {
        payload: Prisma.$entities_likesPayload<ExtArgs>
        fields: Prisma.entities_likesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.entities_likesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_likesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.entities_likesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_likesPayload>
          }
          findFirst: {
            args: Prisma.entities_likesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_likesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.entities_likesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_likesPayload>
          }
          findMany: {
            args: Prisma.entities_likesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_likesPayload>[]
          }
          create: {
            args: Prisma.entities_likesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_likesPayload>
          }
          createMany: {
            args: Prisma.entities_likesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.entities_likesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_likesPayload>
          }
          update: {
            args: Prisma.entities_likesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_likesPayload>
          }
          deleteMany: {
            args: Prisma.entities_likesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.entities_likesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.entities_likesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_likesPayload>
          }
          aggregate: {
            args: Prisma.Entities_likesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEntities_likes>
          }
          groupBy: {
            args: Prisma.entities_likesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Entities_likesGroupByOutputType>[]
          }
          count: {
            args: Prisma.entities_likesCountArgs<ExtArgs>,
            result: $Utils.Optional<Entities_likesCountAggregateOutputType> | number
          }
        }
      }
      entities_references: {
        payload: Prisma.$entities_referencesPayload<ExtArgs>
        fields: Prisma.entities_referencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.entities_referencesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_referencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.entities_referencesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_referencesPayload>
          }
          findFirst: {
            args: Prisma.entities_referencesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_referencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.entities_referencesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_referencesPayload>
          }
          findMany: {
            args: Prisma.entities_referencesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_referencesPayload>[]
          }
          create: {
            args: Prisma.entities_referencesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_referencesPayload>
          }
          createMany: {
            args: Prisma.entities_referencesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.entities_referencesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_referencesPayload>
          }
          update: {
            args: Prisma.entities_referencesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_referencesPayload>
          }
          deleteMany: {
            args: Prisma.entities_referencesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.entities_referencesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.entities_referencesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$entities_referencesPayload>
          }
          aggregate: {
            args: Prisma.Entities_referencesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEntities_references>
          }
          groupBy: {
            args: Prisma.entities_referencesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Entities_referencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.entities_referencesCountArgs<ExtArgs>,
            result: $Utils.Optional<Entities_referencesCountAggregateOutputType> | number
          }
        }
      }
      groups: {
        payload: Prisma.$groupsPayload<ExtArgs>
        fields: Prisma.groupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.groupsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.groupsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupsPayload>
          }
          findFirst: {
            args: Prisma.groupsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.groupsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupsPayload>
          }
          findMany: {
            args: Prisma.groupsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupsPayload>[]
          }
          create: {
            args: Prisma.groupsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupsPayload>
          }
          createMany: {
            args: Prisma.groupsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.groupsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupsPayload>
          }
          update: {
            args: Prisma.groupsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupsPayload>
          }
          deleteMany: {
            args: Prisma.groupsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.groupsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.groupsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupsPayload>
          }
          aggregate: {
            args: Prisma.GroupsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGroups>
          }
          groupBy: {
            args: Prisma.groupsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GroupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.groupsCountArgs<ExtArgs>,
            result: $Utils.Optional<GroupsCountAggregateOutputType> | number
          }
        }
      }
      groups_members: {
        payload: Prisma.$groups_membersPayload<ExtArgs>
        fields: Prisma.groups_membersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.groups_membersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groups_membersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.groups_membersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groups_membersPayload>
          }
          findFirst: {
            args: Prisma.groups_membersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groups_membersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.groups_membersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groups_membersPayload>
          }
          findMany: {
            args: Prisma.groups_membersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groups_membersPayload>[]
          }
          create: {
            args: Prisma.groups_membersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groups_membersPayload>
          }
          createMany: {
            args: Prisma.groups_membersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.groups_membersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groups_membersPayload>
          }
          update: {
            args: Prisma.groups_membersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groups_membersPayload>
          }
          deleteMany: {
            args: Prisma.groups_membersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.groups_membersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.groups_membersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groups_membersPayload>
          }
          aggregate: {
            args: Prisma.Groups_membersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGroups_members>
          }
          groupBy: {
            args: Prisma.groups_membersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Groups_membersGroupByOutputType>[]
          }
          count: {
            args: Prisma.groups_membersCountArgs<ExtArgs>,
            result: $Utils.Optional<Groups_membersCountAggregateOutputType> | number
          }
        }
      }
      images: {
        payload: Prisma.$imagesPayload<ExtArgs>
        fields: Prisma.imagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.imagesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$imagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.imagesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>
          }
          findFirst: {
            args: Prisma.imagesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$imagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.imagesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>
          }
          findMany: {
            args: Prisma.imagesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>[]
          }
          create: {
            args: Prisma.imagesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>
          }
          createMany: {
            args: Prisma.imagesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.imagesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>
          }
          update: {
            args: Prisma.imagesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>
          }
          deleteMany: {
            args: Prisma.imagesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.imagesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.imagesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>
          }
          aggregate: {
            args: Prisma.ImagesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateImages>
          }
          groupBy: {
            args: Prisma.imagesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ImagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.imagesCountArgs<ExtArgs>,
            result: $Utils.Optional<ImagesCountAggregateOutputType> | number
          }
        }
      }
      images_data: {
        payload: Prisma.$images_dataPayload<ExtArgs>
        fields: Prisma.images_dataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.images_dataFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$images_dataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.images_dataFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$images_dataPayload>
          }
          findFirst: {
            args: Prisma.images_dataFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$images_dataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.images_dataFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$images_dataPayload>
          }
          findMany: {
            args: Prisma.images_dataFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$images_dataPayload>[]
          }
          create: {
            args: Prisma.images_dataCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$images_dataPayload>
          }
          createMany: {
            args: Prisma.images_dataCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.images_dataDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$images_dataPayload>
          }
          update: {
            args: Prisma.images_dataUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$images_dataPayload>
          }
          deleteMany: {
            args: Prisma.images_dataDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.images_dataUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.images_dataUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$images_dataPayload>
          }
          aggregate: {
            args: Prisma.Images_dataAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateImages_data>
          }
          groupBy: {
            args: Prisma.images_dataGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Images_dataGroupByOutputType>[]
          }
          count: {
            args: Prisma.images_dataCountArgs<ExtArgs>,
            result: $Utils.Optional<Images_dataCountAggregateOutputType> | number
          }
        }
      }
      individuals: {
        payload: Prisma.$individualsPayload<ExtArgs>
        fields: Prisma.individualsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.individualsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$individualsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.individualsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$individualsPayload>
          }
          findFirst: {
            args: Prisma.individualsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$individualsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.individualsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$individualsPayload>
          }
          findMany: {
            args: Prisma.individualsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$individualsPayload>[]
          }
          create: {
            args: Prisma.individualsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$individualsPayload>
          }
          createMany: {
            args: Prisma.individualsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.individualsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$individualsPayload>
          }
          update: {
            args: Prisma.individualsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$individualsPayload>
          }
          deleteMany: {
            args: Prisma.individualsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.individualsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.individualsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$individualsPayload>
          }
          aggregate: {
            args: Prisma.IndividualsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIndividuals>
          }
          groupBy: {
            args: Prisma.individualsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<IndividualsGroupByOutputType>[]
          }
          count: {
            args: Prisma.individualsCountArgs<ExtArgs>,
            result: $Utils.Optional<IndividualsCountAggregateOutputType> | number
          }
        }
      }
      organizations: {
        payload: Prisma.$organizationsPayload<ExtArgs>
        fields: Prisma.organizationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.organizationsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$organizationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.organizationsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$organizationsPayload>
          }
          findFirst: {
            args: Prisma.organizationsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$organizationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.organizationsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$organizationsPayload>
          }
          findMany: {
            args: Prisma.organizationsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$organizationsPayload>[]
          }
          create: {
            args: Prisma.organizationsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$organizationsPayload>
          }
          createMany: {
            args: Prisma.organizationsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.organizationsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$organizationsPayload>
          }
          update: {
            args: Prisma.organizationsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$organizationsPayload>
          }
          deleteMany: {
            args: Prisma.organizationsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.organizationsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.organizationsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$organizationsPayload>
          }
          aggregate: {
            args: Prisma.OrganizationsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrganizations>
          }
          groupBy: {
            args: Prisma.organizationsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrganizationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.organizationsCountArgs<ExtArgs>,
            result: $Utils.Optional<OrganizationsCountAggregateOutputType> | number
          }
        }
      }
      organizations_members: {
        payload: Prisma.$organizations_membersPayload<ExtArgs>
        fields: Prisma.organizations_membersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.organizations_membersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$organizations_membersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.organizations_membersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$organizations_membersPayload>
          }
          findFirst: {
            args: Prisma.organizations_membersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$organizations_membersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.organizations_membersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$organizations_membersPayload>
          }
          findMany: {
            args: Prisma.organizations_membersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$organizations_membersPayload>[]
          }
          create: {
            args: Prisma.organizations_membersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$organizations_membersPayload>
          }
          createMany: {
            args: Prisma.organizations_membersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.organizations_membersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$organizations_membersPayload>
          }
          update: {
            args: Prisma.organizations_membersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$organizations_membersPayload>
          }
          deleteMany: {
            args: Prisma.organizations_membersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.organizations_membersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.organizations_membersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$organizations_membersPayload>
          }
          aggregate: {
            args: Prisma.Organizations_membersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrganizations_members>
          }
          groupBy: {
            args: Prisma.organizations_membersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Organizations_membersGroupByOutputType>[]
          }
          count: {
            args: Prisma.organizations_membersCountArgs<ExtArgs>,
            result: $Utils.Optional<Organizations_membersCountAggregateOutputType> | number
          }
        }
      }
      profile_pictures: {
        payload: Prisma.$profile_picturesPayload<ExtArgs>
        fields: Prisma.profile_picturesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.profile_picturesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$profile_picturesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.profile_picturesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$profile_picturesPayload>
          }
          findFirst: {
            args: Prisma.profile_picturesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$profile_picturesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.profile_picturesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$profile_picturesPayload>
          }
          findMany: {
            args: Prisma.profile_picturesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$profile_picturesPayload>[]
          }
          create: {
            args: Prisma.profile_picturesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$profile_picturesPayload>
          }
          createMany: {
            args: Prisma.profile_picturesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.profile_picturesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$profile_picturesPayload>
          }
          update: {
            args: Prisma.profile_picturesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$profile_picturesPayload>
          }
          deleteMany: {
            args: Prisma.profile_picturesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.profile_picturesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.profile_picturesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$profile_picturesPayload>
          }
          aggregate: {
            args: Prisma.Profile_picturesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProfile_pictures>
          }
          groupBy: {
            args: Prisma.profile_picturesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Profile_picturesGroupByOutputType>[]
          }
          count: {
            args: Prisma.profile_picturesCountArgs<ExtArgs>,
            result: $Utils.Optional<Profile_picturesCountAggregateOutputType> | number
          }
        }
      }
      sheets: {
        payload: Prisma.$sheetsPayload<ExtArgs>
        fields: Prisma.sheetsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sheetsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sheetsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sheetsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sheetsPayload>
          }
          findFirst: {
            args: Prisma.sheetsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sheetsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sheetsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sheetsPayload>
          }
          findMany: {
            args: Prisma.sheetsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sheetsPayload>[]
          }
          create: {
            args: Prisma.sheetsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sheetsPayload>
          }
          createMany: {
            args: Prisma.sheetsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.sheetsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sheetsPayload>
          }
          update: {
            args: Prisma.sheetsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sheetsPayload>
          }
          deleteMany: {
            args: Prisma.sheetsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.sheetsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.sheetsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sheetsPayload>
          }
          aggregate: {
            args: Prisma.SheetsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSheets>
          }
          groupBy: {
            args: Prisma.sheetsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SheetsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sheetsCountArgs<ExtArgs>,
            result: $Utils.Optional<SheetsCountAggregateOutputType> | number
          }
        }
      }
      sheets_data: {
        payload: Prisma.$sheets_dataPayload<ExtArgs>
        fields: Prisma.sheets_dataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sheets_dataFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sheets_dataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sheets_dataFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sheets_dataPayload>
          }
          findFirst: {
            args: Prisma.sheets_dataFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sheets_dataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sheets_dataFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sheets_dataPayload>
          }
          findMany: {
            args: Prisma.sheets_dataFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sheets_dataPayload>[]
          }
          create: {
            args: Prisma.sheets_dataCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sheets_dataPayload>
          }
          createMany: {
            args: Prisma.sheets_dataCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.sheets_dataDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sheets_dataPayload>
          }
          update: {
            args: Prisma.sheets_dataUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sheets_dataPayload>
          }
          deleteMany: {
            args: Prisma.sheets_dataDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.sheets_dataUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.sheets_dataUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sheets_dataPayload>
          }
          aggregate: {
            args: Prisma.Sheets_dataAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSheets_data>
          }
          groupBy: {
            args: Prisma.sheets_dataGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Sheets_dataGroupByOutputType>[]
          }
          count: {
            args: Prisma.sheets_dataCountArgs<ExtArgs>,
            result: $Utils.Optional<Sheets_dataCountAggregateOutputType> | number
          }
        }
      }
      sheets_thumbnails: {
        payload: Prisma.$sheets_thumbnailsPayload<ExtArgs>
        fields: Prisma.sheets_thumbnailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sheets_thumbnailsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sheets_thumbnailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sheets_thumbnailsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sheets_thumbnailsPayload>
          }
          findFirst: {
            args: Prisma.sheets_thumbnailsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sheets_thumbnailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sheets_thumbnailsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sheets_thumbnailsPayload>
          }
          findMany: {
            args: Prisma.sheets_thumbnailsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sheets_thumbnailsPayload>[]
          }
          create: {
            args: Prisma.sheets_thumbnailsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sheets_thumbnailsPayload>
          }
          createMany: {
            args: Prisma.sheets_thumbnailsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.sheets_thumbnailsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sheets_thumbnailsPayload>
          }
          update: {
            args: Prisma.sheets_thumbnailsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sheets_thumbnailsPayload>
          }
          deleteMany: {
            args: Prisma.sheets_thumbnailsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.sheets_thumbnailsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.sheets_thumbnailsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sheets_thumbnailsPayload>
          }
          aggregate: {
            args: Prisma.Sheets_thumbnailsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSheets_thumbnails>
          }
          groupBy: {
            args: Prisma.sheets_thumbnailsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Sheets_thumbnailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sheets_thumbnailsCountArgs<ExtArgs>,
            result: $Utils.Optional<Sheets_thumbnailsCountAggregateOutputType> | number
          }
        }
      }
      tables: {
        payload: Prisma.$tablesPayload<ExtArgs>
        fields: Prisma.tablesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tablesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tablesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tablesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tablesPayload>
          }
          findFirst: {
            args: Prisma.tablesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tablesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tablesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tablesPayload>
          }
          findMany: {
            args: Prisma.tablesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tablesPayload>[]
          }
          create: {
            args: Prisma.tablesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tablesPayload>
          }
          createMany: {
            args: Prisma.tablesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.tablesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tablesPayload>
          }
          update: {
            args: Prisma.tablesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tablesPayload>
          }
          deleteMany: {
            args: Prisma.tablesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.tablesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.tablesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tablesPayload>
          }
          aggregate: {
            args: Prisma.TablesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTables>
          }
          groupBy: {
            args: Prisma.tablesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TablesGroupByOutputType>[]
          }
          count: {
            args: Prisma.tablesCountArgs<ExtArgs>,
            result: $Utils.Optional<TablesCountAggregateOutputType> | number
          }
        }
      }
      tables_members: {
        payload: Prisma.$tables_membersPayload<ExtArgs>
        fields: Prisma.tables_membersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tables_membersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_membersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tables_membersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_membersPayload>
          }
          findFirst: {
            args: Prisma.tables_membersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_membersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tables_membersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_membersPayload>
          }
          findMany: {
            args: Prisma.tables_membersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_membersPayload>[]
          }
          create: {
            args: Prisma.tables_membersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_membersPayload>
          }
          createMany: {
            args: Prisma.tables_membersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.tables_membersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_membersPayload>
          }
          update: {
            args: Prisma.tables_membersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_membersPayload>
          }
          deleteMany: {
            args: Prisma.tables_membersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.tables_membersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.tables_membersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_membersPayload>
          }
          aggregate: {
            args: Prisma.Tables_membersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTables_members>
          }
          groupBy: {
            args: Prisma.tables_membersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tables_membersGroupByOutputType>[]
          }
          count: {
            args: Prisma.tables_membersCountArgs<ExtArgs>,
            result: $Utils.Optional<Tables_membersCountAggregateOutputType> | number
          }
        }
      }
      tables_messages_logs: {
        payload: Prisma.$tables_messages_logsPayload<ExtArgs>
        fields: Prisma.tables_messages_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tables_messages_logsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_messages_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tables_messages_logsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_messages_logsPayload>
          }
          findFirst: {
            args: Prisma.tables_messages_logsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_messages_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tables_messages_logsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_messages_logsPayload>
          }
          findMany: {
            args: Prisma.tables_messages_logsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_messages_logsPayload>[]
          }
          create: {
            args: Prisma.tables_messages_logsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_messages_logsPayload>
          }
          createMany: {
            args: Prisma.tables_messages_logsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.tables_messages_logsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_messages_logsPayload>
          }
          update: {
            args: Prisma.tables_messages_logsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_messages_logsPayload>
          }
          deleteMany: {
            args: Prisma.tables_messages_logsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.tables_messages_logsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.tables_messages_logsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_messages_logsPayload>
          }
          aggregate: {
            args: Prisma.Tables_messages_logsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTables_messages_logs>
          }
          groupBy: {
            args: Prisma.tables_messages_logsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tables_messages_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tables_messages_logsCountArgs<ExtArgs>,
            result: $Utils.Optional<Tables_messages_logsCountAggregateOutputType> | number
          }
        }
      }
      tables_pictures: {
        payload: Prisma.$tables_picturesPayload<ExtArgs>
        fields: Prisma.tables_picturesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tables_picturesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_picturesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tables_picturesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_picturesPayload>
          }
          findFirst: {
            args: Prisma.tables_picturesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_picturesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tables_picturesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_picturesPayload>
          }
          findMany: {
            args: Prisma.tables_picturesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_picturesPayload>[]
          }
          create: {
            args: Prisma.tables_picturesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_picturesPayload>
          }
          createMany: {
            args: Prisma.tables_picturesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.tables_picturesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_picturesPayload>
          }
          update: {
            args: Prisma.tables_picturesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_picturesPayload>
          }
          deleteMany: {
            args: Prisma.tables_picturesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.tables_picturesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.tables_picturesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_picturesPayload>
          }
          aggregate: {
            args: Prisma.Tables_picturesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTables_pictures>
          }
          groupBy: {
            args: Prisma.tables_picturesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tables_picturesGroupByOutputType>[]
          }
          count: {
            args: Prisma.tables_picturesCountArgs<ExtArgs>,
            result: $Utils.Optional<Tables_picturesCountAggregateOutputType> | number
          }
        }
      }
      tables_tabletops: {
        payload: Prisma.$tables_tabletopsPayload<ExtArgs>
        fields: Prisma.tables_tabletopsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tables_tabletopsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_tabletopsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tables_tabletopsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_tabletopsPayload>
          }
          findFirst: {
            args: Prisma.tables_tabletopsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_tabletopsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tables_tabletopsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_tabletopsPayload>
          }
          findMany: {
            args: Prisma.tables_tabletopsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_tabletopsPayload>[]
          }
          create: {
            args: Prisma.tables_tabletopsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_tabletopsPayload>
          }
          createMany: {
            args: Prisma.tables_tabletopsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.tables_tabletopsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_tabletopsPayload>
          }
          update: {
            args: Prisma.tables_tabletopsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_tabletopsPayload>
          }
          deleteMany: {
            args: Prisma.tables_tabletopsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.tables_tabletopsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.tables_tabletopsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_tabletopsPayload>
          }
          aggregate: {
            args: Prisma.Tables_tabletopsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTables_tabletops>
          }
          groupBy: {
            args: Prisma.tables_tabletopsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tables_tabletopsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tables_tabletopsCountArgs<ExtArgs>,
            result: $Utils.Optional<Tables_tabletopsCountAggregateOutputType> | number
          }
        }
      }
      tables_tabletops_data: {
        payload: Prisma.$tables_tabletops_dataPayload<ExtArgs>
        fields: Prisma.tables_tabletops_dataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tables_tabletops_dataFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_tabletops_dataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tables_tabletops_dataFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_tabletops_dataPayload>
          }
          findFirst: {
            args: Prisma.tables_tabletops_dataFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_tabletops_dataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tables_tabletops_dataFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_tabletops_dataPayload>
          }
          findMany: {
            args: Prisma.tables_tabletops_dataFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_tabletops_dataPayload>[]
          }
          create: {
            args: Prisma.tables_tabletops_dataCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_tabletops_dataPayload>
          }
          createMany: {
            args: Prisma.tables_tabletops_dataCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.tables_tabletops_dataDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_tabletops_dataPayload>
          }
          update: {
            args: Prisma.tables_tabletops_dataUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_tabletops_dataPayload>
          }
          deleteMany: {
            args: Prisma.tables_tabletops_dataDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.tables_tabletops_dataUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.tables_tabletops_dataUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tables_tabletops_dataPayload>
          }
          aggregate: {
            args: Prisma.Tables_tabletops_dataAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTables_tabletops_data>
          }
          groupBy: {
            args: Prisma.tables_tabletops_dataGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tables_tabletops_dataGroupByOutputType>[]
          }
          count: {
            args: Prisma.tables_tabletops_dataCountArgs<ExtArgs>,
            result: $Utils.Optional<Tables_tabletops_dataCountAggregateOutputType> | number
          }
        }
      }
      user_credentials: {
        payload: Prisma.$user_credentialsPayload<ExtArgs>
        fields: Prisma.user_credentialsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_credentialsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_credentialsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_credentialsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_credentialsPayload>
          }
          findFirst: {
            args: Prisma.user_credentialsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_credentialsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_credentialsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_credentialsPayload>
          }
          findMany: {
            args: Prisma.user_credentialsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_credentialsPayload>[]
          }
          create: {
            args: Prisma.user_credentialsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_credentialsPayload>
          }
          createMany: {
            args: Prisma.user_credentialsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.user_credentialsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_credentialsPayload>
          }
          update: {
            args: Prisma.user_credentialsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_credentialsPayload>
          }
          deleteMany: {
            args: Prisma.user_credentialsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.user_credentialsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.user_credentialsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_credentialsPayload>
          }
          aggregate: {
            args: Prisma.User_credentialsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser_credentials>
          }
          groupBy: {
            args: Prisma.user_credentialsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<User_credentialsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_credentialsCountArgs<ExtArgs>,
            result: $Utils.Optional<User_credentialsCountAggregateOutputType> | number
          }
        }
      }
      videos: {
        payload: Prisma.$videosPayload<ExtArgs>
        fields: Prisma.videosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.videosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.videosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videosPayload>
          }
          findFirst: {
            args: Prisma.videosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.videosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videosPayload>
          }
          findMany: {
            args: Prisma.videosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videosPayload>[]
          }
          create: {
            args: Prisma.videosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videosPayload>
          }
          createMany: {
            args: Prisma.videosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.videosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videosPayload>
          }
          update: {
            args: Prisma.videosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videosPayload>
          }
          deleteMany: {
            args: Prisma.videosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.videosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.videosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videosPayload>
          }
          aggregate: {
            args: Prisma.VideosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVideos>
          }
          groupBy: {
            args: Prisma.videosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VideosGroupByOutputType>[]
          }
          count: {
            args: Prisma.videosCountArgs<ExtArgs>,
            result: $Utils.Optional<VideosCountAggregateOutputType> | number
          }
        }
      }
      videos_data: {
        payload: Prisma.$videos_dataPayload<ExtArgs>
        fields: Prisma.videos_dataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.videos_dataFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videos_dataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.videos_dataFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videos_dataPayload>
          }
          findFirst: {
            args: Prisma.videos_dataFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videos_dataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.videos_dataFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videos_dataPayload>
          }
          findMany: {
            args: Prisma.videos_dataFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videos_dataPayload>[]
          }
          create: {
            args: Prisma.videos_dataCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videos_dataPayload>
          }
          createMany: {
            args: Prisma.videos_dataCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.videos_dataDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videos_dataPayload>
          }
          update: {
            args: Prisma.videos_dataUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videos_dataPayload>
          }
          deleteMany: {
            args: Prisma.videos_dataDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.videos_dataUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.videos_dataUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videos_dataPayload>
          }
          aggregate: {
            args: Prisma.Videos_dataAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVideos_data>
          }
          groupBy: {
            args: Prisma.videos_dataGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Videos_dataGroupByOutputType>[]
          }
          count: {
            args: Prisma.videos_dataCountArgs<ExtArgs>,
            result: $Utils.Optional<Videos_dataCountAggregateOutputType> | number
          }
        }
      }
      videos_thumbnails: {
        payload: Prisma.$videos_thumbnailsPayload<ExtArgs>
        fields: Prisma.videos_thumbnailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.videos_thumbnailsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videos_thumbnailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.videos_thumbnailsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videos_thumbnailsPayload>
          }
          findFirst: {
            args: Prisma.videos_thumbnailsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videos_thumbnailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.videos_thumbnailsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videos_thumbnailsPayload>
          }
          findMany: {
            args: Prisma.videos_thumbnailsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videos_thumbnailsPayload>[]
          }
          create: {
            args: Prisma.videos_thumbnailsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videos_thumbnailsPayload>
          }
          createMany: {
            args: Prisma.videos_thumbnailsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.videos_thumbnailsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videos_thumbnailsPayload>
          }
          update: {
            args: Prisma.videos_thumbnailsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videos_thumbnailsPayload>
          }
          deleteMany: {
            args: Prisma.videos_thumbnailsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.videos_thumbnailsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.videos_thumbnailsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videos_thumbnailsPayload>
          }
          aggregate: {
            args: Prisma.Videos_thumbnailsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVideos_thumbnails>
          }
          groupBy: {
            args: Prisma.videos_thumbnailsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Videos_thumbnailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.videos_thumbnailsCountArgs<ExtArgs>,
            result: $Utils.Optional<Videos_thumbnailsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CollectionsCountOutputType
   */

  export type CollectionsCountOutputType = {
    collections_content: number
  }

  export type CollectionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collections_content?: boolean | CollectionsCountOutputTypeCountCollections_contentArgs
  }

  // Custom InputTypes

  /**
   * CollectionsCountOutputType without action
   */
  export type CollectionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionsCountOutputType
     */
    select?: CollectionsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CollectionsCountOutputType without action
   */
  export type CollectionsCountOutputTypeCountCollections_contentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collections_contentWhereInput
  }



  /**
   * Count Type Contacts_picturesCountOutputType
   */

  export type Contacts_picturesCountOutputType = {
    contacts: number
  }

  export type Contacts_picturesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | Contacts_picturesCountOutputTypeCountContactsArgs
  }

  // Custom InputTypes

  /**
   * Contacts_picturesCountOutputType without action
   */
  export type Contacts_picturesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts_picturesCountOutputType
     */
    select?: Contacts_picturesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Contacts_picturesCountOutputType without action
   */
  export type Contacts_picturesCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contactsWhereInput
  }



  /**
   * Count Type ContentCountOutputType
   */

  export type ContentCountOutputType = {
    collections_content: number
    entities_content: number
    entities_dislikes: number
    entities_likes: number
  }

  export type ContentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collections_content?: boolean | ContentCountOutputTypeCountCollections_contentArgs
    entities_content?: boolean | ContentCountOutputTypeCountEntities_contentArgs
    entities_dislikes?: boolean | ContentCountOutputTypeCountEntities_dislikesArgs
    entities_likes?: boolean | ContentCountOutputTypeCountEntities_likesArgs
  }

  // Custom InputTypes

  /**
   * ContentCountOutputType without action
   */
  export type ContentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCountOutputType
     */
    select?: ContentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ContentCountOutputType without action
   */
  export type ContentCountOutputTypeCountCollections_contentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collections_contentWhereInput
  }


  /**
   * ContentCountOutputType without action
   */
  export type ContentCountOutputTypeCountEntities_contentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: entities_contentWhereInput
  }


  /**
   * ContentCountOutputType without action
   */
  export type ContentCountOutputTypeCountEntities_dislikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: entities_dislikesWhereInput
  }


  /**
   * ContentCountOutputType without action
   */
  export type ContentCountOutputTypeCountEntities_likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: entities_likesWhereInput
  }



  /**
   * Count Type ConversationsCountOutputType
   */

  export type ConversationsCountOutputType = {
    conversations_members: number
    conversations_messages_logs: number
  }

  export type ConversationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations_members?: boolean | ConversationsCountOutputTypeCountConversations_membersArgs
    conversations_messages_logs?: boolean | ConversationsCountOutputTypeCountConversations_messages_logsArgs
  }

  // Custom InputTypes

  /**
   * ConversationsCountOutputType without action
   */
  export type ConversationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationsCountOutputType
     */
    select?: ConversationsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ConversationsCountOutputType without action
   */
  export type ConversationsCountOutputTypeCountConversations_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conversations_membersWhereInput
  }


  /**
   * ConversationsCountOutputType without action
   */
  export type ConversationsCountOutputTypeCountConversations_messages_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conversations_messages_logsWhereInput
  }



  /**
   * Count Type Conversations_picturesCountOutputType
   */

  export type Conversations_picturesCountOutputType = {
    conversations: number
  }

  export type Conversations_picturesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations?: boolean | Conversations_picturesCountOutputTypeCountConversationsArgs
  }

  // Custom InputTypes

  /**
   * Conversations_picturesCountOutputType without action
   */
  export type Conversations_picturesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversations_picturesCountOutputType
     */
    select?: Conversations_picturesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Conversations_picturesCountOutputType without action
   */
  export type Conversations_picturesCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conversationsWhereInput
  }



  /**
   * Count Type EntitiesCountOutputType
   */

  export type EntitiesCountOutputType = {
    collections: number
    contacts_contacts_contact_id_rootToentities: number
    contacts_contacts_contact_id_targetToentities: number
    conversations_members: number
    conversations_messages_logs: number
    entities_content: number
    entities_dislikes: number
    entities_likes: number
    entities_references: number
    groups_members: number
    images: number
    organizations_members: number
    sheets: number
    tables_members: number
    tables_messages_logs: number
    tables_tabletops: number
    videos: number
  }

  export type EntitiesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collections?: boolean | EntitiesCountOutputTypeCountCollectionsArgs
    contacts_contacts_contact_id_rootToentities?: boolean | EntitiesCountOutputTypeCountContacts_contacts_contact_id_rootToentitiesArgs
    contacts_contacts_contact_id_targetToentities?: boolean | EntitiesCountOutputTypeCountContacts_contacts_contact_id_targetToentitiesArgs
    conversations_members?: boolean | EntitiesCountOutputTypeCountConversations_membersArgs
    conversations_messages_logs?: boolean | EntitiesCountOutputTypeCountConversations_messages_logsArgs
    entities_content?: boolean | EntitiesCountOutputTypeCountEntities_contentArgs
    entities_dislikes?: boolean | EntitiesCountOutputTypeCountEntities_dislikesArgs
    entities_likes?: boolean | EntitiesCountOutputTypeCountEntities_likesArgs
    entities_references?: boolean | EntitiesCountOutputTypeCountEntities_referencesArgs
    groups_members?: boolean | EntitiesCountOutputTypeCountGroups_membersArgs
    images?: boolean | EntitiesCountOutputTypeCountImagesArgs
    organizations_members?: boolean | EntitiesCountOutputTypeCountOrganizations_membersArgs
    sheets?: boolean | EntitiesCountOutputTypeCountSheetsArgs
    tables_members?: boolean | EntitiesCountOutputTypeCountTables_membersArgs
    tables_messages_logs?: boolean | EntitiesCountOutputTypeCountTables_messages_logsArgs
    tables_tabletops?: boolean | EntitiesCountOutputTypeCountTables_tabletopsArgs
    videos?: boolean | EntitiesCountOutputTypeCountVideosArgs
  }

  // Custom InputTypes

  /**
   * EntitiesCountOutputType without action
   */
  export type EntitiesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntitiesCountOutputType
     */
    select?: EntitiesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EntitiesCountOutputType without action
   */
  export type EntitiesCountOutputTypeCountCollectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collectionsWhereInput
  }


  /**
   * EntitiesCountOutputType without action
   */
  export type EntitiesCountOutputTypeCountContacts_contacts_contact_id_rootToentitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contactsWhereInput
  }


  /**
   * EntitiesCountOutputType without action
   */
  export type EntitiesCountOutputTypeCountContacts_contacts_contact_id_targetToentitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contactsWhereInput
  }


  /**
   * EntitiesCountOutputType without action
   */
  export type EntitiesCountOutputTypeCountConversations_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conversations_membersWhereInput
  }


  /**
   * EntitiesCountOutputType without action
   */
  export type EntitiesCountOutputTypeCountConversations_messages_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conversations_messages_logsWhereInput
  }


  /**
   * EntitiesCountOutputType without action
   */
  export type EntitiesCountOutputTypeCountEntities_contentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: entities_contentWhereInput
  }


  /**
   * EntitiesCountOutputType without action
   */
  export type EntitiesCountOutputTypeCountEntities_dislikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: entities_dislikesWhereInput
  }


  /**
   * EntitiesCountOutputType without action
   */
  export type EntitiesCountOutputTypeCountEntities_likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: entities_likesWhereInput
  }


  /**
   * EntitiesCountOutputType without action
   */
  export type EntitiesCountOutputTypeCountEntities_referencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: entities_referencesWhereInput
  }


  /**
   * EntitiesCountOutputType without action
   */
  export type EntitiesCountOutputTypeCountGroups_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: groups_membersWhereInput
  }


  /**
   * EntitiesCountOutputType without action
   */
  export type EntitiesCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: imagesWhereInput
  }


  /**
   * EntitiesCountOutputType without action
   */
  export type EntitiesCountOutputTypeCountOrganizations_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: organizations_membersWhereInput
  }


  /**
   * EntitiesCountOutputType without action
   */
  export type EntitiesCountOutputTypeCountSheetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sheetsWhereInput
  }


  /**
   * EntitiesCountOutputType without action
   */
  export type EntitiesCountOutputTypeCountTables_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tables_membersWhereInput
  }


  /**
   * EntitiesCountOutputType without action
   */
  export type EntitiesCountOutputTypeCountTables_messages_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tables_messages_logsWhereInput
  }


  /**
   * EntitiesCountOutputType without action
   */
  export type EntitiesCountOutputTypeCountTables_tabletopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tables_tabletopsWhereInput
  }


  /**
   * EntitiesCountOutputType without action
   */
  export type EntitiesCountOutputTypeCountVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: videosWhereInput
  }



  /**
   * Count Type GroupsCountOutputType
   */

  export type GroupsCountOutputType = {
    groups_members: number
  }

  export type GroupsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groups_members?: boolean | GroupsCountOutputTypeCountGroups_membersArgs
  }

  // Custom InputTypes

  /**
   * GroupsCountOutputType without action
   */
  export type GroupsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupsCountOutputType
     */
    select?: GroupsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * GroupsCountOutputType without action
   */
  export type GroupsCountOutputTypeCountGroups_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: groups_membersWhereInput
  }



  /**
   * Count Type Images_dataCountOutputType
   */

  export type Images_dataCountOutputType = {
    images: number
  }

  export type Images_dataCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | Images_dataCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes

  /**
   * Images_dataCountOutputType without action
   */
  export type Images_dataCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Images_dataCountOutputType
     */
    select?: Images_dataCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Images_dataCountOutputType without action
   */
  export type Images_dataCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: imagesWhereInput
  }



  /**
   * Count Type OrganizationsCountOutputType
   */

  export type OrganizationsCountOutputType = {
    organizations_members: number
  }

  export type OrganizationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations_members?: boolean | OrganizationsCountOutputTypeCountOrganizations_membersArgs
  }

  // Custom InputTypes

  /**
   * OrganizationsCountOutputType without action
   */
  export type OrganizationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationsCountOutputType
     */
    select?: OrganizationsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * OrganizationsCountOutputType without action
   */
  export type OrganizationsCountOutputTypeCountOrganizations_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: organizations_membersWhereInput
  }



  /**
   * Count Type Profile_picturesCountOutputType
   */

  export type Profile_picturesCountOutputType = {
    groups: number
    individuals: number
    organizations: number
  }

  export type Profile_picturesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groups?: boolean | Profile_picturesCountOutputTypeCountGroupsArgs
    individuals?: boolean | Profile_picturesCountOutputTypeCountIndividualsArgs
    organizations?: boolean | Profile_picturesCountOutputTypeCountOrganizationsArgs
  }

  // Custom InputTypes

  /**
   * Profile_picturesCountOutputType without action
   */
  export type Profile_picturesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile_picturesCountOutputType
     */
    select?: Profile_picturesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Profile_picturesCountOutputType without action
   */
  export type Profile_picturesCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: groupsWhereInput
  }


  /**
   * Profile_picturesCountOutputType without action
   */
  export type Profile_picturesCountOutputTypeCountIndividualsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: individualsWhereInput
  }


  /**
   * Profile_picturesCountOutputType without action
   */
  export type Profile_picturesCountOutputTypeCountOrganizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: organizationsWhereInput
  }



  /**
   * Count Type Sheets_dataCountOutputType
   */

  export type Sheets_dataCountOutputType = {
    sheets: number
  }

  export type Sheets_dataCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sheets?: boolean | Sheets_dataCountOutputTypeCountSheetsArgs
  }

  // Custom InputTypes

  /**
   * Sheets_dataCountOutputType without action
   */
  export type Sheets_dataCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sheets_dataCountOutputType
     */
    select?: Sheets_dataCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Sheets_dataCountOutputType without action
   */
  export type Sheets_dataCountOutputTypeCountSheetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sheetsWhereInput
  }



  /**
   * Count Type Sheets_thumbnailsCountOutputType
   */

  export type Sheets_thumbnailsCountOutputType = {
    sheets: number
  }

  export type Sheets_thumbnailsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sheets?: boolean | Sheets_thumbnailsCountOutputTypeCountSheetsArgs
  }

  // Custom InputTypes

  /**
   * Sheets_thumbnailsCountOutputType without action
   */
  export type Sheets_thumbnailsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sheets_thumbnailsCountOutputType
     */
    select?: Sheets_thumbnailsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Sheets_thumbnailsCountOutputType without action
   */
  export type Sheets_thumbnailsCountOutputTypeCountSheetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sheetsWhereInput
  }



  /**
   * Count Type TablesCountOutputType
   */

  export type TablesCountOutputType = {
    tables_members: number
    tables_messages_logs: number
    tables_tabletops: number
  }

  export type TablesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tables_members?: boolean | TablesCountOutputTypeCountTables_membersArgs
    tables_messages_logs?: boolean | TablesCountOutputTypeCountTables_messages_logsArgs
    tables_tabletops?: boolean | TablesCountOutputTypeCountTables_tabletopsArgs
  }

  // Custom InputTypes

  /**
   * TablesCountOutputType without action
   */
  export type TablesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TablesCountOutputType
     */
    select?: TablesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TablesCountOutputType without action
   */
  export type TablesCountOutputTypeCountTables_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tables_membersWhereInput
  }


  /**
   * TablesCountOutputType without action
   */
  export type TablesCountOutputTypeCountTables_messages_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tables_messages_logsWhereInput
  }


  /**
   * TablesCountOutputType without action
   */
  export type TablesCountOutputTypeCountTables_tabletopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tables_tabletopsWhereInput
  }



  /**
   * Count Type Tables_picturesCountOutputType
   */

  export type Tables_picturesCountOutputType = {
    tables: number
  }

  export type Tables_picturesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tables?: boolean | Tables_picturesCountOutputTypeCountTablesArgs
  }

  // Custom InputTypes

  /**
   * Tables_picturesCountOutputType without action
   */
  export type Tables_picturesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tables_picturesCountOutputType
     */
    select?: Tables_picturesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Tables_picturesCountOutputType without action
   */
  export type Tables_picturesCountOutputTypeCountTablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tablesWhereInput
  }



  /**
   * Count Type Tables_tabletops_dataCountOutputType
   */

  export type Tables_tabletops_dataCountOutputType = {
    tables_tabletops: number
  }

  export type Tables_tabletops_dataCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tables_tabletops?: boolean | Tables_tabletops_dataCountOutputTypeCountTables_tabletopsArgs
  }

  // Custom InputTypes

  /**
   * Tables_tabletops_dataCountOutputType without action
   */
  export type Tables_tabletops_dataCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tables_tabletops_dataCountOutputType
     */
    select?: Tables_tabletops_dataCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Tables_tabletops_dataCountOutputType without action
   */
  export type Tables_tabletops_dataCountOutputTypeCountTables_tabletopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tables_tabletopsWhereInput
  }



  /**
   * Count Type Videos_dataCountOutputType
   */

  export type Videos_dataCountOutputType = {
    videos: number
  }

  export type Videos_dataCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videos?: boolean | Videos_dataCountOutputTypeCountVideosArgs
  }

  // Custom InputTypes

  /**
   * Videos_dataCountOutputType without action
   */
  export type Videos_dataCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videos_dataCountOutputType
     */
    select?: Videos_dataCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Videos_dataCountOutputType without action
   */
  export type Videos_dataCountOutputTypeCountVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: videosWhereInput
  }



  /**
   * Count Type Videos_thumbnailsCountOutputType
   */

  export type Videos_thumbnailsCountOutputType = {
    videos: number
  }

  export type Videos_thumbnailsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videos?: boolean | Videos_thumbnailsCountOutputTypeCountVideosArgs
  }

  // Custom InputTypes

  /**
   * Videos_thumbnailsCountOutputType without action
   */
  export type Videos_thumbnailsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videos_thumbnailsCountOutputType
     */
    select?: Videos_thumbnailsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Videos_thumbnailsCountOutputType without action
   */
  export type Videos_thumbnailsCountOutputTypeCountVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: videosWhereInput
  }



  /**
   * Models
   */

  /**
   * Model affiliates_relations
   */

  export type AggregateAffiliates_relations = {
    _count: Affiliates_relationsCountAggregateOutputType | null
    _min: Affiliates_relationsMinAggregateOutputType | null
    _max: Affiliates_relationsMaxAggregateOutputType | null
  }

  export type Affiliates_relationsMinAggregateOutputType = {
    affiliate_relation_id: string | null
    affiliate_id_root: string | null
    affiliate_id_target: string | null
    affiliate_relation_date: Date | null
  }

  export type Affiliates_relationsMaxAggregateOutputType = {
    affiliate_relation_id: string | null
    affiliate_id_root: string | null
    affiliate_id_target: string | null
    affiliate_relation_date: Date | null
  }

  export type Affiliates_relationsCountAggregateOutputType = {
    affiliate_relation_id: number
    affiliate_id_root: number
    affiliate_id_target: number
    affiliate_relation_date: number
    _all: number
  }


  export type Affiliates_relationsMinAggregateInputType = {
    affiliate_relation_id?: true
    affiliate_id_root?: true
    affiliate_id_target?: true
    affiliate_relation_date?: true
  }

  export type Affiliates_relationsMaxAggregateInputType = {
    affiliate_relation_id?: true
    affiliate_id_root?: true
    affiliate_id_target?: true
    affiliate_relation_date?: true
  }

  export type Affiliates_relationsCountAggregateInputType = {
    affiliate_relation_id?: true
    affiliate_id_root?: true
    affiliate_id_target?: true
    affiliate_relation_date?: true
    _all?: true
  }

  export type Affiliates_relationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which affiliates_relations to aggregate.
     */
    where?: affiliates_relationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of affiliates_relations to fetch.
     */
    orderBy?: affiliates_relationsOrderByWithRelationInput | affiliates_relationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: affiliates_relationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` affiliates_relations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` affiliates_relations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned affiliates_relations
    **/
    _count?: true | Affiliates_relationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Affiliates_relationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Affiliates_relationsMaxAggregateInputType
  }

  export type GetAffiliates_relationsAggregateType<T extends Affiliates_relationsAggregateArgs> = {
        [P in keyof T & keyof AggregateAffiliates_relations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAffiliates_relations[P]>
      : GetScalarType<T[P], AggregateAffiliates_relations[P]>
  }




  export type affiliates_relationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: affiliates_relationsWhereInput
    orderBy?: affiliates_relationsOrderByWithAggregationInput | affiliates_relationsOrderByWithAggregationInput[]
    by: Affiliates_relationsScalarFieldEnum[] | Affiliates_relationsScalarFieldEnum
    having?: affiliates_relationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Affiliates_relationsCountAggregateInputType | true
    _min?: Affiliates_relationsMinAggregateInputType
    _max?: Affiliates_relationsMaxAggregateInputType
  }

  export type Affiliates_relationsGroupByOutputType = {
    affiliate_relation_id: string
    affiliate_id_root: string
    affiliate_id_target: string
    affiliate_relation_date: Date
    _count: Affiliates_relationsCountAggregateOutputType | null
    _min: Affiliates_relationsMinAggregateOutputType | null
    _max: Affiliates_relationsMaxAggregateOutputType | null
  }

  type GetAffiliates_relationsGroupByPayload<T extends affiliates_relationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Affiliates_relationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Affiliates_relationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Affiliates_relationsGroupByOutputType[P]>
            : GetScalarType<T[P], Affiliates_relationsGroupByOutputType[P]>
        }
      >
    >


  export type affiliates_relationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    affiliate_relation_id?: boolean
    affiliate_id_root?: boolean
    affiliate_id_target?: boolean
    affiliate_relation_date?: boolean
  }, ExtArgs["result"]["affiliates_relations"]>

  export type affiliates_relationsSelectScalar = {
    affiliate_relation_id?: boolean
    affiliate_id_root?: boolean
    affiliate_id_target?: boolean
    affiliate_relation_date?: boolean
  }


  export type $affiliates_relationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "affiliates_relations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      affiliate_relation_id: string
      affiliate_id_root: string
      affiliate_id_target: string
      affiliate_relation_date: Date
    }, ExtArgs["result"]["affiliates_relations"]>
    composites: {}
  }


  type affiliates_relationsGetPayload<S extends boolean | null | undefined | affiliates_relationsDefaultArgs> = $Result.GetResult<Prisma.$affiliates_relationsPayload, S>

  type affiliates_relationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<affiliates_relationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Affiliates_relationsCountAggregateInputType | true
    }

  export interface affiliates_relationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['affiliates_relations'], meta: { name: 'affiliates_relations' } }
    /**
     * Find zero or one Affiliates_relations that matches the filter.
     * @param {affiliates_relationsFindUniqueArgs} args - Arguments to find a Affiliates_relations
     * @example
     * // Get one Affiliates_relations
     * const affiliates_relations = await prisma.affiliates_relations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends affiliates_relationsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, affiliates_relationsFindUniqueArgs<ExtArgs>>
    ): Prisma__affiliates_relationsClient<$Result.GetResult<Prisma.$affiliates_relationsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Affiliates_relations that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {affiliates_relationsFindUniqueOrThrowArgs} args - Arguments to find a Affiliates_relations
     * @example
     * // Get one Affiliates_relations
     * const affiliates_relations = await prisma.affiliates_relations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends affiliates_relationsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, affiliates_relationsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__affiliates_relationsClient<$Result.GetResult<Prisma.$affiliates_relationsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Affiliates_relations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {affiliates_relationsFindFirstArgs} args - Arguments to find a Affiliates_relations
     * @example
     * // Get one Affiliates_relations
     * const affiliates_relations = await prisma.affiliates_relations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends affiliates_relationsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, affiliates_relationsFindFirstArgs<ExtArgs>>
    ): Prisma__affiliates_relationsClient<$Result.GetResult<Prisma.$affiliates_relationsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Affiliates_relations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {affiliates_relationsFindFirstOrThrowArgs} args - Arguments to find a Affiliates_relations
     * @example
     * // Get one Affiliates_relations
     * const affiliates_relations = await prisma.affiliates_relations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends affiliates_relationsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, affiliates_relationsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__affiliates_relationsClient<$Result.GetResult<Prisma.$affiliates_relationsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Affiliates_relations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {affiliates_relationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Affiliates_relations
     * const affiliates_relations = await prisma.affiliates_relations.findMany()
     * 
     * // Get first 10 Affiliates_relations
     * const affiliates_relations = await prisma.affiliates_relations.findMany({ take: 10 })
     * 
     * // Only select the `affiliate_relation_id`
     * const affiliates_relationsWithAffiliate_relation_idOnly = await prisma.affiliates_relations.findMany({ select: { affiliate_relation_id: true } })
     * 
    **/
    findMany<T extends affiliates_relationsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, affiliates_relationsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$affiliates_relationsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Affiliates_relations.
     * @param {affiliates_relationsCreateArgs} args - Arguments to create a Affiliates_relations.
     * @example
     * // Create one Affiliates_relations
     * const Affiliates_relations = await prisma.affiliates_relations.create({
     *   data: {
     *     // ... data to create a Affiliates_relations
     *   }
     * })
     * 
    **/
    create<T extends affiliates_relationsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, affiliates_relationsCreateArgs<ExtArgs>>
    ): Prisma__affiliates_relationsClient<$Result.GetResult<Prisma.$affiliates_relationsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Affiliates_relations.
     *     @param {affiliates_relationsCreateManyArgs} args - Arguments to create many Affiliates_relations.
     *     @example
     *     // Create many Affiliates_relations
     *     const affiliates_relations = await prisma.affiliates_relations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends affiliates_relationsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, affiliates_relationsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Affiliates_relations.
     * @param {affiliates_relationsDeleteArgs} args - Arguments to delete one Affiliates_relations.
     * @example
     * // Delete one Affiliates_relations
     * const Affiliates_relations = await prisma.affiliates_relations.delete({
     *   where: {
     *     // ... filter to delete one Affiliates_relations
     *   }
     * })
     * 
    **/
    delete<T extends affiliates_relationsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, affiliates_relationsDeleteArgs<ExtArgs>>
    ): Prisma__affiliates_relationsClient<$Result.GetResult<Prisma.$affiliates_relationsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Affiliates_relations.
     * @param {affiliates_relationsUpdateArgs} args - Arguments to update one Affiliates_relations.
     * @example
     * // Update one Affiliates_relations
     * const affiliates_relations = await prisma.affiliates_relations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends affiliates_relationsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, affiliates_relationsUpdateArgs<ExtArgs>>
    ): Prisma__affiliates_relationsClient<$Result.GetResult<Prisma.$affiliates_relationsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Affiliates_relations.
     * @param {affiliates_relationsDeleteManyArgs} args - Arguments to filter Affiliates_relations to delete.
     * @example
     * // Delete a few Affiliates_relations
     * const { count } = await prisma.affiliates_relations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends affiliates_relationsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, affiliates_relationsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Affiliates_relations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {affiliates_relationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Affiliates_relations
     * const affiliates_relations = await prisma.affiliates_relations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends affiliates_relationsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, affiliates_relationsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Affiliates_relations.
     * @param {affiliates_relationsUpsertArgs} args - Arguments to update or create a Affiliates_relations.
     * @example
     * // Update or create a Affiliates_relations
     * const affiliates_relations = await prisma.affiliates_relations.upsert({
     *   create: {
     *     // ... data to create a Affiliates_relations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Affiliates_relations we want to update
     *   }
     * })
    **/
    upsert<T extends affiliates_relationsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, affiliates_relationsUpsertArgs<ExtArgs>>
    ): Prisma__affiliates_relationsClient<$Result.GetResult<Prisma.$affiliates_relationsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Affiliates_relations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {affiliates_relationsCountArgs} args - Arguments to filter Affiliates_relations to count.
     * @example
     * // Count the number of Affiliates_relations
     * const count = await prisma.affiliates_relations.count({
     *   where: {
     *     // ... the filter for the Affiliates_relations we want to count
     *   }
     * })
    **/
    count<T extends affiliates_relationsCountArgs>(
      args?: Subset<T, affiliates_relationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Affiliates_relationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Affiliates_relations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Affiliates_relationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Affiliates_relationsAggregateArgs>(args: Subset<T, Affiliates_relationsAggregateArgs>): Prisma.PrismaPromise<GetAffiliates_relationsAggregateType<T>>

    /**
     * Group by Affiliates_relations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {affiliates_relationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends affiliates_relationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: affiliates_relationsGroupByArgs['orderBy'] }
        : { orderBy?: affiliates_relationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, affiliates_relationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAffiliates_relationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the affiliates_relations model
   */
  readonly fields: affiliates_relationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for affiliates_relations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__affiliates_relationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the affiliates_relations model
   */ 
  interface affiliates_relationsFieldRefs {
    readonly affiliate_relation_id: FieldRef<"affiliates_relations", 'String'>
    readonly affiliate_id_root: FieldRef<"affiliates_relations", 'String'>
    readonly affiliate_id_target: FieldRef<"affiliates_relations", 'String'>
    readonly affiliate_relation_date: FieldRef<"affiliates_relations", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * affiliates_relations findUnique
   */
  export type affiliates_relationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affiliates_relations
     */
    select?: affiliates_relationsSelect<ExtArgs> | null
    /**
     * Filter, which affiliates_relations to fetch.
     */
    where: affiliates_relationsWhereUniqueInput
  }


  /**
   * affiliates_relations findUniqueOrThrow
   */
  export type affiliates_relationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affiliates_relations
     */
    select?: affiliates_relationsSelect<ExtArgs> | null
    /**
     * Filter, which affiliates_relations to fetch.
     */
    where: affiliates_relationsWhereUniqueInput
  }


  /**
   * affiliates_relations findFirst
   */
  export type affiliates_relationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affiliates_relations
     */
    select?: affiliates_relationsSelect<ExtArgs> | null
    /**
     * Filter, which affiliates_relations to fetch.
     */
    where?: affiliates_relationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of affiliates_relations to fetch.
     */
    orderBy?: affiliates_relationsOrderByWithRelationInput | affiliates_relationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for affiliates_relations.
     */
    cursor?: affiliates_relationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` affiliates_relations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` affiliates_relations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of affiliates_relations.
     */
    distinct?: Affiliates_relationsScalarFieldEnum | Affiliates_relationsScalarFieldEnum[]
  }


  /**
   * affiliates_relations findFirstOrThrow
   */
  export type affiliates_relationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affiliates_relations
     */
    select?: affiliates_relationsSelect<ExtArgs> | null
    /**
     * Filter, which affiliates_relations to fetch.
     */
    where?: affiliates_relationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of affiliates_relations to fetch.
     */
    orderBy?: affiliates_relationsOrderByWithRelationInput | affiliates_relationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for affiliates_relations.
     */
    cursor?: affiliates_relationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` affiliates_relations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` affiliates_relations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of affiliates_relations.
     */
    distinct?: Affiliates_relationsScalarFieldEnum | Affiliates_relationsScalarFieldEnum[]
  }


  /**
   * affiliates_relations findMany
   */
  export type affiliates_relationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affiliates_relations
     */
    select?: affiliates_relationsSelect<ExtArgs> | null
    /**
     * Filter, which affiliates_relations to fetch.
     */
    where?: affiliates_relationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of affiliates_relations to fetch.
     */
    orderBy?: affiliates_relationsOrderByWithRelationInput | affiliates_relationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing affiliates_relations.
     */
    cursor?: affiliates_relationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` affiliates_relations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` affiliates_relations.
     */
    skip?: number
    distinct?: Affiliates_relationsScalarFieldEnum | Affiliates_relationsScalarFieldEnum[]
  }


  /**
   * affiliates_relations create
   */
  export type affiliates_relationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affiliates_relations
     */
    select?: affiliates_relationsSelect<ExtArgs> | null
    /**
     * The data needed to create a affiliates_relations.
     */
    data: XOR<affiliates_relationsCreateInput, affiliates_relationsUncheckedCreateInput>
  }


  /**
   * affiliates_relations createMany
   */
  export type affiliates_relationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many affiliates_relations.
     */
    data: affiliates_relationsCreateManyInput | affiliates_relationsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * affiliates_relations update
   */
  export type affiliates_relationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affiliates_relations
     */
    select?: affiliates_relationsSelect<ExtArgs> | null
    /**
     * The data needed to update a affiliates_relations.
     */
    data: XOR<affiliates_relationsUpdateInput, affiliates_relationsUncheckedUpdateInput>
    /**
     * Choose, which affiliates_relations to update.
     */
    where: affiliates_relationsWhereUniqueInput
  }


  /**
   * affiliates_relations updateMany
   */
  export type affiliates_relationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update affiliates_relations.
     */
    data: XOR<affiliates_relationsUpdateManyMutationInput, affiliates_relationsUncheckedUpdateManyInput>
    /**
     * Filter which affiliates_relations to update
     */
    where?: affiliates_relationsWhereInput
  }


  /**
   * affiliates_relations upsert
   */
  export type affiliates_relationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affiliates_relations
     */
    select?: affiliates_relationsSelect<ExtArgs> | null
    /**
     * The filter to search for the affiliates_relations to update in case it exists.
     */
    where: affiliates_relationsWhereUniqueInput
    /**
     * In case the affiliates_relations found by the `where` argument doesn't exist, create a new affiliates_relations with this data.
     */
    create: XOR<affiliates_relationsCreateInput, affiliates_relationsUncheckedCreateInput>
    /**
     * In case the affiliates_relations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<affiliates_relationsUpdateInput, affiliates_relationsUncheckedUpdateInput>
  }


  /**
   * affiliates_relations delete
   */
  export type affiliates_relationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affiliates_relations
     */
    select?: affiliates_relationsSelect<ExtArgs> | null
    /**
     * Filter which affiliates_relations to delete.
     */
    where: affiliates_relationsWhereUniqueInput
  }


  /**
   * affiliates_relations deleteMany
   */
  export type affiliates_relationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which affiliates_relations to delete
     */
    where?: affiliates_relationsWhereInput
  }


  /**
   * affiliates_relations without action
   */
  export type affiliates_relationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affiliates_relations
     */
    select?: affiliates_relationsSelect<ExtArgs> | null
  }



  /**
   * Model collections
   */

  export type AggregateCollections = {
    _count: CollectionsCountAggregateOutputType | null
    _min: CollectionsMinAggregateOutputType | null
    _max: CollectionsMaxAggregateOutputType | null
  }

  export type CollectionsMinAggregateOutputType = {
    collection_id: string | null
    collection_name: string | null
    entity_id: string | null
  }

  export type CollectionsMaxAggregateOutputType = {
    collection_id: string | null
    collection_name: string | null
    entity_id: string | null
  }

  export type CollectionsCountAggregateOutputType = {
    collection_id: number
    collection_name: number
    entity_id: number
    _all: number
  }


  export type CollectionsMinAggregateInputType = {
    collection_id?: true
    collection_name?: true
    entity_id?: true
  }

  export type CollectionsMaxAggregateInputType = {
    collection_id?: true
    collection_name?: true
    entity_id?: true
  }

  export type CollectionsCountAggregateInputType = {
    collection_id?: true
    collection_name?: true
    entity_id?: true
    _all?: true
  }

  export type CollectionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collections to aggregate.
     */
    where?: collectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collections to fetch.
     */
    orderBy?: collectionsOrderByWithRelationInput | collectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: collectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned collections
    **/
    _count?: true | CollectionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollectionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollectionsMaxAggregateInputType
  }

  export type GetCollectionsAggregateType<T extends CollectionsAggregateArgs> = {
        [P in keyof T & keyof AggregateCollections]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollections[P]>
      : GetScalarType<T[P], AggregateCollections[P]>
  }




  export type collectionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collectionsWhereInput
    orderBy?: collectionsOrderByWithAggregationInput | collectionsOrderByWithAggregationInput[]
    by: CollectionsScalarFieldEnum[] | CollectionsScalarFieldEnum
    having?: collectionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollectionsCountAggregateInputType | true
    _min?: CollectionsMinAggregateInputType
    _max?: CollectionsMaxAggregateInputType
  }

  export type CollectionsGroupByOutputType = {
    collection_id: string
    collection_name: string
    entity_id: string
    _count: CollectionsCountAggregateOutputType | null
    _min: CollectionsMinAggregateOutputType | null
    _max: CollectionsMaxAggregateOutputType | null
  }

  type GetCollectionsGroupByPayload<T extends collectionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CollectionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollectionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollectionsGroupByOutputType[P]>
            : GetScalarType<T[P], CollectionsGroupByOutputType[P]>
        }
      >
    >


  export type collectionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    collection_id?: boolean
    collection_name?: boolean
    entity_id?: boolean
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
    collections_content?: boolean | collections$collections_contentArgs<ExtArgs>
    _count?: boolean | CollectionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collections"]>

  export type collectionsSelectScalar = {
    collection_id?: boolean
    collection_name?: boolean
    entity_id?: boolean
  }

  export type collectionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
    collections_content?: boolean | collections$collections_contentArgs<ExtArgs>
    _count?: boolean | CollectionsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $collectionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "collections"
    objects: {
      entities: Prisma.$entitiesPayload<ExtArgs>
      collections_content: Prisma.$collections_contentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      collection_id: string
      collection_name: string
      entity_id: string
    }, ExtArgs["result"]["collections"]>
    composites: {}
  }


  type collectionsGetPayload<S extends boolean | null | undefined | collectionsDefaultArgs> = $Result.GetResult<Prisma.$collectionsPayload, S>

  type collectionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<collectionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CollectionsCountAggregateInputType | true
    }

  export interface collectionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['collections'], meta: { name: 'collections' } }
    /**
     * Find zero or one Collections that matches the filter.
     * @param {collectionsFindUniqueArgs} args - Arguments to find a Collections
     * @example
     * // Get one Collections
     * const collections = await prisma.collections.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends collectionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, collectionsFindUniqueArgs<ExtArgs>>
    ): Prisma__collectionsClient<$Result.GetResult<Prisma.$collectionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Collections that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {collectionsFindUniqueOrThrowArgs} args - Arguments to find a Collections
     * @example
     * // Get one Collections
     * const collections = await prisma.collections.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends collectionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, collectionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__collectionsClient<$Result.GetResult<Prisma.$collectionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Collections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectionsFindFirstArgs} args - Arguments to find a Collections
     * @example
     * // Get one Collections
     * const collections = await prisma.collections.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends collectionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, collectionsFindFirstArgs<ExtArgs>>
    ): Prisma__collectionsClient<$Result.GetResult<Prisma.$collectionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Collections that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectionsFindFirstOrThrowArgs} args - Arguments to find a Collections
     * @example
     * // Get one Collections
     * const collections = await prisma.collections.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends collectionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, collectionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__collectionsClient<$Result.GetResult<Prisma.$collectionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Collections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collections
     * const collections = await prisma.collections.findMany()
     * 
     * // Get first 10 Collections
     * const collections = await prisma.collections.findMany({ take: 10 })
     * 
     * // Only select the `collection_id`
     * const collectionsWithCollection_idOnly = await prisma.collections.findMany({ select: { collection_id: true } })
     * 
    **/
    findMany<T extends collectionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, collectionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collectionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Collections.
     * @param {collectionsCreateArgs} args - Arguments to create a Collections.
     * @example
     * // Create one Collections
     * const Collections = await prisma.collections.create({
     *   data: {
     *     // ... data to create a Collections
     *   }
     * })
     * 
    **/
    create<T extends collectionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, collectionsCreateArgs<ExtArgs>>
    ): Prisma__collectionsClient<$Result.GetResult<Prisma.$collectionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Collections.
     *     @param {collectionsCreateManyArgs} args - Arguments to create many Collections.
     *     @example
     *     // Create many Collections
     *     const collections = await prisma.collections.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends collectionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, collectionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Collections.
     * @param {collectionsDeleteArgs} args - Arguments to delete one Collections.
     * @example
     * // Delete one Collections
     * const Collections = await prisma.collections.delete({
     *   where: {
     *     // ... filter to delete one Collections
     *   }
     * })
     * 
    **/
    delete<T extends collectionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, collectionsDeleteArgs<ExtArgs>>
    ): Prisma__collectionsClient<$Result.GetResult<Prisma.$collectionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Collections.
     * @param {collectionsUpdateArgs} args - Arguments to update one Collections.
     * @example
     * // Update one Collections
     * const collections = await prisma.collections.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends collectionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, collectionsUpdateArgs<ExtArgs>>
    ): Prisma__collectionsClient<$Result.GetResult<Prisma.$collectionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Collections.
     * @param {collectionsDeleteManyArgs} args - Arguments to filter Collections to delete.
     * @example
     * // Delete a few Collections
     * const { count } = await prisma.collections.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends collectionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, collectionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collections
     * const collections = await prisma.collections.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends collectionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, collectionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Collections.
     * @param {collectionsUpsertArgs} args - Arguments to update or create a Collections.
     * @example
     * // Update or create a Collections
     * const collections = await prisma.collections.upsert({
     *   create: {
     *     // ... data to create a Collections
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collections we want to update
     *   }
     * })
    **/
    upsert<T extends collectionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, collectionsUpsertArgs<ExtArgs>>
    ): Prisma__collectionsClient<$Result.GetResult<Prisma.$collectionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectionsCountArgs} args - Arguments to filter Collections to count.
     * @example
     * // Count the number of Collections
     * const count = await prisma.collections.count({
     *   where: {
     *     // ... the filter for the Collections we want to count
     *   }
     * })
    **/
    count<T extends collectionsCountArgs>(
      args?: Subset<T, collectionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollectionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollectionsAggregateArgs>(args: Subset<T, CollectionsAggregateArgs>): Prisma.PrismaPromise<GetCollectionsAggregateType<T>>

    /**
     * Group by Collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends collectionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: collectionsGroupByArgs['orderBy'] }
        : { orderBy?: collectionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, collectionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollectionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the collections model
   */
  readonly fields: collectionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for collections.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__collectionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    entities<T extends entitiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, entitiesDefaultArgs<ExtArgs>>): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    collections_content<T extends collections$collections_contentArgs<ExtArgs> = {}>(args?: Subset<T, collections$collections_contentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collections_contentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the collections model
   */ 
  interface collectionsFieldRefs {
    readonly collection_id: FieldRef<"collections", 'String'>
    readonly collection_name: FieldRef<"collections", 'String'>
    readonly entity_id: FieldRef<"collections", 'String'>
  }
    

  // Custom InputTypes

  /**
   * collections findUnique
   */
  export type collectionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collections
     */
    select?: collectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collectionsInclude<ExtArgs> | null
    /**
     * Filter, which collections to fetch.
     */
    where: collectionsWhereUniqueInput
  }


  /**
   * collections findUniqueOrThrow
   */
  export type collectionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collections
     */
    select?: collectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collectionsInclude<ExtArgs> | null
    /**
     * Filter, which collections to fetch.
     */
    where: collectionsWhereUniqueInput
  }


  /**
   * collections findFirst
   */
  export type collectionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collections
     */
    select?: collectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collectionsInclude<ExtArgs> | null
    /**
     * Filter, which collections to fetch.
     */
    where?: collectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collections to fetch.
     */
    orderBy?: collectionsOrderByWithRelationInput | collectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collections.
     */
    cursor?: collectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collections.
     */
    distinct?: CollectionsScalarFieldEnum | CollectionsScalarFieldEnum[]
  }


  /**
   * collections findFirstOrThrow
   */
  export type collectionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collections
     */
    select?: collectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collectionsInclude<ExtArgs> | null
    /**
     * Filter, which collections to fetch.
     */
    where?: collectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collections to fetch.
     */
    orderBy?: collectionsOrderByWithRelationInput | collectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collections.
     */
    cursor?: collectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collections.
     */
    distinct?: CollectionsScalarFieldEnum | CollectionsScalarFieldEnum[]
  }


  /**
   * collections findMany
   */
  export type collectionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collections
     */
    select?: collectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collectionsInclude<ExtArgs> | null
    /**
     * Filter, which collections to fetch.
     */
    where?: collectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collections to fetch.
     */
    orderBy?: collectionsOrderByWithRelationInput | collectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing collections.
     */
    cursor?: collectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collections.
     */
    skip?: number
    distinct?: CollectionsScalarFieldEnum | CollectionsScalarFieldEnum[]
  }


  /**
   * collections create
   */
  export type collectionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collections
     */
    select?: collectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collectionsInclude<ExtArgs> | null
    /**
     * The data needed to create a collections.
     */
    data: XOR<collectionsCreateInput, collectionsUncheckedCreateInput>
  }


  /**
   * collections createMany
   */
  export type collectionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many collections.
     */
    data: collectionsCreateManyInput | collectionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * collections update
   */
  export type collectionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collections
     */
    select?: collectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collectionsInclude<ExtArgs> | null
    /**
     * The data needed to update a collections.
     */
    data: XOR<collectionsUpdateInput, collectionsUncheckedUpdateInput>
    /**
     * Choose, which collections to update.
     */
    where: collectionsWhereUniqueInput
  }


  /**
   * collections updateMany
   */
  export type collectionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update collections.
     */
    data: XOR<collectionsUpdateManyMutationInput, collectionsUncheckedUpdateManyInput>
    /**
     * Filter which collections to update
     */
    where?: collectionsWhereInput
  }


  /**
   * collections upsert
   */
  export type collectionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collections
     */
    select?: collectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collectionsInclude<ExtArgs> | null
    /**
     * The filter to search for the collections to update in case it exists.
     */
    where: collectionsWhereUniqueInput
    /**
     * In case the collections found by the `where` argument doesn't exist, create a new collections with this data.
     */
    create: XOR<collectionsCreateInput, collectionsUncheckedCreateInput>
    /**
     * In case the collections was found with the provided `where` argument, update it with this data.
     */
    update: XOR<collectionsUpdateInput, collectionsUncheckedUpdateInput>
  }


  /**
   * collections delete
   */
  export type collectionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collections
     */
    select?: collectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collectionsInclude<ExtArgs> | null
    /**
     * Filter which collections to delete.
     */
    where: collectionsWhereUniqueInput
  }


  /**
   * collections deleteMany
   */
  export type collectionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collections to delete
     */
    where?: collectionsWhereInput
  }


  /**
   * collections.collections_content
   */
  export type collections$collections_contentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collections_content
     */
    select?: collections_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collections_contentInclude<ExtArgs> | null
    where?: collections_contentWhereInput
    orderBy?: collections_contentOrderByWithRelationInput | collections_contentOrderByWithRelationInput[]
    cursor?: collections_contentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Collections_contentScalarFieldEnum | Collections_contentScalarFieldEnum[]
  }


  /**
   * collections without action
   */
  export type collectionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collections
     */
    select?: collectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collectionsInclude<ExtArgs> | null
  }



  /**
   * Model collections_content
   */

  export type AggregateCollections_content = {
    _count: Collections_contentCountAggregateOutputType | null
    _min: Collections_contentMinAggregateOutputType | null
    _max: Collections_contentMaxAggregateOutputType | null
  }

  export type Collections_contentMinAggregateOutputType = {
    collections_content_id: string | null
    collection_id: string | null
    content_id: string | null
    date_added: Date | null
    pinned: boolean | null
    date_pinned: Date | null
  }

  export type Collections_contentMaxAggregateOutputType = {
    collections_content_id: string | null
    collection_id: string | null
    content_id: string | null
    date_added: Date | null
    pinned: boolean | null
    date_pinned: Date | null
  }

  export type Collections_contentCountAggregateOutputType = {
    collections_content_id: number
    collection_id: number
    content_id: number
    date_added: number
    pinned: number
    date_pinned: number
    _all: number
  }


  export type Collections_contentMinAggregateInputType = {
    collections_content_id?: true
    collection_id?: true
    content_id?: true
    date_added?: true
    pinned?: true
    date_pinned?: true
  }

  export type Collections_contentMaxAggregateInputType = {
    collections_content_id?: true
    collection_id?: true
    content_id?: true
    date_added?: true
    pinned?: true
    date_pinned?: true
  }

  export type Collections_contentCountAggregateInputType = {
    collections_content_id?: true
    collection_id?: true
    content_id?: true
    date_added?: true
    pinned?: true
    date_pinned?: true
    _all?: true
  }

  export type Collections_contentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collections_content to aggregate.
     */
    where?: collections_contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collections_contents to fetch.
     */
    orderBy?: collections_contentOrderByWithRelationInput | collections_contentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: collections_contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collections_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collections_contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned collections_contents
    **/
    _count?: true | Collections_contentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Collections_contentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Collections_contentMaxAggregateInputType
  }

  export type GetCollections_contentAggregateType<T extends Collections_contentAggregateArgs> = {
        [P in keyof T & keyof AggregateCollections_content]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollections_content[P]>
      : GetScalarType<T[P], AggregateCollections_content[P]>
  }




  export type collections_contentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collections_contentWhereInput
    orderBy?: collections_contentOrderByWithAggregationInput | collections_contentOrderByWithAggregationInput[]
    by: Collections_contentScalarFieldEnum[] | Collections_contentScalarFieldEnum
    having?: collections_contentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Collections_contentCountAggregateInputType | true
    _min?: Collections_contentMinAggregateInputType
    _max?: Collections_contentMaxAggregateInputType
  }

  export type Collections_contentGroupByOutputType = {
    collections_content_id: string
    collection_id: string
    content_id: string
    date_added: Date
    pinned: boolean
    date_pinned: Date | null
    _count: Collections_contentCountAggregateOutputType | null
    _min: Collections_contentMinAggregateOutputType | null
    _max: Collections_contentMaxAggregateOutputType | null
  }

  type GetCollections_contentGroupByPayload<T extends collections_contentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Collections_contentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Collections_contentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Collections_contentGroupByOutputType[P]>
            : GetScalarType<T[P], Collections_contentGroupByOutputType[P]>
        }
      >
    >


  export type collections_contentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    collections_content_id?: boolean
    collection_id?: boolean
    content_id?: boolean
    date_added?: boolean
    pinned?: boolean
    date_pinned?: boolean
    collections?: boolean | collectionsDefaultArgs<ExtArgs>
    content?: boolean | contentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collections_content"]>

  export type collections_contentSelectScalar = {
    collections_content_id?: boolean
    collection_id?: boolean
    content_id?: boolean
    date_added?: boolean
    pinned?: boolean
    date_pinned?: boolean
  }

  export type collections_contentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collections?: boolean | collectionsDefaultArgs<ExtArgs>
    content?: boolean | contentDefaultArgs<ExtArgs>
  }


  export type $collections_contentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "collections_content"
    objects: {
      collections: Prisma.$collectionsPayload<ExtArgs>
      content: Prisma.$contentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      collections_content_id: string
      collection_id: string
      content_id: string
      date_added: Date
      pinned: boolean
      date_pinned: Date | null
    }, ExtArgs["result"]["collections_content"]>
    composites: {}
  }


  type collections_contentGetPayload<S extends boolean | null | undefined | collections_contentDefaultArgs> = $Result.GetResult<Prisma.$collections_contentPayload, S>

  type collections_contentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<collections_contentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Collections_contentCountAggregateInputType | true
    }

  export interface collections_contentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['collections_content'], meta: { name: 'collections_content' } }
    /**
     * Find zero or one Collections_content that matches the filter.
     * @param {collections_contentFindUniqueArgs} args - Arguments to find a Collections_content
     * @example
     * // Get one Collections_content
     * const collections_content = await prisma.collections_content.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends collections_contentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, collections_contentFindUniqueArgs<ExtArgs>>
    ): Prisma__collections_contentClient<$Result.GetResult<Prisma.$collections_contentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Collections_content that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {collections_contentFindUniqueOrThrowArgs} args - Arguments to find a Collections_content
     * @example
     * // Get one Collections_content
     * const collections_content = await prisma.collections_content.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends collections_contentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, collections_contentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__collections_contentClient<$Result.GetResult<Prisma.$collections_contentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Collections_content that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collections_contentFindFirstArgs} args - Arguments to find a Collections_content
     * @example
     * // Get one Collections_content
     * const collections_content = await prisma.collections_content.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends collections_contentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, collections_contentFindFirstArgs<ExtArgs>>
    ): Prisma__collections_contentClient<$Result.GetResult<Prisma.$collections_contentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Collections_content that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collections_contentFindFirstOrThrowArgs} args - Arguments to find a Collections_content
     * @example
     * // Get one Collections_content
     * const collections_content = await prisma.collections_content.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends collections_contentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, collections_contentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__collections_contentClient<$Result.GetResult<Prisma.$collections_contentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Collections_contents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collections_contentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collections_contents
     * const collections_contents = await prisma.collections_content.findMany()
     * 
     * // Get first 10 Collections_contents
     * const collections_contents = await prisma.collections_content.findMany({ take: 10 })
     * 
     * // Only select the `collections_content_id`
     * const collections_contentWithCollections_content_idOnly = await prisma.collections_content.findMany({ select: { collections_content_id: true } })
     * 
    **/
    findMany<T extends collections_contentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, collections_contentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collections_contentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Collections_content.
     * @param {collections_contentCreateArgs} args - Arguments to create a Collections_content.
     * @example
     * // Create one Collections_content
     * const Collections_content = await prisma.collections_content.create({
     *   data: {
     *     // ... data to create a Collections_content
     *   }
     * })
     * 
    **/
    create<T extends collections_contentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, collections_contentCreateArgs<ExtArgs>>
    ): Prisma__collections_contentClient<$Result.GetResult<Prisma.$collections_contentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Collections_contents.
     *     @param {collections_contentCreateManyArgs} args - Arguments to create many Collections_contents.
     *     @example
     *     // Create many Collections_contents
     *     const collections_content = await prisma.collections_content.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends collections_contentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, collections_contentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Collections_content.
     * @param {collections_contentDeleteArgs} args - Arguments to delete one Collections_content.
     * @example
     * // Delete one Collections_content
     * const Collections_content = await prisma.collections_content.delete({
     *   where: {
     *     // ... filter to delete one Collections_content
     *   }
     * })
     * 
    **/
    delete<T extends collections_contentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, collections_contentDeleteArgs<ExtArgs>>
    ): Prisma__collections_contentClient<$Result.GetResult<Prisma.$collections_contentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Collections_content.
     * @param {collections_contentUpdateArgs} args - Arguments to update one Collections_content.
     * @example
     * // Update one Collections_content
     * const collections_content = await prisma.collections_content.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends collections_contentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, collections_contentUpdateArgs<ExtArgs>>
    ): Prisma__collections_contentClient<$Result.GetResult<Prisma.$collections_contentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Collections_contents.
     * @param {collections_contentDeleteManyArgs} args - Arguments to filter Collections_contents to delete.
     * @example
     * // Delete a few Collections_contents
     * const { count } = await prisma.collections_content.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends collections_contentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, collections_contentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collections_contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collections_contentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collections_contents
     * const collections_content = await prisma.collections_content.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends collections_contentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, collections_contentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Collections_content.
     * @param {collections_contentUpsertArgs} args - Arguments to update or create a Collections_content.
     * @example
     * // Update or create a Collections_content
     * const collections_content = await prisma.collections_content.upsert({
     *   create: {
     *     // ... data to create a Collections_content
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collections_content we want to update
     *   }
     * })
    **/
    upsert<T extends collections_contentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, collections_contentUpsertArgs<ExtArgs>>
    ): Prisma__collections_contentClient<$Result.GetResult<Prisma.$collections_contentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Collections_contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collections_contentCountArgs} args - Arguments to filter Collections_contents to count.
     * @example
     * // Count the number of Collections_contents
     * const count = await prisma.collections_content.count({
     *   where: {
     *     // ... the filter for the Collections_contents we want to count
     *   }
     * })
    **/
    count<T extends collections_contentCountArgs>(
      args?: Subset<T, collections_contentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Collections_contentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collections_content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Collections_contentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Collections_contentAggregateArgs>(args: Subset<T, Collections_contentAggregateArgs>): Prisma.PrismaPromise<GetCollections_contentAggregateType<T>>

    /**
     * Group by Collections_content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collections_contentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends collections_contentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: collections_contentGroupByArgs['orderBy'] }
        : { orderBy?: collections_contentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, collections_contentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollections_contentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the collections_content model
   */
  readonly fields: collections_contentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for collections_content.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__collections_contentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    collections<T extends collectionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, collectionsDefaultArgs<ExtArgs>>): Prisma__collectionsClient<$Result.GetResult<Prisma.$collectionsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    content<T extends contentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, contentDefaultArgs<ExtArgs>>): Prisma__contentClient<$Result.GetResult<Prisma.$contentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the collections_content model
   */ 
  interface collections_contentFieldRefs {
    readonly collections_content_id: FieldRef<"collections_content", 'String'>
    readonly collection_id: FieldRef<"collections_content", 'String'>
    readonly content_id: FieldRef<"collections_content", 'String'>
    readonly date_added: FieldRef<"collections_content", 'DateTime'>
    readonly pinned: FieldRef<"collections_content", 'Boolean'>
    readonly date_pinned: FieldRef<"collections_content", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * collections_content findUnique
   */
  export type collections_contentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collections_content
     */
    select?: collections_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collections_contentInclude<ExtArgs> | null
    /**
     * Filter, which collections_content to fetch.
     */
    where: collections_contentWhereUniqueInput
  }


  /**
   * collections_content findUniqueOrThrow
   */
  export type collections_contentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collections_content
     */
    select?: collections_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collections_contentInclude<ExtArgs> | null
    /**
     * Filter, which collections_content to fetch.
     */
    where: collections_contentWhereUniqueInput
  }


  /**
   * collections_content findFirst
   */
  export type collections_contentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collections_content
     */
    select?: collections_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collections_contentInclude<ExtArgs> | null
    /**
     * Filter, which collections_content to fetch.
     */
    where?: collections_contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collections_contents to fetch.
     */
    orderBy?: collections_contentOrderByWithRelationInput | collections_contentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collections_contents.
     */
    cursor?: collections_contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collections_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collections_contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collections_contents.
     */
    distinct?: Collections_contentScalarFieldEnum | Collections_contentScalarFieldEnum[]
  }


  /**
   * collections_content findFirstOrThrow
   */
  export type collections_contentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collections_content
     */
    select?: collections_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collections_contentInclude<ExtArgs> | null
    /**
     * Filter, which collections_content to fetch.
     */
    where?: collections_contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collections_contents to fetch.
     */
    orderBy?: collections_contentOrderByWithRelationInput | collections_contentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collections_contents.
     */
    cursor?: collections_contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collections_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collections_contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collections_contents.
     */
    distinct?: Collections_contentScalarFieldEnum | Collections_contentScalarFieldEnum[]
  }


  /**
   * collections_content findMany
   */
  export type collections_contentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collections_content
     */
    select?: collections_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collections_contentInclude<ExtArgs> | null
    /**
     * Filter, which collections_contents to fetch.
     */
    where?: collections_contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collections_contents to fetch.
     */
    orderBy?: collections_contentOrderByWithRelationInput | collections_contentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing collections_contents.
     */
    cursor?: collections_contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collections_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collections_contents.
     */
    skip?: number
    distinct?: Collections_contentScalarFieldEnum | Collections_contentScalarFieldEnum[]
  }


  /**
   * collections_content create
   */
  export type collections_contentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collections_content
     */
    select?: collections_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collections_contentInclude<ExtArgs> | null
    /**
     * The data needed to create a collections_content.
     */
    data: XOR<collections_contentCreateInput, collections_contentUncheckedCreateInput>
  }


  /**
   * collections_content createMany
   */
  export type collections_contentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many collections_contents.
     */
    data: collections_contentCreateManyInput | collections_contentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * collections_content update
   */
  export type collections_contentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collections_content
     */
    select?: collections_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collections_contentInclude<ExtArgs> | null
    /**
     * The data needed to update a collections_content.
     */
    data: XOR<collections_contentUpdateInput, collections_contentUncheckedUpdateInput>
    /**
     * Choose, which collections_content to update.
     */
    where: collections_contentWhereUniqueInput
  }


  /**
   * collections_content updateMany
   */
  export type collections_contentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update collections_contents.
     */
    data: XOR<collections_contentUpdateManyMutationInput, collections_contentUncheckedUpdateManyInput>
    /**
     * Filter which collections_contents to update
     */
    where?: collections_contentWhereInput
  }


  /**
   * collections_content upsert
   */
  export type collections_contentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collections_content
     */
    select?: collections_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collections_contentInclude<ExtArgs> | null
    /**
     * The filter to search for the collections_content to update in case it exists.
     */
    where: collections_contentWhereUniqueInput
    /**
     * In case the collections_content found by the `where` argument doesn't exist, create a new collections_content with this data.
     */
    create: XOR<collections_contentCreateInput, collections_contentUncheckedCreateInput>
    /**
     * In case the collections_content was found with the provided `where` argument, update it with this data.
     */
    update: XOR<collections_contentUpdateInput, collections_contentUncheckedUpdateInput>
  }


  /**
   * collections_content delete
   */
  export type collections_contentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collections_content
     */
    select?: collections_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collections_contentInclude<ExtArgs> | null
    /**
     * Filter which collections_content to delete.
     */
    where: collections_contentWhereUniqueInput
  }


  /**
   * collections_content deleteMany
   */
  export type collections_contentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collections_contents to delete
     */
    where?: collections_contentWhereInput
  }


  /**
   * collections_content without action
   */
  export type collections_contentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collections_content
     */
    select?: collections_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collections_contentInclude<ExtArgs> | null
  }



  /**
   * Model contacts
   */

  export type AggregateContacts = {
    _count: ContactsCountAggregateOutputType | null
    _min: ContactsMinAggregateOutputType | null
    _max: ContactsMaxAggregateOutputType | null
  }

  export type ContactsMinAggregateOutputType = {
    contact_id: string | null
    conversation_id: string | null
    contact_id_root: string | null
    contact_id_target: string | null
    contact_creation_date: Date | null
    last_message: string | null
    last_contact_date: Date | null
    contacts_pictures_id: string | null
  }

  export type ContactsMaxAggregateOutputType = {
    contact_id: string | null
    conversation_id: string | null
    contact_id_root: string | null
    contact_id_target: string | null
    contact_creation_date: Date | null
    last_message: string | null
    last_contact_date: Date | null
    contacts_pictures_id: string | null
  }

  export type ContactsCountAggregateOutputType = {
    contact_id: number
    conversation_id: number
    contact_id_root: number
    contact_id_target: number
    contact_creation_date: number
    last_message: number
    last_contact_date: number
    contacts_pictures_id: number
    _all: number
  }


  export type ContactsMinAggregateInputType = {
    contact_id?: true
    conversation_id?: true
    contact_id_root?: true
    contact_id_target?: true
    contact_creation_date?: true
    last_message?: true
    last_contact_date?: true
    contacts_pictures_id?: true
  }

  export type ContactsMaxAggregateInputType = {
    contact_id?: true
    conversation_id?: true
    contact_id_root?: true
    contact_id_target?: true
    contact_creation_date?: true
    last_message?: true
    last_contact_date?: true
    contacts_pictures_id?: true
  }

  export type ContactsCountAggregateInputType = {
    contact_id?: true
    conversation_id?: true
    contact_id_root?: true
    contact_id_target?: true
    contact_creation_date?: true
    last_message?: true
    last_contact_date?: true
    contacts_pictures_id?: true
    _all?: true
  }

  export type ContactsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contacts to aggregate.
     */
    where?: contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactsOrderByWithRelationInput | contactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contacts
    **/
    _count?: true | ContactsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactsMaxAggregateInputType
  }

  export type GetContactsAggregateType<T extends ContactsAggregateArgs> = {
        [P in keyof T & keyof AggregateContacts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContacts[P]>
      : GetScalarType<T[P], AggregateContacts[P]>
  }




  export type contactsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contactsWhereInput
    orderBy?: contactsOrderByWithAggregationInput | contactsOrderByWithAggregationInput[]
    by: ContactsScalarFieldEnum[] | ContactsScalarFieldEnum
    having?: contactsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactsCountAggregateInputType | true
    _min?: ContactsMinAggregateInputType
    _max?: ContactsMaxAggregateInputType
  }

  export type ContactsGroupByOutputType = {
    contact_id: string
    conversation_id: string
    contact_id_root: string
    contact_id_target: string
    contact_creation_date: Date
    last_message: string | null
    last_contact_date: Date | null
    contacts_pictures_id: string | null
    _count: ContactsCountAggregateOutputType | null
    _min: ContactsMinAggregateOutputType | null
    _max: ContactsMaxAggregateOutputType | null
  }

  type GetContactsGroupByPayload<T extends contactsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactsGroupByOutputType[P]>
            : GetScalarType<T[P], ContactsGroupByOutputType[P]>
        }
      >
    >


  export type contactsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contact_id?: boolean
    conversation_id?: boolean
    contact_id_root?: boolean
    contact_id_target?: boolean
    contact_creation_date?: boolean
    last_message?: boolean
    last_contact_date?: boolean
    contacts_pictures_id?: boolean
    entities_contacts_contact_id_rootToentities?: boolean | entitiesDefaultArgs<ExtArgs>
    entities_contacts_contact_id_targetToentities?: boolean | entitiesDefaultArgs<ExtArgs>
    contacts_pictures?: boolean | contacts$contacts_picturesArgs<ExtArgs>
  }, ExtArgs["result"]["contacts"]>

  export type contactsSelectScalar = {
    contact_id?: boolean
    conversation_id?: boolean
    contact_id_root?: boolean
    contact_id_target?: boolean
    contact_creation_date?: boolean
    last_message?: boolean
    last_contact_date?: boolean
    contacts_pictures_id?: boolean
  }

  export type contactsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entities_contacts_contact_id_rootToentities?: boolean | entitiesDefaultArgs<ExtArgs>
    entities_contacts_contact_id_targetToentities?: boolean | entitiesDefaultArgs<ExtArgs>
    contacts_pictures?: boolean | contacts$contacts_picturesArgs<ExtArgs>
  }


  export type $contactsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "contacts"
    objects: {
      entities_contacts_contact_id_rootToentities: Prisma.$entitiesPayload<ExtArgs>
      entities_contacts_contact_id_targetToentities: Prisma.$entitiesPayload<ExtArgs>
      contacts_pictures: Prisma.$contacts_picturesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      contact_id: string
      conversation_id: string
      contact_id_root: string
      contact_id_target: string
      contact_creation_date: Date
      last_message: string | null
      last_contact_date: Date | null
      contacts_pictures_id: string | null
    }, ExtArgs["result"]["contacts"]>
    composites: {}
  }


  type contactsGetPayload<S extends boolean | null | undefined | contactsDefaultArgs> = $Result.GetResult<Prisma.$contactsPayload, S>

  type contactsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<contactsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContactsCountAggregateInputType | true
    }

  export interface contactsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['contacts'], meta: { name: 'contacts' } }
    /**
     * Find zero or one Contacts that matches the filter.
     * @param {contactsFindUniqueArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends contactsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, contactsFindUniqueArgs<ExtArgs>>
    ): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Contacts that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {contactsFindUniqueOrThrowArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends contactsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, contactsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactsFindFirstArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends contactsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, contactsFindFirstArgs<ExtArgs>>
    ): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Contacts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactsFindFirstOrThrowArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends contactsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, contactsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contacts.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contacts.findMany({ take: 10 })
     * 
     * // Only select the `contact_id`
     * const contactsWithContact_idOnly = await prisma.contacts.findMany({ select: { contact_id: true } })
     * 
    **/
    findMany<T extends contactsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contactsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Contacts.
     * @param {contactsCreateArgs} args - Arguments to create a Contacts.
     * @example
     * // Create one Contacts
     * const Contacts = await prisma.contacts.create({
     *   data: {
     *     // ... data to create a Contacts
     *   }
     * })
     * 
    **/
    create<T extends contactsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, contactsCreateArgs<ExtArgs>>
    ): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Contacts.
     *     @param {contactsCreateManyArgs} args - Arguments to create many Contacts.
     *     @example
     *     // Create many Contacts
     *     const contacts = await prisma.contacts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends contactsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contactsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contacts.
     * @param {contactsDeleteArgs} args - Arguments to delete one Contacts.
     * @example
     * // Delete one Contacts
     * const Contacts = await prisma.contacts.delete({
     *   where: {
     *     // ... filter to delete one Contacts
     *   }
     * })
     * 
    **/
    delete<T extends contactsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, contactsDeleteArgs<ExtArgs>>
    ): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Contacts.
     * @param {contactsUpdateArgs} args - Arguments to update one Contacts.
     * @example
     * // Update one Contacts
     * const contacts = await prisma.contacts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends contactsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, contactsUpdateArgs<ExtArgs>>
    ): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Contacts.
     * @param {contactsDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contacts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends contactsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contactsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contacts = await prisma.contacts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends contactsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, contactsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contacts.
     * @param {contactsUpsertArgs} args - Arguments to update or create a Contacts.
     * @example
     * // Update or create a Contacts
     * const contacts = await prisma.contacts.upsert({
     *   create: {
     *     // ... data to create a Contacts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contacts we want to update
     *   }
     * })
    **/
    upsert<T extends contactsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, contactsUpsertArgs<ExtArgs>>
    ): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactsCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contacts.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends contactsCountArgs>(
      args?: Subset<T, contactsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactsAggregateArgs>(args: Subset<T, ContactsAggregateArgs>): Prisma.PrismaPromise<GetContactsAggregateType<T>>

    /**
     * Group by Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends contactsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contactsGroupByArgs['orderBy'] }
        : { orderBy?: contactsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, contactsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the contacts model
   */
  readonly fields: contactsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for contacts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__contactsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    entities_contacts_contact_id_rootToentities<T extends entitiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, entitiesDefaultArgs<ExtArgs>>): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    entities_contacts_contact_id_targetToentities<T extends entitiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, entitiesDefaultArgs<ExtArgs>>): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    contacts_pictures<T extends contacts$contacts_picturesArgs<ExtArgs> = {}>(args?: Subset<T, contacts$contacts_picturesArgs<ExtArgs>>): Prisma__contacts_picturesClient<$Result.GetResult<Prisma.$contacts_picturesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the contacts model
   */ 
  interface contactsFieldRefs {
    readonly contact_id: FieldRef<"contacts", 'String'>
    readonly conversation_id: FieldRef<"contacts", 'String'>
    readonly contact_id_root: FieldRef<"contacts", 'String'>
    readonly contact_id_target: FieldRef<"contacts", 'String'>
    readonly contact_creation_date: FieldRef<"contacts", 'DateTime'>
    readonly last_message: FieldRef<"contacts", 'String'>
    readonly last_contact_date: FieldRef<"contacts", 'DateTime'>
    readonly contacts_pictures_id: FieldRef<"contacts", 'String'>
  }
    

  // Custom InputTypes

  /**
   * contacts findUnique
   */
  export type contactsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * Filter, which contacts to fetch.
     */
    where: contactsWhereUniqueInput
  }


  /**
   * contacts findUniqueOrThrow
   */
  export type contactsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * Filter, which contacts to fetch.
     */
    where: contactsWhereUniqueInput
  }


  /**
   * contacts findFirst
   */
  export type contactsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * Filter, which contacts to fetch.
     */
    where?: contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactsOrderByWithRelationInput | contactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contacts.
     */
    cursor?: contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contacts.
     */
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }


  /**
   * contacts findFirstOrThrow
   */
  export type contactsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * Filter, which contacts to fetch.
     */
    where?: contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactsOrderByWithRelationInput | contactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contacts.
     */
    cursor?: contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contacts.
     */
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }


  /**
   * contacts findMany
   */
  export type contactsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * Filter, which contacts to fetch.
     */
    where?: contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactsOrderByWithRelationInput | contactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contacts.
     */
    cursor?: contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }


  /**
   * contacts create
   */
  export type contactsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * The data needed to create a contacts.
     */
    data: XOR<contactsCreateInput, contactsUncheckedCreateInput>
  }


  /**
   * contacts createMany
   */
  export type contactsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many contacts.
     */
    data: contactsCreateManyInput | contactsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * contacts update
   */
  export type contactsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * The data needed to update a contacts.
     */
    data: XOR<contactsUpdateInput, contactsUncheckedUpdateInput>
    /**
     * Choose, which contacts to update.
     */
    where: contactsWhereUniqueInput
  }


  /**
   * contacts updateMany
   */
  export type contactsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update contacts.
     */
    data: XOR<contactsUpdateManyMutationInput, contactsUncheckedUpdateManyInput>
    /**
     * Filter which contacts to update
     */
    where?: contactsWhereInput
  }


  /**
   * contacts upsert
   */
  export type contactsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * The filter to search for the contacts to update in case it exists.
     */
    where: contactsWhereUniqueInput
    /**
     * In case the contacts found by the `where` argument doesn't exist, create a new contacts with this data.
     */
    create: XOR<contactsCreateInput, contactsUncheckedCreateInput>
    /**
     * In case the contacts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contactsUpdateInput, contactsUncheckedUpdateInput>
  }


  /**
   * contacts delete
   */
  export type contactsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * Filter which contacts to delete.
     */
    where: contactsWhereUniqueInput
  }


  /**
   * contacts deleteMany
   */
  export type contactsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contacts to delete
     */
    where?: contactsWhereInput
  }


  /**
   * contacts.contacts_pictures
   */
  export type contacts$contacts_picturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts_pictures
     */
    select?: contacts_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contacts_picturesInclude<ExtArgs> | null
    where?: contacts_picturesWhereInput
  }


  /**
   * contacts without action
   */
  export type contactsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contactsInclude<ExtArgs> | null
  }



  /**
   * Model contacts_pictures
   */

  export type AggregateContacts_pictures = {
    _count: Contacts_picturesCountAggregateOutputType | null
    _min: Contacts_picturesMinAggregateOutputType | null
    _max: Contacts_picturesMaxAggregateOutputType | null
  }

  export type Contacts_picturesMinAggregateOutputType = {
    contacts_pictures_id: string | null
    contact_picture_data: Buffer | null
    contact_picture_filename: string | null
  }

  export type Contacts_picturesMaxAggregateOutputType = {
    contacts_pictures_id: string | null
    contact_picture_data: Buffer | null
    contact_picture_filename: string | null
  }

  export type Contacts_picturesCountAggregateOutputType = {
    contacts_pictures_id: number
    contact_picture_data: number
    contact_picture_filename: number
    _all: number
  }


  export type Contacts_picturesMinAggregateInputType = {
    contacts_pictures_id?: true
    contact_picture_data?: true
    contact_picture_filename?: true
  }

  export type Contacts_picturesMaxAggregateInputType = {
    contacts_pictures_id?: true
    contact_picture_data?: true
    contact_picture_filename?: true
  }

  export type Contacts_picturesCountAggregateInputType = {
    contacts_pictures_id?: true
    contact_picture_data?: true
    contact_picture_filename?: true
    _all?: true
  }

  export type Contacts_picturesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contacts_pictures to aggregate.
     */
    where?: contacts_picturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts_pictures to fetch.
     */
    orderBy?: contacts_picturesOrderByWithRelationInput | contacts_picturesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: contacts_picturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts_pictures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts_pictures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contacts_pictures
    **/
    _count?: true | Contacts_picturesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Contacts_picturesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Contacts_picturesMaxAggregateInputType
  }

  export type GetContacts_picturesAggregateType<T extends Contacts_picturesAggregateArgs> = {
        [P in keyof T & keyof AggregateContacts_pictures]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContacts_pictures[P]>
      : GetScalarType<T[P], AggregateContacts_pictures[P]>
  }




  export type contacts_picturesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contacts_picturesWhereInput
    orderBy?: contacts_picturesOrderByWithAggregationInput | contacts_picturesOrderByWithAggregationInput[]
    by: Contacts_picturesScalarFieldEnum[] | Contacts_picturesScalarFieldEnum
    having?: contacts_picturesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Contacts_picturesCountAggregateInputType | true
    _min?: Contacts_picturesMinAggregateInputType
    _max?: Contacts_picturesMaxAggregateInputType
  }

  export type Contacts_picturesGroupByOutputType = {
    contacts_pictures_id: string
    contact_picture_data: Buffer
    contact_picture_filename: string
    _count: Contacts_picturesCountAggregateOutputType | null
    _min: Contacts_picturesMinAggregateOutputType | null
    _max: Contacts_picturesMaxAggregateOutputType | null
  }

  type GetContacts_picturesGroupByPayload<T extends contacts_picturesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Contacts_picturesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Contacts_picturesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Contacts_picturesGroupByOutputType[P]>
            : GetScalarType<T[P], Contacts_picturesGroupByOutputType[P]>
        }
      >
    >


  export type contacts_picturesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contacts_pictures_id?: boolean
    contact_picture_data?: boolean
    contact_picture_filename?: boolean
    contacts?: boolean | contacts_pictures$contactsArgs<ExtArgs>
    _count?: boolean | Contacts_picturesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contacts_pictures"]>

  export type contacts_picturesSelectScalar = {
    contacts_pictures_id?: boolean
    contact_picture_data?: boolean
    contact_picture_filename?: boolean
  }

  export type contacts_picturesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | contacts_pictures$contactsArgs<ExtArgs>
    _count?: boolean | Contacts_picturesCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $contacts_picturesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "contacts_pictures"
    objects: {
      contacts: Prisma.$contactsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      contacts_pictures_id: string
      contact_picture_data: Buffer
      contact_picture_filename: string
    }, ExtArgs["result"]["contacts_pictures"]>
    composites: {}
  }


  type contacts_picturesGetPayload<S extends boolean | null | undefined | contacts_picturesDefaultArgs> = $Result.GetResult<Prisma.$contacts_picturesPayload, S>

  type contacts_picturesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<contacts_picturesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Contacts_picturesCountAggregateInputType | true
    }

  export interface contacts_picturesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['contacts_pictures'], meta: { name: 'contacts_pictures' } }
    /**
     * Find zero or one Contacts_pictures that matches the filter.
     * @param {contacts_picturesFindUniqueArgs} args - Arguments to find a Contacts_pictures
     * @example
     * // Get one Contacts_pictures
     * const contacts_pictures = await prisma.contacts_pictures.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends contacts_picturesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, contacts_picturesFindUniqueArgs<ExtArgs>>
    ): Prisma__contacts_picturesClient<$Result.GetResult<Prisma.$contacts_picturesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Contacts_pictures that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {contacts_picturesFindUniqueOrThrowArgs} args - Arguments to find a Contacts_pictures
     * @example
     * // Get one Contacts_pictures
     * const contacts_pictures = await prisma.contacts_pictures.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends contacts_picturesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, contacts_picturesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__contacts_picturesClient<$Result.GetResult<Prisma.$contacts_picturesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Contacts_pictures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contacts_picturesFindFirstArgs} args - Arguments to find a Contacts_pictures
     * @example
     * // Get one Contacts_pictures
     * const contacts_pictures = await prisma.contacts_pictures.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends contacts_picturesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, contacts_picturesFindFirstArgs<ExtArgs>>
    ): Prisma__contacts_picturesClient<$Result.GetResult<Prisma.$contacts_picturesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Contacts_pictures that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contacts_picturesFindFirstOrThrowArgs} args - Arguments to find a Contacts_pictures
     * @example
     * // Get one Contacts_pictures
     * const contacts_pictures = await prisma.contacts_pictures.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends contacts_picturesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, contacts_picturesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__contacts_picturesClient<$Result.GetResult<Prisma.$contacts_picturesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Contacts_pictures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contacts_picturesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts_pictures
     * const contacts_pictures = await prisma.contacts_pictures.findMany()
     * 
     * // Get first 10 Contacts_pictures
     * const contacts_pictures = await prisma.contacts_pictures.findMany({ take: 10 })
     * 
     * // Only select the `contacts_pictures_id`
     * const contacts_picturesWithContacts_pictures_idOnly = await prisma.contacts_pictures.findMany({ select: { contacts_pictures_id: true } })
     * 
    **/
    findMany<T extends contacts_picturesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contacts_picturesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contacts_picturesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Contacts_pictures.
     * @param {contacts_picturesCreateArgs} args - Arguments to create a Contacts_pictures.
     * @example
     * // Create one Contacts_pictures
     * const Contacts_pictures = await prisma.contacts_pictures.create({
     *   data: {
     *     // ... data to create a Contacts_pictures
     *   }
     * })
     * 
    **/
    create<T extends contacts_picturesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, contacts_picturesCreateArgs<ExtArgs>>
    ): Prisma__contacts_picturesClient<$Result.GetResult<Prisma.$contacts_picturesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Contacts_pictures.
     *     @param {contacts_picturesCreateManyArgs} args - Arguments to create many Contacts_pictures.
     *     @example
     *     // Create many Contacts_pictures
     *     const contacts_pictures = await prisma.contacts_pictures.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends contacts_picturesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contacts_picturesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contacts_pictures.
     * @param {contacts_picturesDeleteArgs} args - Arguments to delete one Contacts_pictures.
     * @example
     * // Delete one Contacts_pictures
     * const Contacts_pictures = await prisma.contacts_pictures.delete({
     *   where: {
     *     // ... filter to delete one Contacts_pictures
     *   }
     * })
     * 
    **/
    delete<T extends contacts_picturesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, contacts_picturesDeleteArgs<ExtArgs>>
    ): Prisma__contacts_picturesClient<$Result.GetResult<Prisma.$contacts_picturesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Contacts_pictures.
     * @param {contacts_picturesUpdateArgs} args - Arguments to update one Contacts_pictures.
     * @example
     * // Update one Contacts_pictures
     * const contacts_pictures = await prisma.contacts_pictures.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends contacts_picturesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, contacts_picturesUpdateArgs<ExtArgs>>
    ): Prisma__contacts_picturesClient<$Result.GetResult<Prisma.$contacts_picturesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Contacts_pictures.
     * @param {contacts_picturesDeleteManyArgs} args - Arguments to filter Contacts_pictures to delete.
     * @example
     * // Delete a few Contacts_pictures
     * const { count } = await prisma.contacts_pictures.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends contacts_picturesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contacts_picturesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts_pictures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contacts_picturesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts_pictures
     * const contacts_pictures = await prisma.contacts_pictures.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends contacts_picturesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, contacts_picturesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contacts_pictures.
     * @param {contacts_picturesUpsertArgs} args - Arguments to update or create a Contacts_pictures.
     * @example
     * // Update or create a Contacts_pictures
     * const contacts_pictures = await prisma.contacts_pictures.upsert({
     *   create: {
     *     // ... data to create a Contacts_pictures
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contacts_pictures we want to update
     *   }
     * })
    **/
    upsert<T extends contacts_picturesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, contacts_picturesUpsertArgs<ExtArgs>>
    ): Prisma__contacts_picturesClient<$Result.GetResult<Prisma.$contacts_picturesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Contacts_pictures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contacts_picturesCountArgs} args - Arguments to filter Contacts_pictures to count.
     * @example
     * // Count the number of Contacts_pictures
     * const count = await prisma.contacts_pictures.count({
     *   where: {
     *     // ... the filter for the Contacts_pictures we want to count
     *   }
     * })
    **/
    count<T extends contacts_picturesCountArgs>(
      args?: Subset<T, contacts_picturesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Contacts_picturesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contacts_pictures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contacts_picturesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Contacts_picturesAggregateArgs>(args: Subset<T, Contacts_picturesAggregateArgs>): Prisma.PrismaPromise<GetContacts_picturesAggregateType<T>>

    /**
     * Group by Contacts_pictures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contacts_picturesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends contacts_picturesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contacts_picturesGroupByArgs['orderBy'] }
        : { orderBy?: contacts_picturesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, contacts_picturesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContacts_picturesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the contacts_pictures model
   */
  readonly fields: contacts_picturesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for contacts_pictures.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__contacts_picturesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    contacts<T extends contacts_pictures$contactsArgs<ExtArgs> = {}>(args?: Subset<T, contacts_pictures$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the contacts_pictures model
   */ 
  interface contacts_picturesFieldRefs {
    readonly contacts_pictures_id: FieldRef<"contacts_pictures", 'String'>
    readonly contact_picture_data: FieldRef<"contacts_pictures", 'Bytes'>
    readonly contact_picture_filename: FieldRef<"contacts_pictures", 'String'>
  }
    

  // Custom InputTypes

  /**
   * contacts_pictures findUnique
   */
  export type contacts_picturesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts_pictures
     */
    select?: contacts_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contacts_picturesInclude<ExtArgs> | null
    /**
     * Filter, which contacts_pictures to fetch.
     */
    where: contacts_picturesWhereUniqueInput
  }


  /**
   * contacts_pictures findUniqueOrThrow
   */
  export type contacts_picturesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts_pictures
     */
    select?: contacts_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contacts_picturesInclude<ExtArgs> | null
    /**
     * Filter, which contacts_pictures to fetch.
     */
    where: contacts_picturesWhereUniqueInput
  }


  /**
   * contacts_pictures findFirst
   */
  export type contacts_picturesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts_pictures
     */
    select?: contacts_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contacts_picturesInclude<ExtArgs> | null
    /**
     * Filter, which contacts_pictures to fetch.
     */
    where?: contacts_picturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts_pictures to fetch.
     */
    orderBy?: contacts_picturesOrderByWithRelationInput | contacts_picturesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contacts_pictures.
     */
    cursor?: contacts_picturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts_pictures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts_pictures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contacts_pictures.
     */
    distinct?: Contacts_picturesScalarFieldEnum | Contacts_picturesScalarFieldEnum[]
  }


  /**
   * contacts_pictures findFirstOrThrow
   */
  export type contacts_picturesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts_pictures
     */
    select?: contacts_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contacts_picturesInclude<ExtArgs> | null
    /**
     * Filter, which contacts_pictures to fetch.
     */
    where?: contacts_picturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts_pictures to fetch.
     */
    orderBy?: contacts_picturesOrderByWithRelationInput | contacts_picturesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contacts_pictures.
     */
    cursor?: contacts_picturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts_pictures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts_pictures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contacts_pictures.
     */
    distinct?: Contacts_picturesScalarFieldEnum | Contacts_picturesScalarFieldEnum[]
  }


  /**
   * contacts_pictures findMany
   */
  export type contacts_picturesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts_pictures
     */
    select?: contacts_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contacts_picturesInclude<ExtArgs> | null
    /**
     * Filter, which contacts_pictures to fetch.
     */
    where?: contacts_picturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts_pictures to fetch.
     */
    orderBy?: contacts_picturesOrderByWithRelationInput | contacts_picturesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contacts_pictures.
     */
    cursor?: contacts_picturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts_pictures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts_pictures.
     */
    skip?: number
    distinct?: Contacts_picturesScalarFieldEnum | Contacts_picturesScalarFieldEnum[]
  }


  /**
   * contacts_pictures create
   */
  export type contacts_picturesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts_pictures
     */
    select?: contacts_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contacts_picturesInclude<ExtArgs> | null
    /**
     * The data needed to create a contacts_pictures.
     */
    data: XOR<contacts_picturesCreateInput, contacts_picturesUncheckedCreateInput>
  }


  /**
   * contacts_pictures createMany
   */
  export type contacts_picturesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many contacts_pictures.
     */
    data: contacts_picturesCreateManyInput | contacts_picturesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * contacts_pictures update
   */
  export type contacts_picturesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts_pictures
     */
    select?: contacts_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contacts_picturesInclude<ExtArgs> | null
    /**
     * The data needed to update a contacts_pictures.
     */
    data: XOR<contacts_picturesUpdateInput, contacts_picturesUncheckedUpdateInput>
    /**
     * Choose, which contacts_pictures to update.
     */
    where: contacts_picturesWhereUniqueInput
  }


  /**
   * contacts_pictures updateMany
   */
  export type contacts_picturesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update contacts_pictures.
     */
    data: XOR<contacts_picturesUpdateManyMutationInput, contacts_picturesUncheckedUpdateManyInput>
    /**
     * Filter which contacts_pictures to update
     */
    where?: contacts_picturesWhereInput
  }


  /**
   * contacts_pictures upsert
   */
  export type contacts_picturesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts_pictures
     */
    select?: contacts_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contacts_picturesInclude<ExtArgs> | null
    /**
     * The filter to search for the contacts_pictures to update in case it exists.
     */
    where: contacts_picturesWhereUniqueInput
    /**
     * In case the contacts_pictures found by the `where` argument doesn't exist, create a new contacts_pictures with this data.
     */
    create: XOR<contacts_picturesCreateInput, contacts_picturesUncheckedCreateInput>
    /**
     * In case the contacts_pictures was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contacts_picturesUpdateInput, contacts_picturesUncheckedUpdateInput>
  }


  /**
   * contacts_pictures delete
   */
  export type contacts_picturesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts_pictures
     */
    select?: contacts_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contacts_picturesInclude<ExtArgs> | null
    /**
     * Filter which contacts_pictures to delete.
     */
    where: contacts_picturesWhereUniqueInput
  }


  /**
   * contacts_pictures deleteMany
   */
  export type contacts_picturesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contacts_pictures to delete
     */
    where?: contacts_picturesWhereInput
  }


  /**
   * contacts_pictures.contacts
   */
  export type contacts_pictures$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contactsInclude<ExtArgs> | null
    where?: contactsWhereInput
    orderBy?: contactsOrderByWithRelationInput | contactsOrderByWithRelationInput[]
    cursor?: contactsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }


  /**
   * contacts_pictures without action
   */
  export type contacts_picturesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts_pictures
     */
    select?: contacts_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contacts_picturesInclude<ExtArgs> | null
  }



  /**
   * Model content
   */

  export type AggregateContent = {
    _count: ContentCountAggregateOutputType | null
    _avg: ContentAvgAggregateOutputType | null
    _sum: ContentSumAggregateOutputType | null
    _min: ContentMinAggregateOutputType | null
    _max: ContentMaxAggregateOutputType | null
  }

  export type ContentAvgAggregateOutputType = {
    content_type: number | null
  }

  export type ContentSumAggregateOutputType = {
    content_type: number | null
  }

  export type ContentMinAggregateOutputType = {
    content_id: string | null
    content_type: number | null
  }

  export type ContentMaxAggregateOutputType = {
    content_id: string | null
    content_type: number | null
  }

  export type ContentCountAggregateOutputType = {
    content_id: number
    content_type: number
    _all: number
  }


  export type ContentAvgAggregateInputType = {
    content_type?: true
  }

  export type ContentSumAggregateInputType = {
    content_type?: true
  }

  export type ContentMinAggregateInputType = {
    content_id?: true
    content_type?: true
  }

  export type ContentMaxAggregateInputType = {
    content_id?: true
    content_type?: true
  }

  export type ContentCountAggregateInputType = {
    content_id?: true
    content_type?: true
    _all?: true
  }

  export type ContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which content to aggregate.
     */
    where?: contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contents to fetch.
     */
    orderBy?: contentOrderByWithRelationInput | contentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contents
    **/
    _count?: true | ContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentMaxAggregateInputType
  }

  export type GetContentAggregateType<T extends ContentAggregateArgs> = {
        [P in keyof T & keyof AggregateContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContent[P]>
      : GetScalarType<T[P], AggregateContent[P]>
  }




  export type contentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contentWhereInput
    orderBy?: contentOrderByWithAggregationInput | contentOrderByWithAggregationInput[]
    by: ContentScalarFieldEnum[] | ContentScalarFieldEnum
    having?: contentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentCountAggregateInputType | true
    _avg?: ContentAvgAggregateInputType
    _sum?: ContentSumAggregateInputType
    _min?: ContentMinAggregateInputType
    _max?: ContentMaxAggregateInputType
  }

  export type ContentGroupByOutputType = {
    content_id: string
    content_type: number | null
    _count: ContentCountAggregateOutputType | null
    _avg: ContentAvgAggregateOutputType | null
    _sum: ContentSumAggregateOutputType | null
    _min: ContentMinAggregateOutputType | null
    _max: ContentMaxAggregateOutputType | null
  }

  type GetContentGroupByPayload<T extends contentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentGroupByOutputType[P]>
            : GetScalarType<T[P], ContentGroupByOutputType[P]>
        }
      >
    >


  export type contentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    content_id?: boolean
    content_type?: boolean
    collections_content?: boolean | content$collections_contentArgs<ExtArgs>
    entities_content?: boolean | content$entities_contentArgs<ExtArgs>
    entities_dislikes?: boolean | content$entities_dislikesArgs<ExtArgs>
    entities_likes?: boolean | content$entities_likesArgs<ExtArgs>
    _count?: boolean | ContentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["content"]>

  export type contentSelectScalar = {
    content_id?: boolean
    content_type?: boolean
  }

  export type contentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collections_content?: boolean | content$collections_contentArgs<ExtArgs>
    entities_content?: boolean | content$entities_contentArgs<ExtArgs>
    entities_dislikes?: boolean | content$entities_dislikesArgs<ExtArgs>
    entities_likes?: boolean | content$entities_likesArgs<ExtArgs>
    _count?: boolean | ContentCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $contentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "content"
    objects: {
      collections_content: Prisma.$collections_contentPayload<ExtArgs>[]
      entities_content: Prisma.$entities_contentPayload<ExtArgs>[]
      entities_dislikes: Prisma.$entities_dislikesPayload<ExtArgs>[]
      entities_likes: Prisma.$entities_likesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      content_id: string
      content_type: number | null
    }, ExtArgs["result"]["content"]>
    composites: {}
  }


  type contentGetPayload<S extends boolean | null | undefined | contentDefaultArgs> = $Result.GetResult<Prisma.$contentPayload, S>

  type contentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<contentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContentCountAggregateInputType | true
    }

  export interface contentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['content'], meta: { name: 'content' } }
    /**
     * Find zero or one Content that matches the filter.
     * @param {contentFindUniqueArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends contentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, contentFindUniqueArgs<ExtArgs>>
    ): Prisma__contentClient<$Result.GetResult<Prisma.$contentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Content that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {contentFindUniqueOrThrowArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends contentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, contentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__contentClient<$Result.GetResult<Prisma.$contentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Content that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contentFindFirstArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends contentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, contentFindFirstArgs<ExtArgs>>
    ): Prisma__contentClient<$Result.GetResult<Prisma.$contentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Content that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contentFindFirstOrThrowArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends contentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, contentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__contentClient<$Result.GetResult<Prisma.$contentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Contents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contents
     * const contents = await prisma.content.findMany()
     * 
     * // Get first 10 Contents
     * const contents = await prisma.content.findMany({ take: 10 })
     * 
     * // Only select the `content_id`
     * const contentWithContent_idOnly = await prisma.content.findMany({ select: { content_id: true } })
     * 
    **/
    findMany<T extends contentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Content.
     * @param {contentCreateArgs} args - Arguments to create a Content.
     * @example
     * // Create one Content
     * const Content = await prisma.content.create({
     *   data: {
     *     // ... data to create a Content
     *   }
     * })
     * 
    **/
    create<T extends contentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, contentCreateArgs<ExtArgs>>
    ): Prisma__contentClient<$Result.GetResult<Prisma.$contentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Contents.
     *     @param {contentCreateManyArgs} args - Arguments to create many Contents.
     *     @example
     *     // Create many Contents
     *     const content = await prisma.content.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends contentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Content.
     * @param {contentDeleteArgs} args - Arguments to delete one Content.
     * @example
     * // Delete one Content
     * const Content = await prisma.content.delete({
     *   where: {
     *     // ... filter to delete one Content
     *   }
     * })
     * 
    **/
    delete<T extends contentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, contentDeleteArgs<ExtArgs>>
    ): Prisma__contentClient<$Result.GetResult<Prisma.$contentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Content.
     * @param {contentUpdateArgs} args - Arguments to update one Content.
     * @example
     * // Update one Content
     * const content = await prisma.content.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends contentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, contentUpdateArgs<ExtArgs>>
    ): Prisma__contentClient<$Result.GetResult<Prisma.$contentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Contents.
     * @param {contentDeleteManyArgs} args - Arguments to filter Contents to delete.
     * @example
     * // Delete a few Contents
     * const { count } = await prisma.content.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends contentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contents
     * const content = await prisma.content.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends contentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, contentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Content.
     * @param {contentUpsertArgs} args - Arguments to update or create a Content.
     * @example
     * // Update or create a Content
     * const content = await prisma.content.upsert({
     *   create: {
     *     // ... data to create a Content
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Content we want to update
     *   }
     * })
    **/
    upsert<T extends contentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, contentUpsertArgs<ExtArgs>>
    ): Prisma__contentClient<$Result.GetResult<Prisma.$contentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contentCountArgs} args - Arguments to filter Contents to count.
     * @example
     * // Count the number of Contents
     * const count = await prisma.content.count({
     *   where: {
     *     // ... the filter for the Contents we want to count
     *   }
     * })
    **/
    count<T extends contentCountArgs>(
      args?: Subset<T, contentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentAggregateArgs>(args: Subset<T, ContentAggregateArgs>): Prisma.PrismaPromise<GetContentAggregateType<T>>

    /**
     * Group by Content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends contentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contentGroupByArgs['orderBy'] }
        : { orderBy?: contentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, contentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the content model
   */
  readonly fields: contentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for content.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__contentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    collections_content<T extends content$collections_contentArgs<ExtArgs> = {}>(args?: Subset<T, content$collections_contentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collections_contentPayload<ExtArgs>, T, 'findMany'> | Null>;

    entities_content<T extends content$entities_contentArgs<ExtArgs> = {}>(args?: Subset<T, content$entities_contentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$entities_contentPayload<ExtArgs>, T, 'findMany'> | Null>;

    entities_dislikes<T extends content$entities_dislikesArgs<ExtArgs> = {}>(args?: Subset<T, content$entities_dislikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$entities_dislikesPayload<ExtArgs>, T, 'findMany'> | Null>;

    entities_likes<T extends content$entities_likesArgs<ExtArgs> = {}>(args?: Subset<T, content$entities_likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$entities_likesPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the content model
   */ 
  interface contentFieldRefs {
    readonly content_id: FieldRef<"content", 'String'>
    readonly content_type: FieldRef<"content", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * content findUnique
   */
  export type contentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the content
     */
    select?: contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contentInclude<ExtArgs> | null
    /**
     * Filter, which content to fetch.
     */
    where: contentWhereUniqueInput
  }


  /**
   * content findUniqueOrThrow
   */
  export type contentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the content
     */
    select?: contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contentInclude<ExtArgs> | null
    /**
     * Filter, which content to fetch.
     */
    where: contentWhereUniqueInput
  }


  /**
   * content findFirst
   */
  export type contentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the content
     */
    select?: contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contentInclude<ExtArgs> | null
    /**
     * Filter, which content to fetch.
     */
    where?: contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contents to fetch.
     */
    orderBy?: contentOrderByWithRelationInput | contentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contents.
     */
    cursor?: contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contents.
     */
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }


  /**
   * content findFirstOrThrow
   */
  export type contentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the content
     */
    select?: contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contentInclude<ExtArgs> | null
    /**
     * Filter, which content to fetch.
     */
    where?: contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contents to fetch.
     */
    orderBy?: contentOrderByWithRelationInput | contentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contents.
     */
    cursor?: contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contents.
     */
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }


  /**
   * content findMany
   */
  export type contentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the content
     */
    select?: contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contentInclude<ExtArgs> | null
    /**
     * Filter, which contents to fetch.
     */
    where?: contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contents to fetch.
     */
    orderBy?: contentOrderByWithRelationInput | contentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contents.
     */
    cursor?: contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contents.
     */
    skip?: number
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }


  /**
   * content create
   */
  export type contentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the content
     */
    select?: contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contentInclude<ExtArgs> | null
    /**
     * The data needed to create a content.
     */
    data: XOR<contentCreateInput, contentUncheckedCreateInput>
  }


  /**
   * content createMany
   */
  export type contentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many contents.
     */
    data: contentCreateManyInput | contentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * content update
   */
  export type contentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the content
     */
    select?: contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contentInclude<ExtArgs> | null
    /**
     * The data needed to update a content.
     */
    data: XOR<contentUpdateInput, contentUncheckedUpdateInput>
    /**
     * Choose, which content to update.
     */
    where: contentWhereUniqueInput
  }


  /**
   * content updateMany
   */
  export type contentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update contents.
     */
    data: XOR<contentUpdateManyMutationInput, contentUncheckedUpdateManyInput>
    /**
     * Filter which contents to update
     */
    where?: contentWhereInput
  }


  /**
   * content upsert
   */
  export type contentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the content
     */
    select?: contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contentInclude<ExtArgs> | null
    /**
     * The filter to search for the content to update in case it exists.
     */
    where: contentWhereUniqueInput
    /**
     * In case the content found by the `where` argument doesn't exist, create a new content with this data.
     */
    create: XOR<contentCreateInput, contentUncheckedCreateInput>
    /**
     * In case the content was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contentUpdateInput, contentUncheckedUpdateInput>
  }


  /**
   * content delete
   */
  export type contentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the content
     */
    select?: contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contentInclude<ExtArgs> | null
    /**
     * Filter which content to delete.
     */
    where: contentWhereUniqueInput
  }


  /**
   * content deleteMany
   */
  export type contentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contents to delete
     */
    where?: contentWhereInput
  }


  /**
   * content.collections_content
   */
  export type content$collections_contentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collections_content
     */
    select?: collections_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collections_contentInclude<ExtArgs> | null
    where?: collections_contentWhereInput
    orderBy?: collections_contentOrderByWithRelationInput | collections_contentOrderByWithRelationInput[]
    cursor?: collections_contentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Collections_contentScalarFieldEnum | Collections_contentScalarFieldEnum[]
  }


  /**
   * content.entities_content
   */
  export type content$entities_contentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_content
     */
    select?: entities_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_contentInclude<ExtArgs> | null
    where?: entities_contentWhereInput
    orderBy?: entities_contentOrderByWithRelationInput | entities_contentOrderByWithRelationInput[]
    cursor?: entities_contentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Entities_contentScalarFieldEnum | Entities_contentScalarFieldEnum[]
  }


  /**
   * content.entities_dislikes
   */
  export type content$entities_dislikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_dislikes
     */
    select?: entities_dislikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_dislikesInclude<ExtArgs> | null
    where?: entities_dislikesWhereInput
    orderBy?: entities_dislikesOrderByWithRelationInput | entities_dislikesOrderByWithRelationInput[]
    cursor?: entities_dislikesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Entities_dislikesScalarFieldEnum | Entities_dislikesScalarFieldEnum[]
  }


  /**
   * content.entities_likes
   */
  export type content$entities_likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_likes
     */
    select?: entities_likesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_likesInclude<ExtArgs> | null
    where?: entities_likesWhereInput
    orderBy?: entities_likesOrderByWithRelationInput | entities_likesOrderByWithRelationInput[]
    cursor?: entities_likesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Entities_likesScalarFieldEnum | Entities_likesScalarFieldEnum[]
  }


  /**
   * content without action
   */
  export type contentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the content
     */
    select?: contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contentInclude<ExtArgs> | null
  }



  /**
   * Model conversations
   */

  export type AggregateConversations = {
    _count: ConversationsCountAggregateOutputType | null
    _min: ConversationsMinAggregateOutputType | null
    _max: ConversationsMaxAggregateOutputType | null
  }

  export type ConversationsMinAggregateOutputType = {
    conversation_id: string | null
    conversation_name: string | null
    conversation_creation_date: Date | null
    last_message: string | null
    last_message_date: Date | null
    conversations_pictures_id: string | null
  }

  export type ConversationsMaxAggregateOutputType = {
    conversation_id: string | null
    conversation_name: string | null
    conversation_creation_date: Date | null
    last_message: string | null
    last_message_date: Date | null
    conversations_pictures_id: string | null
  }

  export type ConversationsCountAggregateOutputType = {
    conversation_id: number
    conversation_name: number
    conversation_creation_date: number
    last_message: number
    last_message_date: number
    conversations_pictures_id: number
    _all: number
  }


  export type ConversationsMinAggregateInputType = {
    conversation_id?: true
    conversation_name?: true
    conversation_creation_date?: true
    last_message?: true
    last_message_date?: true
    conversations_pictures_id?: true
  }

  export type ConversationsMaxAggregateInputType = {
    conversation_id?: true
    conversation_name?: true
    conversation_creation_date?: true
    last_message?: true
    last_message_date?: true
    conversations_pictures_id?: true
  }

  export type ConversationsCountAggregateInputType = {
    conversation_id?: true
    conversation_name?: true
    conversation_creation_date?: true
    last_message?: true
    last_message_date?: true
    conversations_pictures_id?: true
    _all?: true
  }

  export type ConversationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conversations to aggregate.
     */
    where?: conversationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations to fetch.
     */
    orderBy?: conversationsOrderByWithRelationInput | conversationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: conversationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned conversations
    **/
    _count?: true | ConversationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationsMaxAggregateInputType
  }

  export type GetConversationsAggregateType<T extends ConversationsAggregateArgs> = {
        [P in keyof T & keyof AggregateConversations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversations[P]>
      : GetScalarType<T[P], AggregateConversations[P]>
  }




  export type conversationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conversationsWhereInput
    orderBy?: conversationsOrderByWithAggregationInput | conversationsOrderByWithAggregationInput[]
    by: ConversationsScalarFieldEnum[] | ConversationsScalarFieldEnum
    having?: conversationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationsCountAggregateInputType | true
    _min?: ConversationsMinAggregateInputType
    _max?: ConversationsMaxAggregateInputType
  }

  export type ConversationsGroupByOutputType = {
    conversation_id: string
    conversation_name: string | null
    conversation_creation_date: Date
    last_message: string | null
    last_message_date: Date | null
    conversations_pictures_id: string | null
    _count: ConversationsCountAggregateOutputType | null
    _min: ConversationsMinAggregateOutputType | null
    _max: ConversationsMaxAggregateOutputType | null
  }

  type GetConversationsGroupByPayload<T extends conversationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationsGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationsGroupByOutputType[P]>
        }
      >
    >


  export type conversationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    conversation_id?: boolean
    conversation_name?: boolean
    conversation_creation_date?: boolean
    last_message?: boolean
    last_message_date?: boolean
    conversations_pictures_id?: boolean
    conversations_pictures?: boolean | conversations$conversations_picturesArgs<ExtArgs>
    conversations_members?: boolean | conversations$conversations_membersArgs<ExtArgs>
    conversations_messages_logs?: boolean | conversations$conversations_messages_logsArgs<ExtArgs>
    _count?: boolean | ConversationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversations"]>

  export type conversationsSelectScalar = {
    conversation_id?: boolean
    conversation_name?: boolean
    conversation_creation_date?: boolean
    last_message?: boolean
    last_message_date?: boolean
    conversations_pictures_id?: boolean
  }

  export type conversationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations_pictures?: boolean | conversations$conversations_picturesArgs<ExtArgs>
    conversations_members?: boolean | conversations$conversations_membersArgs<ExtArgs>
    conversations_messages_logs?: boolean | conversations$conversations_messages_logsArgs<ExtArgs>
    _count?: boolean | ConversationsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $conversationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "conversations"
    objects: {
      conversations_pictures: Prisma.$conversations_picturesPayload<ExtArgs> | null
      conversations_members: Prisma.$conversations_membersPayload<ExtArgs>[]
      conversations_messages_logs: Prisma.$conversations_messages_logsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      conversation_id: string
      conversation_name: string | null
      conversation_creation_date: Date
      last_message: string | null
      last_message_date: Date | null
      conversations_pictures_id: string | null
    }, ExtArgs["result"]["conversations"]>
    composites: {}
  }


  type conversationsGetPayload<S extends boolean | null | undefined | conversationsDefaultArgs> = $Result.GetResult<Prisma.$conversationsPayload, S>

  type conversationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<conversationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConversationsCountAggregateInputType | true
    }

  export interface conversationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['conversations'], meta: { name: 'conversations' } }
    /**
     * Find zero or one Conversations that matches the filter.
     * @param {conversationsFindUniqueArgs} args - Arguments to find a Conversations
     * @example
     * // Get one Conversations
     * const conversations = await prisma.conversations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends conversationsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, conversationsFindUniqueArgs<ExtArgs>>
    ): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Conversations that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {conversationsFindUniqueOrThrowArgs} args - Arguments to find a Conversations
     * @example
     * // Get one Conversations
     * const conversations = await prisma.conversations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends conversationsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, conversationsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationsFindFirstArgs} args - Arguments to find a Conversations
     * @example
     * // Get one Conversations
     * const conversations = await prisma.conversations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends conversationsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, conversationsFindFirstArgs<ExtArgs>>
    ): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Conversations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationsFindFirstOrThrowArgs} args - Arguments to find a Conversations
     * @example
     * // Get one Conversations
     * const conversations = await prisma.conversations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends conversationsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, conversationsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversations.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversations.findMany({ take: 10 })
     * 
     * // Only select the `conversation_id`
     * const conversationsWithConversation_idOnly = await prisma.conversations.findMany({ select: { conversation_id: true } })
     * 
    **/
    findMany<T extends conversationsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, conversationsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Conversations.
     * @param {conversationsCreateArgs} args - Arguments to create a Conversations.
     * @example
     * // Create one Conversations
     * const Conversations = await prisma.conversations.create({
     *   data: {
     *     // ... data to create a Conversations
     *   }
     * })
     * 
    **/
    create<T extends conversationsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, conversationsCreateArgs<ExtArgs>>
    ): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Conversations.
     *     @param {conversationsCreateManyArgs} args - Arguments to create many Conversations.
     *     @example
     *     // Create many Conversations
     *     const conversations = await prisma.conversations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends conversationsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, conversationsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Conversations.
     * @param {conversationsDeleteArgs} args - Arguments to delete one Conversations.
     * @example
     * // Delete one Conversations
     * const Conversations = await prisma.conversations.delete({
     *   where: {
     *     // ... filter to delete one Conversations
     *   }
     * })
     * 
    **/
    delete<T extends conversationsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, conversationsDeleteArgs<ExtArgs>>
    ): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Conversations.
     * @param {conversationsUpdateArgs} args - Arguments to update one Conversations.
     * @example
     * // Update one Conversations
     * const conversations = await prisma.conversations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends conversationsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, conversationsUpdateArgs<ExtArgs>>
    ): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Conversations.
     * @param {conversationsDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends conversationsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, conversationsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversations = await prisma.conversations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends conversationsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, conversationsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conversations.
     * @param {conversationsUpsertArgs} args - Arguments to update or create a Conversations.
     * @example
     * // Update or create a Conversations
     * const conversations = await prisma.conversations.upsert({
     *   create: {
     *     // ... data to create a Conversations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversations we want to update
     *   }
     * })
    **/
    upsert<T extends conversationsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, conversationsUpsertArgs<ExtArgs>>
    ): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationsCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversations.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends conversationsCountArgs>(
      args?: Subset<T, conversationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationsAggregateArgs>(args: Subset<T, ConversationsAggregateArgs>): Prisma.PrismaPromise<GetConversationsAggregateType<T>>

    /**
     * Group by Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends conversationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: conversationsGroupByArgs['orderBy'] }
        : { orderBy?: conversationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, conversationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the conversations model
   */
  readonly fields: conversationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for conversations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__conversationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    conversations_pictures<T extends conversations$conversations_picturesArgs<ExtArgs> = {}>(args?: Subset<T, conversations$conversations_picturesArgs<ExtArgs>>): Prisma__conversations_picturesClient<$Result.GetResult<Prisma.$conversations_picturesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    conversations_members<T extends conversations$conversations_membersArgs<ExtArgs> = {}>(args?: Subset<T, conversations$conversations_membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversations_membersPayload<ExtArgs>, T, 'findMany'> | Null>;

    conversations_messages_logs<T extends conversations$conversations_messages_logsArgs<ExtArgs> = {}>(args?: Subset<T, conversations$conversations_messages_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversations_messages_logsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the conversations model
   */ 
  interface conversationsFieldRefs {
    readonly conversation_id: FieldRef<"conversations", 'String'>
    readonly conversation_name: FieldRef<"conversations", 'String'>
    readonly conversation_creation_date: FieldRef<"conversations", 'DateTime'>
    readonly last_message: FieldRef<"conversations", 'String'>
    readonly last_message_date: FieldRef<"conversations", 'DateTime'>
    readonly conversations_pictures_id: FieldRef<"conversations", 'String'>
  }
    

  // Custom InputTypes

  /**
   * conversations findUnique
   */
  export type conversationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversationsInclude<ExtArgs> | null
    /**
     * Filter, which conversations to fetch.
     */
    where: conversationsWhereUniqueInput
  }


  /**
   * conversations findUniqueOrThrow
   */
  export type conversationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversationsInclude<ExtArgs> | null
    /**
     * Filter, which conversations to fetch.
     */
    where: conversationsWhereUniqueInput
  }


  /**
   * conversations findFirst
   */
  export type conversationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversationsInclude<ExtArgs> | null
    /**
     * Filter, which conversations to fetch.
     */
    where?: conversationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations to fetch.
     */
    orderBy?: conversationsOrderByWithRelationInput | conversationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conversations.
     */
    cursor?: conversationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conversations.
     */
    distinct?: ConversationsScalarFieldEnum | ConversationsScalarFieldEnum[]
  }


  /**
   * conversations findFirstOrThrow
   */
  export type conversationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversationsInclude<ExtArgs> | null
    /**
     * Filter, which conversations to fetch.
     */
    where?: conversationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations to fetch.
     */
    orderBy?: conversationsOrderByWithRelationInput | conversationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conversations.
     */
    cursor?: conversationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conversations.
     */
    distinct?: ConversationsScalarFieldEnum | ConversationsScalarFieldEnum[]
  }


  /**
   * conversations findMany
   */
  export type conversationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversationsInclude<ExtArgs> | null
    /**
     * Filter, which conversations to fetch.
     */
    where?: conversationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations to fetch.
     */
    orderBy?: conversationsOrderByWithRelationInput | conversationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing conversations.
     */
    cursor?: conversationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations.
     */
    skip?: number
    distinct?: ConversationsScalarFieldEnum | ConversationsScalarFieldEnum[]
  }


  /**
   * conversations create
   */
  export type conversationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversationsInclude<ExtArgs> | null
    /**
     * The data needed to create a conversations.
     */
    data: XOR<conversationsCreateInput, conversationsUncheckedCreateInput>
  }


  /**
   * conversations createMany
   */
  export type conversationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many conversations.
     */
    data: conversationsCreateManyInput | conversationsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * conversations update
   */
  export type conversationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversationsInclude<ExtArgs> | null
    /**
     * The data needed to update a conversations.
     */
    data: XOR<conversationsUpdateInput, conversationsUncheckedUpdateInput>
    /**
     * Choose, which conversations to update.
     */
    where: conversationsWhereUniqueInput
  }


  /**
   * conversations updateMany
   */
  export type conversationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update conversations.
     */
    data: XOR<conversationsUpdateManyMutationInput, conversationsUncheckedUpdateManyInput>
    /**
     * Filter which conversations to update
     */
    where?: conversationsWhereInput
  }


  /**
   * conversations upsert
   */
  export type conversationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversationsInclude<ExtArgs> | null
    /**
     * The filter to search for the conversations to update in case it exists.
     */
    where: conversationsWhereUniqueInput
    /**
     * In case the conversations found by the `where` argument doesn't exist, create a new conversations with this data.
     */
    create: XOR<conversationsCreateInput, conversationsUncheckedCreateInput>
    /**
     * In case the conversations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<conversationsUpdateInput, conversationsUncheckedUpdateInput>
  }


  /**
   * conversations delete
   */
  export type conversationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversationsInclude<ExtArgs> | null
    /**
     * Filter which conversations to delete.
     */
    where: conversationsWhereUniqueInput
  }


  /**
   * conversations deleteMany
   */
  export type conversationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conversations to delete
     */
    where?: conversationsWhereInput
  }


  /**
   * conversations.conversations_pictures
   */
  export type conversations$conversations_picturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_pictures
     */
    select?: conversations_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_picturesInclude<ExtArgs> | null
    where?: conversations_picturesWhereInput
  }


  /**
   * conversations.conversations_members
   */
  export type conversations$conversations_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_members
     */
    select?: conversations_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_membersInclude<ExtArgs> | null
    where?: conversations_membersWhereInput
    orderBy?: conversations_membersOrderByWithRelationInput | conversations_membersOrderByWithRelationInput[]
    cursor?: conversations_membersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Conversations_membersScalarFieldEnum | Conversations_membersScalarFieldEnum[]
  }


  /**
   * conversations.conversations_messages_logs
   */
  export type conversations$conversations_messages_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_messages_logs
     */
    select?: conversations_messages_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_messages_logsInclude<ExtArgs> | null
    where?: conversations_messages_logsWhereInput
    orderBy?: conversations_messages_logsOrderByWithRelationInput | conversations_messages_logsOrderByWithRelationInput[]
    cursor?: conversations_messages_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Conversations_messages_logsScalarFieldEnum | Conversations_messages_logsScalarFieldEnum[]
  }


  /**
   * conversations without action
   */
  export type conversationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversationsInclude<ExtArgs> | null
  }



  /**
   * Model conversations_members
   */

  export type AggregateConversations_members = {
    _count: Conversations_membersCountAggregateOutputType | null
    _min: Conversations_membersMinAggregateOutputType | null
    _max: Conversations_membersMaxAggregateOutputType | null
  }

  export type Conversations_membersMinAggregateOutputType = {
    conversations_members_id: string | null
    conversation_id: string | null
    member_id: string | null
  }

  export type Conversations_membersMaxAggregateOutputType = {
    conversations_members_id: string | null
    conversation_id: string | null
    member_id: string | null
  }

  export type Conversations_membersCountAggregateOutputType = {
    conversations_members_id: number
    conversation_id: number
    member_id: number
    _all: number
  }


  export type Conversations_membersMinAggregateInputType = {
    conversations_members_id?: true
    conversation_id?: true
    member_id?: true
  }

  export type Conversations_membersMaxAggregateInputType = {
    conversations_members_id?: true
    conversation_id?: true
    member_id?: true
  }

  export type Conversations_membersCountAggregateInputType = {
    conversations_members_id?: true
    conversation_id?: true
    member_id?: true
    _all?: true
  }

  export type Conversations_membersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conversations_members to aggregate.
     */
    where?: conversations_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations_members to fetch.
     */
    orderBy?: conversations_membersOrderByWithRelationInput | conversations_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: conversations_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned conversations_members
    **/
    _count?: true | Conversations_membersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Conversations_membersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Conversations_membersMaxAggregateInputType
  }

  export type GetConversations_membersAggregateType<T extends Conversations_membersAggregateArgs> = {
        [P in keyof T & keyof AggregateConversations_members]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversations_members[P]>
      : GetScalarType<T[P], AggregateConversations_members[P]>
  }




  export type conversations_membersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conversations_membersWhereInput
    orderBy?: conversations_membersOrderByWithAggregationInput | conversations_membersOrderByWithAggregationInput[]
    by: Conversations_membersScalarFieldEnum[] | Conversations_membersScalarFieldEnum
    having?: conversations_membersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Conversations_membersCountAggregateInputType | true
    _min?: Conversations_membersMinAggregateInputType
    _max?: Conversations_membersMaxAggregateInputType
  }

  export type Conversations_membersGroupByOutputType = {
    conversations_members_id: string
    conversation_id: string
    member_id: string
    _count: Conversations_membersCountAggregateOutputType | null
    _min: Conversations_membersMinAggregateOutputType | null
    _max: Conversations_membersMaxAggregateOutputType | null
  }

  type GetConversations_membersGroupByPayload<T extends conversations_membersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Conversations_membersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Conversations_membersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Conversations_membersGroupByOutputType[P]>
            : GetScalarType<T[P], Conversations_membersGroupByOutputType[P]>
        }
      >
    >


  export type conversations_membersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    conversations_members_id?: boolean
    conversation_id?: boolean
    member_id?: boolean
    conversations?: boolean | conversationsDefaultArgs<ExtArgs>
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversations_members"]>

  export type conversations_membersSelectScalar = {
    conversations_members_id?: boolean
    conversation_id?: boolean
    member_id?: boolean
  }

  export type conversations_membersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations?: boolean | conversationsDefaultArgs<ExtArgs>
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
  }


  export type $conversations_membersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "conversations_members"
    objects: {
      conversations: Prisma.$conversationsPayload<ExtArgs>
      entities: Prisma.$entitiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      conversations_members_id: string
      conversation_id: string
      member_id: string
    }, ExtArgs["result"]["conversations_members"]>
    composites: {}
  }


  type conversations_membersGetPayload<S extends boolean | null | undefined | conversations_membersDefaultArgs> = $Result.GetResult<Prisma.$conversations_membersPayload, S>

  type conversations_membersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<conversations_membersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Conversations_membersCountAggregateInputType | true
    }

  export interface conversations_membersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['conversations_members'], meta: { name: 'conversations_members' } }
    /**
     * Find zero or one Conversations_members that matches the filter.
     * @param {conversations_membersFindUniqueArgs} args - Arguments to find a Conversations_members
     * @example
     * // Get one Conversations_members
     * const conversations_members = await prisma.conversations_members.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends conversations_membersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, conversations_membersFindUniqueArgs<ExtArgs>>
    ): Prisma__conversations_membersClient<$Result.GetResult<Prisma.$conversations_membersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Conversations_members that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {conversations_membersFindUniqueOrThrowArgs} args - Arguments to find a Conversations_members
     * @example
     * // Get one Conversations_members
     * const conversations_members = await prisma.conversations_members.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends conversations_membersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, conversations_membersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__conversations_membersClient<$Result.GetResult<Prisma.$conversations_membersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Conversations_members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversations_membersFindFirstArgs} args - Arguments to find a Conversations_members
     * @example
     * // Get one Conversations_members
     * const conversations_members = await prisma.conversations_members.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends conversations_membersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, conversations_membersFindFirstArgs<ExtArgs>>
    ): Prisma__conversations_membersClient<$Result.GetResult<Prisma.$conversations_membersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Conversations_members that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversations_membersFindFirstOrThrowArgs} args - Arguments to find a Conversations_members
     * @example
     * // Get one Conversations_members
     * const conversations_members = await prisma.conversations_members.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends conversations_membersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, conversations_membersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__conversations_membersClient<$Result.GetResult<Prisma.$conversations_membersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Conversations_members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversations_membersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations_members
     * const conversations_members = await prisma.conversations_members.findMany()
     * 
     * // Get first 10 Conversations_members
     * const conversations_members = await prisma.conversations_members.findMany({ take: 10 })
     * 
     * // Only select the `conversations_members_id`
     * const conversations_membersWithConversations_members_idOnly = await prisma.conversations_members.findMany({ select: { conversations_members_id: true } })
     * 
    **/
    findMany<T extends conversations_membersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, conversations_membersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversations_membersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Conversations_members.
     * @param {conversations_membersCreateArgs} args - Arguments to create a Conversations_members.
     * @example
     * // Create one Conversations_members
     * const Conversations_members = await prisma.conversations_members.create({
     *   data: {
     *     // ... data to create a Conversations_members
     *   }
     * })
     * 
    **/
    create<T extends conversations_membersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, conversations_membersCreateArgs<ExtArgs>>
    ): Prisma__conversations_membersClient<$Result.GetResult<Prisma.$conversations_membersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Conversations_members.
     *     @param {conversations_membersCreateManyArgs} args - Arguments to create many Conversations_members.
     *     @example
     *     // Create many Conversations_members
     *     const conversations_members = await prisma.conversations_members.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends conversations_membersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, conversations_membersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Conversations_members.
     * @param {conversations_membersDeleteArgs} args - Arguments to delete one Conversations_members.
     * @example
     * // Delete one Conversations_members
     * const Conversations_members = await prisma.conversations_members.delete({
     *   where: {
     *     // ... filter to delete one Conversations_members
     *   }
     * })
     * 
    **/
    delete<T extends conversations_membersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, conversations_membersDeleteArgs<ExtArgs>>
    ): Prisma__conversations_membersClient<$Result.GetResult<Prisma.$conversations_membersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Conversations_members.
     * @param {conversations_membersUpdateArgs} args - Arguments to update one Conversations_members.
     * @example
     * // Update one Conversations_members
     * const conversations_members = await prisma.conversations_members.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends conversations_membersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, conversations_membersUpdateArgs<ExtArgs>>
    ): Prisma__conversations_membersClient<$Result.GetResult<Prisma.$conversations_membersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Conversations_members.
     * @param {conversations_membersDeleteManyArgs} args - Arguments to filter Conversations_members to delete.
     * @example
     * // Delete a few Conversations_members
     * const { count } = await prisma.conversations_members.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends conversations_membersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, conversations_membersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversations_membersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations_members
     * const conversations_members = await prisma.conversations_members.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends conversations_membersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, conversations_membersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conversations_members.
     * @param {conversations_membersUpsertArgs} args - Arguments to update or create a Conversations_members.
     * @example
     * // Update or create a Conversations_members
     * const conversations_members = await prisma.conversations_members.upsert({
     *   create: {
     *     // ... data to create a Conversations_members
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversations_members we want to update
     *   }
     * })
    **/
    upsert<T extends conversations_membersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, conversations_membersUpsertArgs<ExtArgs>>
    ): Prisma__conversations_membersClient<$Result.GetResult<Prisma.$conversations_membersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Conversations_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversations_membersCountArgs} args - Arguments to filter Conversations_members to count.
     * @example
     * // Count the number of Conversations_members
     * const count = await prisma.conversations_members.count({
     *   where: {
     *     // ... the filter for the Conversations_members we want to count
     *   }
     * })
    **/
    count<T extends conversations_membersCountArgs>(
      args?: Subset<T, conversations_membersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Conversations_membersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversations_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Conversations_membersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Conversations_membersAggregateArgs>(args: Subset<T, Conversations_membersAggregateArgs>): Prisma.PrismaPromise<GetConversations_membersAggregateType<T>>

    /**
     * Group by Conversations_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversations_membersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends conversations_membersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: conversations_membersGroupByArgs['orderBy'] }
        : { orderBy?: conversations_membersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, conversations_membersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversations_membersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the conversations_members model
   */
  readonly fields: conversations_membersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for conversations_members.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__conversations_membersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    conversations<T extends conversationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, conversationsDefaultArgs<ExtArgs>>): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    entities<T extends entitiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, entitiesDefaultArgs<ExtArgs>>): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the conversations_members model
   */ 
  interface conversations_membersFieldRefs {
    readonly conversations_members_id: FieldRef<"conversations_members", 'String'>
    readonly conversation_id: FieldRef<"conversations_members", 'String'>
    readonly member_id: FieldRef<"conversations_members", 'String'>
  }
    

  // Custom InputTypes

  /**
   * conversations_members findUnique
   */
  export type conversations_membersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_members
     */
    select?: conversations_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_membersInclude<ExtArgs> | null
    /**
     * Filter, which conversations_members to fetch.
     */
    where: conversations_membersWhereUniqueInput
  }


  /**
   * conversations_members findUniqueOrThrow
   */
  export type conversations_membersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_members
     */
    select?: conversations_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_membersInclude<ExtArgs> | null
    /**
     * Filter, which conversations_members to fetch.
     */
    where: conversations_membersWhereUniqueInput
  }


  /**
   * conversations_members findFirst
   */
  export type conversations_membersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_members
     */
    select?: conversations_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_membersInclude<ExtArgs> | null
    /**
     * Filter, which conversations_members to fetch.
     */
    where?: conversations_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations_members to fetch.
     */
    orderBy?: conversations_membersOrderByWithRelationInput | conversations_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conversations_members.
     */
    cursor?: conversations_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conversations_members.
     */
    distinct?: Conversations_membersScalarFieldEnum | Conversations_membersScalarFieldEnum[]
  }


  /**
   * conversations_members findFirstOrThrow
   */
  export type conversations_membersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_members
     */
    select?: conversations_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_membersInclude<ExtArgs> | null
    /**
     * Filter, which conversations_members to fetch.
     */
    where?: conversations_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations_members to fetch.
     */
    orderBy?: conversations_membersOrderByWithRelationInput | conversations_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conversations_members.
     */
    cursor?: conversations_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conversations_members.
     */
    distinct?: Conversations_membersScalarFieldEnum | Conversations_membersScalarFieldEnum[]
  }


  /**
   * conversations_members findMany
   */
  export type conversations_membersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_members
     */
    select?: conversations_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_membersInclude<ExtArgs> | null
    /**
     * Filter, which conversations_members to fetch.
     */
    where?: conversations_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations_members to fetch.
     */
    orderBy?: conversations_membersOrderByWithRelationInput | conversations_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing conversations_members.
     */
    cursor?: conversations_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations_members.
     */
    skip?: number
    distinct?: Conversations_membersScalarFieldEnum | Conversations_membersScalarFieldEnum[]
  }


  /**
   * conversations_members create
   */
  export type conversations_membersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_members
     */
    select?: conversations_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_membersInclude<ExtArgs> | null
    /**
     * The data needed to create a conversations_members.
     */
    data: XOR<conversations_membersCreateInput, conversations_membersUncheckedCreateInput>
  }


  /**
   * conversations_members createMany
   */
  export type conversations_membersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many conversations_members.
     */
    data: conversations_membersCreateManyInput | conversations_membersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * conversations_members update
   */
  export type conversations_membersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_members
     */
    select?: conversations_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_membersInclude<ExtArgs> | null
    /**
     * The data needed to update a conversations_members.
     */
    data: XOR<conversations_membersUpdateInput, conversations_membersUncheckedUpdateInput>
    /**
     * Choose, which conversations_members to update.
     */
    where: conversations_membersWhereUniqueInput
  }


  /**
   * conversations_members updateMany
   */
  export type conversations_membersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update conversations_members.
     */
    data: XOR<conversations_membersUpdateManyMutationInput, conversations_membersUncheckedUpdateManyInput>
    /**
     * Filter which conversations_members to update
     */
    where?: conversations_membersWhereInput
  }


  /**
   * conversations_members upsert
   */
  export type conversations_membersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_members
     */
    select?: conversations_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_membersInclude<ExtArgs> | null
    /**
     * The filter to search for the conversations_members to update in case it exists.
     */
    where: conversations_membersWhereUniqueInput
    /**
     * In case the conversations_members found by the `where` argument doesn't exist, create a new conversations_members with this data.
     */
    create: XOR<conversations_membersCreateInput, conversations_membersUncheckedCreateInput>
    /**
     * In case the conversations_members was found with the provided `where` argument, update it with this data.
     */
    update: XOR<conversations_membersUpdateInput, conversations_membersUncheckedUpdateInput>
  }


  /**
   * conversations_members delete
   */
  export type conversations_membersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_members
     */
    select?: conversations_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_membersInclude<ExtArgs> | null
    /**
     * Filter which conversations_members to delete.
     */
    where: conversations_membersWhereUniqueInput
  }


  /**
   * conversations_members deleteMany
   */
  export type conversations_membersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conversations_members to delete
     */
    where?: conversations_membersWhereInput
  }


  /**
   * conversations_members without action
   */
  export type conversations_membersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_members
     */
    select?: conversations_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_membersInclude<ExtArgs> | null
  }



  /**
   * Model conversations_messages_logs
   */

  export type AggregateConversations_messages_logs = {
    _count: Conversations_messages_logsCountAggregateOutputType | null
    _min: Conversations_messages_logsMinAggregateOutputType | null
    _max: Conversations_messages_logsMaxAggregateOutputType | null
  }

  export type Conversations_messages_logsMinAggregateOutputType = {
    conversations_messages_logs_id: string | null
    conversation_id: string | null
    entity_id: string | null
    message: string | null
    message_date: Date | null
  }

  export type Conversations_messages_logsMaxAggregateOutputType = {
    conversations_messages_logs_id: string | null
    conversation_id: string | null
    entity_id: string | null
    message: string | null
    message_date: Date | null
  }

  export type Conversations_messages_logsCountAggregateOutputType = {
    conversations_messages_logs_id: number
    conversation_id: number
    entity_id: number
    message: number
    message_date: number
    _all: number
  }


  export type Conversations_messages_logsMinAggregateInputType = {
    conversations_messages_logs_id?: true
    conversation_id?: true
    entity_id?: true
    message?: true
    message_date?: true
  }

  export type Conversations_messages_logsMaxAggregateInputType = {
    conversations_messages_logs_id?: true
    conversation_id?: true
    entity_id?: true
    message?: true
    message_date?: true
  }

  export type Conversations_messages_logsCountAggregateInputType = {
    conversations_messages_logs_id?: true
    conversation_id?: true
    entity_id?: true
    message?: true
    message_date?: true
    _all?: true
  }

  export type Conversations_messages_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conversations_messages_logs to aggregate.
     */
    where?: conversations_messages_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations_messages_logs to fetch.
     */
    orderBy?: conversations_messages_logsOrderByWithRelationInput | conversations_messages_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: conversations_messages_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations_messages_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations_messages_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned conversations_messages_logs
    **/
    _count?: true | Conversations_messages_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Conversations_messages_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Conversations_messages_logsMaxAggregateInputType
  }

  export type GetConversations_messages_logsAggregateType<T extends Conversations_messages_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateConversations_messages_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversations_messages_logs[P]>
      : GetScalarType<T[P], AggregateConversations_messages_logs[P]>
  }




  export type conversations_messages_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conversations_messages_logsWhereInput
    orderBy?: conversations_messages_logsOrderByWithAggregationInput | conversations_messages_logsOrderByWithAggregationInput[]
    by: Conversations_messages_logsScalarFieldEnum[] | Conversations_messages_logsScalarFieldEnum
    having?: conversations_messages_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Conversations_messages_logsCountAggregateInputType | true
    _min?: Conversations_messages_logsMinAggregateInputType
    _max?: Conversations_messages_logsMaxAggregateInputType
  }

  export type Conversations_messages_logsGroupByOutputType = {
    conversations_messages_logs_id: string
    conversation_id: string
    entity_id: string
    message: string
    message_date: Date
    _count: Conversations_messages_logsCountAggregateOutputType | null
    _min: Conversations_messages_logsMinAggregateOutputType | null
    _max: Conversations_messages_logsMaxAggregateOutputType | null
  }

  type GetConversations_messages_logsGroupByPayload<T extends conversations_messages_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Conversations_messages_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Conversations_messages_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Conversations_messages_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Conversations_messages_logsGroupByOutputType[P]>
        }
      >
    >


  export type conversations_messages_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    conversations_messages_logs_id?: boolean
    conversation_id?: boolean
    entity_id?: boolean
    message?: boolean
    message_date?: boolean
    conversations?: boolean | conversationsDefaultArgs<ExtArgs>
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversations_messages_logs"]>

  export type conversations_messages_logsSelectScalar = {
    conversations_messages_logs_id?: boolean
    conversation_id?: boolean
    entity_id?: boolean
    message?: boolean
    message_date?: boolean
  }

  export type conversations_messages_logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations?: boolean | conversationsDefaultArgs<ExtArgs>
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
  }


  export type $conversations_messages_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "conversations_messages_logs"
    objects: {
      conversations: Prisma.$conversationsPayload<ExtArgs>
      entities: Prisma.$entitiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      conversations_messages_logs_id: string
      conversation_id: string
      entity_id: string
      message: string
      message_date: Date
    }, ExtArgs["result"]["conversations_messages_logs"]>
    composites: {}
  }


  type conversations_messages_logsGetPayload<S extends boolean | null | undefined | conversations_messages_logsDefaultArgs> = $Result.GetResult<Prisma.$conversations_messages_logsPayload, S>

  type conversations_messages_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<conversations_messages_logsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Conversations_messages_logsCountAggregateInputType | true
    }

  export interface conversations_messages_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['conversations_messages_logs'], meta: { name: 'conversations_messages_logs' } }
    /**
     * Find zero or one Conversations_messages_logs that matches the filter.
     * @param {conversations_messages_logsFindUniqueArgs} args - Arguments to find a Conversations_messages_logs
     * @example
     * // Get one Conversations_messages_logs
     * const conversations_messages_logs = await prisma.conversations_messages_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends conversations_messages_logsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, conversations_messages_logsFindUniqueArgs<ExtArgs>>
    ): Prisma__conversations_messages_logsClient<$Result.GetResult<Prisma.$conversations_messages_logsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Conversations_messages_logs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {conversations_messages_logsFindUniqueOrThrowArgs} args - Arguments to find a Conversations_messages_logs
     * @example
     * // Get one Conversations_messages_logs
     * const conversations_messages_logs = await prisma.conversations_messages_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends conversations_messages_logsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, conversations_messages_logsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__conversations_messages_logsClient<$Result.GetResult<Prisma.$conversations_messages_logsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Conversations_messages_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversations_messages_logsFindFirstArgs} args - Arguments to find a Conversations_messages_logs
     * @example
     * // Get one Conversations_messages_logs
     * const conversations_messages_logs = await prisma.conversations_messages_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends conversations_messages_logsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, conversations_messages_logsFindFirstArgs<ExtArgs>>
    ): Prisma__conversations_messages_logsClient<$Result.GetResult<Prisma.$conversations_messages_logsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Conversations_messages_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversations_messages_logsFindFirstOrThrowArgs} args - Arguments to find a Conversations_messages_logs
     * @example
     * // Get one Conversations_messages_logs
     * const conversations_messages_logs = await prisma.conversations_messages_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends conversations_messages_logsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, conversations_messages_logsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__conversations_messages_logsClient<$Result.GetResult<Prisma.$conversations_messages_logsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Conversations_messages_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversations_messages_logsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations_messages_logs
     * const conversations_messages_logs = await prisma.conversations_messages_logs.findMany()
     * 
     * // Get first 10 Conversations_messages_logs
     * const conversations_messages_logs = await prisma.conversations_messages_logs.findMany({ take: 10 })
     * 
     * // Only select the `conversations_messages_logs_id`
     * const conversations_messages_logsWithConversations_messages_logs_idOnly = await prisma.conversations_messages_logs.findMany({ select: { conversations_messages_logs_id: true } })
     * 
    **/
    findMany<T extends conversations_messages_logsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, conversations_messages_logsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversations_messages_logsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Conversations_messages_logs.
     * @param {conversations_messages_logsCreateArgs} args - Arguments to create a Conversations_messages_logs.
     * @example
     * // Create one Conversations_messages_logs
     * const Conversations_messages_logs = await prisma.conversations_messages_logs.create({
     *   data: {
     *     // ... data to create a Conversations_messages_logs
     *   }
     * })
     * 
    **/
    create<T extends conversations_messages_logsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, conversations_messages_logsCreateArgs<ExtArgs>>
    ): Prisma__conversations_messages_logsClient<$Result.GetResult<Prisma.$conversations_messages_logsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Conversations_messages_logs.
     *     @param {conversations_messages_logsCreateManyArgs} args - Arguments to create many Conversations_messages_logs.
     *     @example
     *     // Create many Conversations_messages_logs
     *     const conversations_messages_logs = await prisma.conversations_messages_logs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends conversations_messages_logsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, conversations_messages_logsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Conversations_messages_logs.
     * @param {conversations_messages_logsDeleteArgs} args - Arguments to delete one Conversations_messages_logs.
     * @example
     * // Delete one Conversations_messages_logs
     * const Conversations_messages_logs = await prisma.conversations_messages_logs.delete({
     *   where: {
     *     // ... filter to delete one Conversations_messages_logs
     *   }
     * })
     * 
    **/
    delete<T extends conversations_messages_logsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, conversations_messages_logsDeleteArgs<ExtArgs>>
    ): Prisma__conversations_messages_logsClient<$Result.GetResult<Prisma.$conversations_messages_logsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Conversations_messages_logs.
     * @param {conversations_messages_logsUpdateArgs} args - Arguments to update one Conversations_messages_logs.
     * @example
     * // Update one Conversations_messages_logs
     * const conversations_messages_logs = await prisma.conversations_messages_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends conversations_messages_logsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, conversations_messages_logsUpdateArgs<ExtArgs>>
    ): Prisma__conversations_messages_logsClient<$Result.GetResult<Prisma.$conversations_messages_logsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Conversations_messages_logs.
     * @param {conversations_messages_logsDeleteManyArgs} args - Arguments to filter Conversations_messages_logs to delete.
     * @example
     * // Delete a few Conversations_messages_logs
     * const { count } = await prisma.conversations_messages_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends conversations_messages_logsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, conversations_messages_logsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations_messages_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversations_messages_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations_messages_logs
     * const conversations_messages_logs = await prisma.conversations_messages_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends conversations_messages_logsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, conversations_messages_logsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conversations_messages_logs.
     * @param {conversations_messages_logsUpsertArgs} args - Arguments to update or create a Conversations_messages_logs.
     * @example
     * // Update or create a Conversations_messages_logs
     * const conversations_messages_logs = await prisma.conversations_messages_logs.upsert({
     *   create: {
     *     // ... data to create a Conversations_messages_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversations_messages_logs we want to update
     *   }
     * })
    **/
    upsert<T extends conversations_messages_logsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, conversations_messages_logsUpsertArgs<ExtArgs>>
    ): Prisma__conversations_messages_logsClient<$Result.GetResult<Prisma.$conversations_messages_logsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Conversations_messages_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversations_messages_logsCountArgs} args - Arguments to filter Conversations_messages_logs to count.
     * @example
     * // Count the number of Conversations_messages_logs
     * const count = await prisma.conversations_messages_logs.count({
     *   where: {
     *     // ... the filter for the Conversations_messages_logs we want to count
     *   }
     * })
    **/
    count<T extends conversations_messages_logsCountArgs>(
      args?: Subset<T, conversations_messages_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Conversations_messages_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversations_messages_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Conversations_messages_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Conversations_messages_logsAggregateArgs>(args: Subset<T, Conversations_messages_logsAggregateArgs>): Prisma.PrismaPromise<GetConversations_messages_logsAggregateType<T>>

    /**
     * Group by Conversations_messages_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversations_messages_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends conversations_messages_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: conversations_messages_logsGroupByArgs['orderBy'] }
        : { orderBy?: conversations_messages_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, conversations_messages_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversations_messages_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the conversations_messages_logs model
   */
  readonly fields: conversations_messages_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for conversations_messages_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__conversations_messages_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    conversations<T extends conversationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, conversationsDefaultArgs<ExtArgs>>): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    entities<T extends entitiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, entitiesDefaultArgs<ExtArgs>>): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the conversations_messages_logs model
   */ 
  interface conversations_messages_logsFieldRefs {
    readonly conversations_messages_logs_id: FieldRef<"conversations_messages_logs", 'String'>
    readonly conversation_id: FieldRef<"conversations_messages_logs", 'String'>
    readonly entity_id: FieldRef<"conversations_messages_logs", 'String'>
    readonly message: FieldRef<"conversations_messages_logs", 'String'>
    readonly message_date: FieldRef<"conversations_messages_logs", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * conversations_messages_logs findUnique
   */
  export type conversations_messages_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_messages_logs
     */
    select?: conversations_messages_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_messages_logsInclude<ExtArgs> | null
    /**
     * Filter, which conversations_messages_logs to fetch.
     */
    where: conversations_messages_logsWhereUniqueInput
  }


  /**
   * conversations_messages_logs findUniqueOrThrow
   */
  export type conversations_messages_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_messages_logs
     */
    select?: conversations_messages_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_messages_logsInclude<ExtArgs> | null
    /**
     * Filter, which conversations_messages_logs to fetch.
     */
    where: conversations_messages_logsWhereUniqueInput
  }


  /**
   * conversations_messages_logs findFirst
   */
  export type conversations_messages_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_messages_logs
     */
    select?: conversations_messages_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_messages_logsInclude<ExtArgs> | null
    /**
     * Filter, which conversations_messages_logs to fetch.
     */
    where?: conversations_messages_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations_messages_logs to fetch.
     */
    orderBy?: conversations_messages_logsOrderByWithRelationInput | conversations_messages_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conversations_messages_logs.
     */
    cursor?: conversations_messages_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations_messages_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations_messages_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conversations_messages_logs.
     */
    distinct?: Conversations_messages_logsScalarFieldEnum | Conversations_messages_logsScalarFieldEnum[]
  }


  /**
   * conversations_messages_logs findFirstOrThrow
   */
  export type conversations_messages_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_messages_logs
     */
    select?: conversations_messages_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_messages_logsInclude<ExtArgs> | null
    /**
     * Filter, which conversations_messages_logs to fetch.
     */
    where?: conversations_messages_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations_messages_logs to fetch.
     */
    orderBy?: conversations_messages_logsOrderByWithRelationInput | conversations_messages_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conversations_messages_logs.
     */
    cursor?: conversations_messages_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations_messages_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations_messages_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conversations_messages_logs.
     */
    distinct?: Conversations_messages_logsScalarFieldEnum | Conversations_messages_logsScalarFieldEnum[]
  }


  /**
   * conversations_messages_logs findMany
   */
  export type conversations_messages_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_messages_logs
     */
    select?: conversations_messages_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_messages_logsInclude<ExtArgs> | null
    /**
     * Filter, which conversations_messages_logs to fetch.
     */
    where?: conversations_messages_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations_messages_logs to fetch.
     */
    orderBy?: conversations_messages_logsOrderByWithRelationInput | conversations_messages_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing conversations_messages_logs.
     */
    cursor?: conversations_messages_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations_messages_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations_messages_logs.
     */
    skip?: number
    distinct?: Conversations_messages_logsScalarFieldEnum | Conversations_messages_logsScalarFieldEnum[]
  }


  /**
   * conversations_messages_logs create
   */
  export type conversations_messages_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_messages_logs
     */
    select?: conversations_messages_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_messages_logsInclude<ExtArgs> | null
    /**
     * The data needed to create a conversations_messages_logs.
     */
    data: XOR<conversations_messages_logsCreateInput, conversations_messages_logsUncheckedCreateInput>
  }


  /**
   * conversations_messages_logs createMany
   */
  export type conversations_messages_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many conversations_messages_logs.
     */
    data: conversations_messages_logsCreateManyInput | conversations_messages_logsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * conversations_messages_logs update
   */
  export type conversations_messages_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_messages_logs
     */
    select?: conversations_messages_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_messages_logsInclude<ExtArgs> | null
    /**
     * The data needed to update a conversations_messages_logs.
     */
    data: XOR<conversations_messages_logsUpdateInput, conversations_messages_logsUncheckedUpdateInput>
    /**
     * Choose, which conversations_messages_logs to update.
     */
    where: conversations_messages_logsWhereUniqueInput
  }


  /**
   * conversations_messages_logs updateMany
   */
  export type conversations_messages_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update conversations_messages_logs.
     */
    data: XOR<conversations_messages_logsUpdateManyMutationInput, conversations_messages_logsUncheckedUpdateManyInput>
    /**
     * Filter which conversations_messages_logs to update
     */
    where?: conversations_messages_logsWhereInput
  }


  /**
   * conversations_messages_logs upsert
   */
  export type conversations_messages_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_messages_logs
     */
    select?: conversations_messages_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_messages_logsInclude<ExtArgs> | null
    /**
     * The filter to search for the conversations_messages_logs to update in case it exists.
     */
    where: conversations_messages_logsWhereUniqueInput
    /**
     * In case the conversations_messages_logs found by the `where` argument doesn't exist, create a new conversations_messages_logs with this data.
     */
    create: XOR<conversations_messages_logsCreateInput, conversations_messages_logsUncheckedCreateInput>
    /**
     * In case the conversations_messages_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<conversations_messages_logsUpdateInput, conversations_messages_logsUncheckedUpdateInput>
  }


  /**
   * conversations_messages_logs delete
   */
  export type conversations_messages_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_messages_logs
     */
    select?: conversations_messages_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_messages_logsInclude<ExtArgs> | null
    /**
     * Filter which conversations_messages_logs to delete.
     */
    where: conversations_messages_logsWhereUniqueInput
  }


  /**
   * conversations_messages_logs deleteMany
   */
  export type conversations_messages_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conversations_messages_logs to delete
     */
    where?: conversations_messages_logsWhereInput
  }


  /**
   * conversations_messages_logs without action
   */
  export type conversations_messages_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_messages_logs
     */
    select?: conversations_messages_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_messages_logsInclude<ExtArgs> | null
  }



  /**
   * Model conversations_pictures
   */

  export type AggregateConversations_pictures = {
    _count: Conversations_picturesCountAggregateOutputType | null
    _min: Conversations_picturesMinAggregateOutputType | null
    _max: Conversations_picturesMaxAggregateOutputType | null
  }

  export type Conversations_picturesMinAggregateOutputType = {
    conversations_pictures_id: string | null
    conversation_picture_data: Buffer | null
    conversation_picture_filename: string | null
  }

  export type Conversations_picturesMaxAggregateOutputType = {
    conversations_pictures_id: string | null
    conversation_picture_data: Buffer | null
    conversation_picture_filename: string | null
  }

  export type Conversations_picturesCountAggregateOutputType = {
    conversations_pictures_id: number
    conversation_picture_data: number
    conversation_picture_filename: number
    _all: number
  }


  export type Conversations_picturesMinAggregateInputType = {
    conversations_pictures_id?: true
    conversation_picture_data?: true
    conversation_picture_filename?: true
  }

  export type Conversations_picturesMaxAggregateInputType = {
    conversations_pictures_id?: true
    conversation_picture_data?: true
    conversation_picture_filename?: true
  }

  export type Conversations_picturesCountAggregateInputType = {
    conversations_pictures_id?: true
    conversation_picture_data?: true
    conversation_picture_filename?: true
    _all?: true
  }

  export type Conversations_picturesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conversations_pictures to aggregate.
     */
    where?: conversations_picturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations_pictures to fetch.
     */
    orderBy?: conversations_picturesOrderByWithRelationInput | conversations_picturesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: conversations_picturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations_pictures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations_pictures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned conversations_pictures
    **/
    _count?: true | Conversations_picturesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Conversations_picturesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Conversations_picturesMaxAggregateInputType
  }

  export type GetConversations_picturesAggregateType<T extends Conversations_picturesAggregateArgs> = {
        [P in keyof T & keyof AggregateConversations_pictures]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversations_pictures[P]>
      : GetScalarType<T[P], AggregateConversations_pictures[P]>
  }




  export type conversations_picturesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conversations_picturesWhereInput
    orderBy?: conversations_picturesOrderByWithAggregationInput | conversations_picturesOrderByWithAggregationInput[]
    by: Conversations_picturesScalarFieldEnum[] | Conversations_picturesScalarFieldEnum
    having?: conversations_picturesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Conversations_picturesCountAggregateInputType | true
    _min?: Conversations_picturesMinAggregateInputType
    _max?: Conversations_picturesMaxAggregateInputType
  }

  export type Conversations_picturesGroupByOutputType = {
    conversations_pictures_id: string
    conversation_picture_data: Buffer
    conversation_picture_filename: string
    _count: Conversations_picturesCountAggregateOutputType | null
    _min: Conversations_picturesMinAggregateOutputType | null
    _max: Conversations_picturesMaxAggregateOutputType | null
  }

  type GetConversations_picturesGroupByPayload<T extends conversations_picturesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Conversations_picturesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Conversations_picturesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Conversations_picturesGroupByOutputType[P]>
            : GetScalarType<T[P], Conversations_picturesGroupByOutputType[P]>
        }
      >
    >


  export type conversations_picturesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    conversations_pictures_id?: boolean
    conversation_picture_data?: boolean
    conversation_picture_filename?: boolean
    conversations?: boolean | conversations_pictures$conversationsArgs<ExtArgs>
    _count?: boolean | Conversations_picturesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversations_pictures"]>

  export type conversations_picturesSelectScalar = {
    conversations_pictures_id?: boolean
    conversation_picture_data?: boolean
    conversation_picture_filename?: boolean
  }

  export type conversations_picturesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations?: boolean | conversations_pictures$conversationsArgs<ExtArgs>
    _count?: boolean | Conversations_picturesCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $conversations_picturesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "conversations_pictures"
    objects: {
      conversations: Prisma.$conversationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      conversations_pictures_id: string
      conversation_picture_data: Buffer
      conversation_picture_filename: string
    }, ExtArgs["result"]["conversations_pictures"]>
    composites: {}
  }


  type conversations_picturesGetPayload<S extends boolean | null | undefined | conversations_picturesDefaultArgs> = $Result.GetResult<Prisma.$conversations_picturesPayload, S>

  type conversations_picturesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<conversations_picturesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Conversations_picturesCountAggregateInputType | true
    }

  export interface conversations_picturesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['conversations_pictures'], meta: { name: 'conversations_pictures' } }
    /**
     * Find zero or one Conversations_pictures that matches the filter.
     * @param {conversations_picturesFindUniqueArgs} args - Arguments to find a Conversations_pictures
     * @example
     * // Get one Conversations_pictures
     * const conversations_pictures = await prisma.conversations_pictures.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends conversations_picturesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, conversations_picturesFindUniqueArgs<ExtArgs>>
    ): Prisma__conversations_picturesClient<$Result.GetResult<Prisma.$conversations_picturesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Conversations_pictures that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {conversations_picturesFindUniqueOrThrowArgs} args - Arguments to find a Conversations_pictures
     * @example
     * // Get one Conversations_pictures
     * const conversations_pictures = await prisma.conversations_pictures.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends conversations_picturesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, conversations_picturesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__conversations_picturesClient<$Result.GetResult<Prisma.$conversations_picturesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Conversations_pictures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversations_picturesFindFirstArgs} args - Arguments to find a Conversations_pictures
     * @example
     * // Get one Conversations_pictures
     * const conversations_pictures = await prisma.conversations_pictures.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends conversations_picturesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, conversations_picturesFindFirstArgs<ExtArgs>>
    ): Prisma__conversations_picturesClient<$Result.GetResult<Prisma.$conversations_picturesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Conversations_pictures that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversations_picturesFindFirstOrThrowArgs} args - Arguments to find a Conversations_pictures
     * @example
     * // Get one Conversations_pictures
     * const conversations_pictures = await prisma.conversations_pictures.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends conversations_picturesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, conversations_picturesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__conversations_picturesClient<$Result.GetResult<Prisma.$conversations_picturesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Conversations_pictures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversations_picturesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations_pictures
     * const conversations_pictures = await prisma.conversations_pictures.findMany()
     * 
     * // Get first 10 Conversations_pictures
     * const conversations_pictures = await prisma.conversations_pictures.findMany({ take: 10 })
     * 
     * // Only select the `conversations_pictures_id`
     * const conversations_picturesWithConversations_pictures_idOnly = await prisma.conversations_pictures.findMany({ select: { conversations_pictures_id: true } })
     * 
    **/
    findMany<T extends conversations_picturesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, conversations_picturesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversations_picturesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Conversations_pictures.
     * @param {conversations_picturesCreateArgs} args - Arguments to create a Conversations_pictures.
     * @example
     * // Create one Conversations_pictures
     * const Conversations_pictures = await prisma.conversations_pictures.create({
     *   data: {
     *     // ... data to create a Conversations_pictures
     *   }
     * })
     * 
    **/
    create<T extends conversations_picturesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, conversations_picturesCreateArgs<ExtArgs>>
    ): Prisma__conversations_picturesClient<$Result.GetResult<Prisma.$conversations_picturesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Conversations_pictures.
     *     @param {conversations_picturesCreateManyArgs} args - Arguments to create many Conversations_pictures.
     *     @example
     *     // Create many Conversations_pictures
     *     const conversations_pictures = await prisma.conversations_pictures.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends conversations_picturesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, conversations_picturesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Conversations_pictures.
     * @param {conversations_picturesDeleteArgs} args - Arguments to delete one Conversations_pictures.
     * @example
     * // Delete one Conversations_pictures
     * const Conversations_pictures = await prisma.conversations_pictures.delete({
     *   where: {
     *     // ... filter to delete one Conversations_pictures
     *   }
     * })
     * 
    **/
    delete<T extends conversations_picturesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, conversations_picturesDeleteArgs<ExtArgs>>
    ): Prisma__conversations_picturesClient<$Result.GetResult<Prisma.$conversations_picturesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Conversations_pictures.
     * @param {conversations_picturesUpdateArgs} args - Arguments to update one Conversations_pictures.
     * @example
     * // Update one Conversations_pictures
     * const conversations_pictures = await prisma.conversations_pictures.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends conversations_picturesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, conversations_picturesUpdateArgs<ExtArgs>>
    ): Prisma__conversations_picturesClient<$Result.GetResult<Prisma.$conversations_picturesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Conversations_pictures.
     * @param {conversations_picturesDeleteManyArgs} args - Arguments to filter Conversations_pictures to delete.
     * @example
     * // Delete a few Conversations_pictures
     * const { count } = await prisma.conversations_pictures.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends conversations_picturesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, conversations_picturesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations_pictures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversations_picturesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations_pictures
     * const conversations_pictures = await prisma.conversations_pictures.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends conversations_picturesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, conversations_picturesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conversations_pictures.
     * @param {conversations_picturesUpsertArgs} args - Arguments to update or create a Conversations_pictures.
     * @example
     * // Update or create a Conversations_pictures
     * const conversations_pictures = await prisma.conversations_pictures.upsert({
     *   create: {
     *     // ... data to create a Conversations_pictures
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversations_pictures we want to update
     *   }
     * })
    **/
    upsert<T extends conversations_picturesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, conversations_picturesUpsertArgs<ExtArgs>>
    ): Prisma__conversations_picturesClient<$Result.GetResult<Prisma.$conversations_picturesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Conversations_pictures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversations_picturesCountArgs} args - Arguments to filter Conversations_pictures to count.
     * @example
     * // Count the number of Conversations_pictures
     * const count = await prisma.conversations_pictures.count({
     *   where: {
     *     // ... the filter for the Conversations_pictures we want to count
     *   }
     * })
    **/
    count<T extends conversations_picturesCountArgs>(
      args?: Subset<T, conversations_picturesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Conversations_picturesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversations_pictures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Conversations_picturesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Conversations_picturesAggregateArgs>(args: Subset<T, Conversations_picturesAggregateArgs>): Prisma.PrismaPromise<GetConversations_picturesAggregateType<T>>

    /**
     * Group by Conversations_pictures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversations_picturesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends conversations_picturesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: conversations_picturesGroupByArgs['orderBy'] }
        : { orderBy?: conversations_picturesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, conversations_picturesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversations_picturesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the conversations_pictures model
   */
  readonly fields: conversations_picturesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for conversations_pictures.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__conversations_picturesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    conversations<T extends conversations_pictures$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, conversations_pictures$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the conversations_pictures model
   */ 
  interface conversations_picturesFieldRefs {
    readonly conversations_pictures_id: FieldRef<"conversations_pictures", 'String'>
    readonly conversation_picture_data: FieldRef<"conversations_pictures", 'Bytes'>
    readonly conversation_picture_filename: FieldRef<"conversations_pictures", 'String'>
  }
    

  // Custom InputTypes

  /**
   * conversations_pictures findUnique
   */
  export type conversations_picturesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_pictures
     */
    select?: conversations_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_picturesInclude<ExtArgs> | null
    /**
     * Filter, which conversations_pictures to fetch.
     */
    where: conversations_picturesWhereUniqueInput
  }


  /**
   * conversations_pictures findUniqueOrThrow
   */
  export type conversations_picturesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_pictures
     */
    select?: conversations_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_picturesInclude<ExtArgs> | null
    /**
     * Filter, which conversations_pictures to fetch.
     */
    where: conversations_picturesWhereUniqueInput
  }


  /**
   * conversations_pictures findFirst
   */
  export type conversations_picturesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_pictures
     */
    select?: conversations_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_picturesInclude<ExtArgs> | null
    /**
     * Filter, which conversations_pictures to fetch.
     */
    where?: conversations_picturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations_pictures to fetch.
     */
    orderBy?: conversations_picturesOrderByWithRelationInput | conversations_picturesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conversations_pictures.
     */
    cursor?: conversations_picturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations_pictures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations_pictures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conversations_pictures.
     */
    distinct?: Conversations_picturesScalarFieldEnum | Conversations_picturesScalarFieldEnum[]
  }


  /**
   * conversations_pictures findFirstOrThrow
   */
  export type conversations_picturesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_pictures
     */
    select?: conversations_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_picturesInclude<ExtArgs> | null
    /**
     * Filter, which conversations_pictures to fetch.
     */
    where?: conversations_picturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations_pictures to fetch.
     */
    orderBy?: conversations_picturesOrderByWithRelationInput | conversations_picturesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conversations_pictures.
     */
    cursor?: conversations_picturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations_pictures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations_pictures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conversations_pictures.
     */
    distinct?: Conversations_picturesScalarFieldEnum | Conversations_picturesScalarFieldEnum[]
  }


  /**
   * conversations_pictures findMany
   */
  export type conversations_picturesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_pictures
     */
    select?: conversations_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_picturesInclude<ExtArgs> | null
    /**
     * Filter, which conversations_pictures to fetch.
     */
    where?: conversations_picturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations_pictures to fetch.
     */
    orderBy?: conversations_picturesOrderByWithRelationInput | conversations_picturesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing conversations_pictures.
     */
    cursor?: conversations_picturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations_pictures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations_pictures.
     */
    skip?: number
    distinct?: Conversations_picturesScalarFieldEnum | Conversations_picturesScalarFieldEnum[]
  }


  /**
   * conversations_pictures create
   */
  export type conversations_picturesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_pictures
     */
    select?: conversations_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_picturesInclude<ExtArgs> | null
    /**
     * The data needed to create a conversations_pictures.
     */
    data: XOR<conversations_picturesCreateInput, conversations_picturesUncheckedCreateInput>
  }


  /**
   * conversations_pictures createMany
   */
  export type conversations_picturesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many conversations_pictures.
     */
    data: conversations_picturesCreateManyInput | conversations_picturesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * conversations_pictures update
   */
  export type conversations_picturesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_pictures
     */
    select?: conversations_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_picturesInclude<ExtArgs> | null
    /**
     * The data needed to update a conversations_pictures.
     */
    data: XOR<conversations_picturesUpdateInput, conversations_picturesUncheckedUpdateInput>
    /**
     * Choose, which conversations_pictures to update.
     */
    where: conversations_picturesWhereUniqueInput
  }


  /**
   * conversations_pictures updateMany
   */
  export type conversations_picturesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update conversations_pictures.
     */
    data: XOR<conversations_picturesUpdateManyMutationInput, conversations_picturesUncheckedUpdateManyInput>
    /**
     * Filter which conversations_pictures to update
     */
    where?: conversations_picturesWhereInput
  }


  /**
   * conversations_pictures upsert
   */
  export type conversations_picturesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_pictures
     */
    select?: conversations_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_picturesInclude<ExtArgs> | null
    /**
     * The filter to search for the conversations_pictures to update in case it exists.
     */
    where: conversations_picturesWhereUniqueInput
    /**
     * In case the conversations_pictures found by the `where` argument doesn't exist, create a new conversations_pictures with this data.
     */
    create: XOR<conversations_picturesCreateInput, conversations_picturesUncheckedCreateInput>
    /**
     * In case the conversations_pictures was found with the provided `where` argument, update it with this data.
     */
    update: XOR<conversations_picturesUpdateInput, conversations_picturesUncheckedUpdateInput>
  }


  /**
   * conversations_pictures delete
   */
  export type conversations_picturesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_pictures
     */
    select?: conversations_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_picturesInclude<ExtArgs> | null
    /**
     * Filter which conversations_pictures to delete.
     */
    where: conversations_picturesWhereUniqueInput
  }


  /**
   * conversations_pictures deleteMany
   */
  export type conversations_picturesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conversations_pictures to delete
     */
    where?: conversations_picturesWhereInput
  }


  /**
   * conversations_pictures.conversations
   */
  export type conversations_pictures$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversationsInclude<ExtArgs> | null
    where?: conversationsWhereInput
    orderBy?: conversationsOrderByWithRelationInput | conversationsOrderByWithRelationInput[]
    cursor?: conversationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationsScalarFieldEnum | ConversationsScalarFieldEnum[]
  }


  /**
   * conversations_pictures without action
   */
  export type conversations_picturesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_pictures
     */
    select?: conversations_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_picturesInclude<ExtArgs> | null
  }



  /**
   * Model entities
   */

  export type AggregateEntities = {
    _count: EntitiesCountAggregateOutputType | null
    _avg: EntitiesAvgAggregateOutputType | null
    _sum: EntitiesSumAggregateOutputType | null
    _min: EntitiesMinAggregateOutputType | null
    _max: EntitiesMaxAggregateOutputType | null
  }

  export type EntitiesAvgAggregateOutputType = {
    entity_type: number | null
  }

  export type EntitiesSumAggregateOutputType = {
    entity_type: number | null
  }

  export type EntitiesMinAggregateOutputType = {
    entity_id: string | null
    entity_username: string | null
    entity_type: number | null
  }

  export type EntitiesMaxAggregateOutputType = {
    entity_id: string | null
    entity_username: string | null
    entity_type: number | null
  }

  export type EntitiesCountAggregateOutputType = {
    entity_id: number
    entity_username: number
    entity_type: number
    _all: number
  }


  export type EntitiesAvgAggregateInputType = {
    entity_type?: true
  }

  export type EntitiesSumAggregateInputType = {
    entity_type?: true
  }

  export type EntitiesMinAggregateInputType = {
    entity_id?: true
    entity_username?: true
    entity_type?: true
  }

  export type EntitiesMaxAggregateInputType = {
    entity_id?: true
    entity_username?: true
    entity_type?: true
  }

  export type EntitiesCountAggregateInputType = {
    entity_id?: true
    entity_username?: true
    entity_type?: true
    _all?: true
  }

  export type EntitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which entities to aggregate.
     */
    where?: entitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entities to fetch.
     */
    orderBy?: entitiesOrderByWithRelationInput | entitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: entitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned entities
    **/
    _count?: true | EntitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EntitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EntitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntitiesMaxAggregateInputType
  }

  export type GetEntitiesAggregateType<T extends EntitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateEntities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntities[P]>
      : GetScalarType<T[P], AggregateEntities[P]>
  }




  export type entitiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: entitiesWhereInput
    orderBy?: entitiesOrderByWithAggregationInput | entitiesOrderByWithAggregationInput[]
    by: EntitiesScalarFieldEnum[] | EntitiesScalarFieldEnum
    having?: entitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntitiesCountAggregateInputType | true
    _avg?: EntitiesAvgAggregateInputType
    _sum?: EntitiesSumAggregateInputType
    _min?: EntitiesMinAggregateInputType
    _max?: EntitiesMaxAggregateInputType
  }

  export type EntitiesGroupByOutputType = {
    entity_id: string
    entity_username: string
    entity_type: number
    _count: EntitiesCountAggregateOutputType | null
    _avg: EntitiesAvgAggregateOutputType | null
    _sum: EntitiesSumAggregateOutputType | null
    _min: EntitiesMinAggregateOutputType | null
    _max: EntitiesMaxAggregateOutputType | null
  }

  type GetEntitiesGroupByPayload<T extends entitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntitiesGroupByOutputType[P]>
            : GetScalarType<T[P], EntitiesGroupByOutputType[P]>
        }
      >
    >


  export type entitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    entity_id?: boolean
    entity_username?: boolean
    entity_type?: boolean
    collections?: boolean | entities$collectionsArgs<ExtArgs>
    contacts_contacts_contact_id_rootToentities?: boolean | entities$contacts_contacts_contact_id_rootToentitiesArgs<ExtArgs>
    contacts_contacts_contact_id_targetToentities?: boolean | entities$contacts_contacts_contact_id_targetToentitiesArgs<ExtArgs>
    conversations_members?: boolean | entities$conversations_membersArgs<ExtArgs>
    conversations_messages_logs?: boolean | entities$conversations_messages_logsArgs<ExtArgs>
    entities_content?: boolean | entities$entities_contentArgs<ExtArgs>
    entities_dislikes?: boolean | entities$entities_dislikesArgs<ExtArgs>
    entities_likes?: boolean | entities$entities_likesArgs<ExtArgs>
    entities_references?: boolean | entities$entities_referencesArgs<ExtArgs>
    groups_members?: boolean | entities$groups_membersArgs<ExtArgs>
    images?: boolean | entities$imagesArgs<ExtArgs>
    organizations_members?: boolean | entities$organizations_membersArgs<ExtArgs>
    sheets?: boolean | entities$sheetsArgs<ExtArgs>
    tables_members?: boolean | entities$tables_membersArgs<ExtArgs>
    tables_messages_logs?: boolean | entities$tables_messages_logsArgs<ExtArgs>
    tables_tabletops?: boolean | entities$tables_tabletopsArgs<ExtArgs>
    videos?: boolean | entities$videosArgs<ExtArgs>
    _count?: boolean | EntitiesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entities"]>

  export type entitiesSelectScalar = {
    entity_id?: boolean
    entity_username?: boolean
    entity_type?: boolean
  }

  export type entitiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collections?: boolean | entities$collectionsArgs<ExtArgs>
    contacts_contacts_contact_id_rootToentities?: boolean | entities$contacts_contacts_contact_id_rootToentitiesArgs<ExtArgs>
    contacts_contacts_contact_id_targetToentities?: boolean | entities$contacts_contacts_contact_id_targetToentitiesArgs<ExtArgs>
    conversations_members?: boolean | entities$conversations_membersArgs<ExtArgs>
    conversations_messages_logs?: boolean | entities$conversations_messages_logsArgs<ExtArgs>
    entities_content?: boolean | entities$entities_contentArgs<ExtArgs>
    entities_dislikes?: boolean | entities$entities_dislikesArgs<ExtArgs>
    entities_likes?: boolean | entities$entities_likesArgs<ExtArgs>
    entities_references?: boolean | entities$entities_referencesArgs<ExtArgs>
    groups_members?: boolean | entities$groups_membersArgs<ExtArgs>
    images?: boolean | entities$imagesArgs<ExtArgs>
    organizations_members?: boolean | entities$organizations_membersArgs<ExtArgs>
    sheets?: boolean | entities$sheetsArgs<ExtArgs>
    tables_members?: boolean | entities$tables_membersArgs<ExtArgs>
    tables_messages_logs?: boolean | entities$tables_messages_logsArgs<ExtArgs>
    tables_tabletops?: boolean | entities$tables_tabletopsArgs<ExtArgs>
    videos?: boolean | entities$videosArgs<ExtArgs>
    _count?: boolean | EntitiesCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $entitiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "entities"
    objects: {
      collections: Prisma.$collectionsPayload<ExtArgs>[]
      contacts_contacts_contact_id_rootToentities: Prisma.$contactsPayload<ExtArgs>[]
      contacts_contacts_contact_id_targetToentities: Prisma.$contactsPayload<ExtArgs>[]
      conversations_members: Prisma.$conversations_membersPayload<ExtArgs>[]
      conversations_messages_logs: Prisma.$conversations_messages_logsPayload<ExtArgs>[]
      entities_content: Prisma.$entities_contentPayload<ExtArgs>[]
      entities_dislikes: Prisma.$entities_dislikesPayload<ExtArgs>[]
      entities_likes: Prisma.$entities_likesPayload<ExtArgs>[]
      entities_references: Prisma.$entities_referencesPayload<ExtArgs>[]
      groups_members: Prisma.$groups_membersPayload<ExtArgs>[]
      images: Prisma.$imagesPayload<ExtArgs>[]
      organizations_members: Prisma.$organizations_membersPayload<ExtArgs>[]
      sheets: Prisma.$sheetsPayload<ExtArgs>[]
      tables_members: Prisma.$tables_membersPayload<ExtArgs>[]
      tables_messages_logs: Prisma.$tables_messages_logsPayload<ExtArgs>[]
      tables_tabletops: Prisma.$tables_tabletopsPayload<ExtArgs>[]
      videos: Prisma.$videosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      entity_id: string
      entity_username: string
      entity_type: number
    }, ExtArgs["result"]["entities"]>
    composites: {}
  }


  type entitiesGetPayload<S extends boolean | null | undefined | entitiesDefaultArgs> = $Result.GetResult<Prisma.$entitiesPayload, S>

  type entitiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<entitiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EntitiesCountAggregateInputType | true
    }

  export interface entitiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['entities'], meta: { name: 'entities' } }
    /**
     * Find zero or one Entities that matches the filter.
     * @param {entitiesFindUniqueArgs} args - Arguments to find a Entities
     * @example
     * // Get one Entities
     * const entities = await prisma.entities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends entitiesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, entitiesFindUniqueArgs<ExtArgs>>
    ): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Entities that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {entitiesFindUniqueOrThrowArgs} args - Arguments to find a Entities
     * @example
     * // Get one Entities
     * const entities = await prisma.entities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends entitiesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, entitiesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Entities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entitiesFindFirstArgs} args - Arguments to find a Entities
     * @example
     * // Get one Entities
     * const entities = await prisma.entities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends entitiesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, entitiesFindFirstArgs<ExtArgs>>
    ): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Entities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entitiesFindFirstOrThrowArgs} args - Arguments to find a Entities
     * @example
     * // Get one Entities
     * const entities = await prisma.entities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends entitiesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, entitiesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Entities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entitiesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Entities
     * const entities = await prisma.entities.findMany()
     * 
     * // Get first 10 Entities
     * const entities = await prisma.entities.findMany({ take: 10 })
     * 
     * // Only select the `entity_id`
     * const entitiesWithEntity_idOnly = await prisma.entities.findMany({ select: { entity_id: true } })
     * 
    **/
    findMany<T extends entitiesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, entitiesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Entities.
     * @param {entitiesCreateArgs} args - Arguments to create a Entities.
     * @example
     * // Create one Entities
     * const Entities = await prisma.entities.create({
     *   data: {
     *     // ... data to create a Entities
     *   }
     * })
     * 
    **/
    create<T extends entitiesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, entitiesCreateArgs<ExtArgs>>
    ): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Entities.
     *     @param {entitiesCreateManyArgs} args - Arguments to create many Entities.
     *     @example
     *     // Create many Entities
     *     const entities = await prisma.entities.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends entitiesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, entitiesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Entities.
     * @param {entitiesDeleteArgs} args - Arguments to delete one Entities.
     * @example
     * // Delete one Entities
     * const Entities = await prisma.entities.delete({
     *   where: {
     *     // ... filter to delete one Entities
     *   }
     * })
     * 
    **/
    delete<T extends entitiesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, entitiesDeleteArgs<ExtArgs>>
    ): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Entities.
     * @param {entitiesUpdateArgs} args - Arguments to update one Entities.
     * @example
     * // Update one Entities
     * const entities = await prisma.entities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends entitiesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, entitiesUpdateArgs<ExtArgs>>
    ): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Entities.
     * @param {entitiesDeleteManyArgs} args - Arguments to filter Entities to delete.
     * @example
     * // Delete a few Entities
     * const { count } = await prisma.entities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends entitiesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, entitiesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Entities
     * const entities = await prisma.entities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends entitiesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, entitiesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Entities.
     * @param {entitiesUpsertArgs} args - Arguments to update or create a Entities.
     * @example
     * // Update or create a Entities
     * const entities = await prisma.entities.upsert({
     *   create: {
     *     // ... data to create a Entities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Entities we want to update
     *   }
     * })
    **/
    upsert<T extends entitiesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, entitiesUpsertArgs<ExtArgs>>
    ): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Entities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entitiesCountArgs} args - Arguments to filter Entities to count.
     * @example
     * // Count the number of Entities
     * const count = await prisma.entities.count({
     *   where: {
     *     // ... the filter for the Entities we want to count
     *   }
     * })
    **/
    count<T extends entitiesCountArgs>(
      args?: Subset<T, entitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Entities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntitiesAggregateArgs>(args: Subset<T, EntitiesAggregateArgs>): Prisma.PrismaPromise<GetEntitiesAggregateType<T>>

    /**
     * Group by Entities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends entitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: entitiesGroupByArgs['orderBy'] }
        : { orderBy?: entitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, entitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the entities model
   */
  readonly fields: entitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for entities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__entitiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    collections<T extends entities$collectionsArgs<ExtArgs> = {}>(args?: Subset<T, entities$collectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collectionsPayload<ExtArgs>, T, 'findMany'> | Null>;

    contacts_contacts_contact_id_rootToentities<T extends entities$contacts_contacts_contact_id_rootToentitiesArgs<ExtArgs> = {}>(args?: Subset<T, entities$contacts_contacts_contact_id_rootToentitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, 'findMany'> | Null>;

    contacts_contacts_contact_id_targetToentities<T extends entities$contacts_contacts_contact_id_targetToentitiesArgs<ExtArgs> = {}>(args?: Subset<T, entities$contacts_contacts_contact_id_targetToentitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, 'findMany'> | Null>;

    conversations_members<T extends entities$conversations_membersArgs<ExtArgs> = {}>(args?: Subset<T, entities$conversations_membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversations_membersPayload<ExtArgs>, T, 'findMany'> | Null>;

    conversations_messages_logs<T extends entities$conversations_messages_logsArgs<ExtArgs> = {}>(args?: Subset<T, entities$conversations_messages_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversations_messages_logsPayload<ExtArgs>, T, 'findMany'> | Null>;

    entities_content<T extends entities$entities_contentArgs<ExtArgs> = {}>(args?: Subset<T, entities$entities_contentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$entities_contentPayload<ExtArgs>, T, 'findMany'> | Null>;

    entities_dislikes<T extends entities$entities_dislikesArgs<ExtArgs> = {}>(args?: Subset<T, entities$entities_dislikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$entities_dislikesPayload<ExtArgs>, T, 'findMany'> | Null>;

    entities_likes<T extends entities$entities_likesArgs<ExtArgs> = {}>(args?: Subset<T, entities$entities_likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$entities_likesPayload<ExtArgs>, T, 'findMany'> | Null>;

    entities_references<T extends entities$entities_referencesArgs<ExtArgs> = {}>(args?: Subset<T, entities$entities_referencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$entities_referencesPayload<ExtArgs>, T, 'findMany'> | Null>;

    groups_members<T extends entities$groups_membersArgs<ExtArgs> = {}>(args?: Subset<T, entities$groups_membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groups_membersPayload<ExtArgs>, T, 'findMany'> | Null>;

    images<T extends entities$imagesArgs<ExtArgs> = {}>(args?: Subset<T, entities$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, 'findMany'> | Null>;

    organizations_members<T extends entities$organizations_membersArgs<ExtArgs> = {}>(args?: Subset<T, entities$organizations_membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$organizations_membersPayload<ExtArgs>, T, 'findMany'> | Null>;

    sheets<T extends entities$sheetsArgs<ExtArgs> = {}>(args?: Subset<T, entities$sheetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sheetsPayload<ExtArgs>, T, 'findMany'> | Null>;

    tables_members<T extends entities$tables_membersArgs<ExtArgs> = {}>(args?: Subset<T, entities$tables_membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tables_membersPayload<ExtArgs>, T, 'findMany'> | Null>;

    tables_messages_logs<T extends entities$tables_messages_logsArgs<ExtArgs> = {}>(args?: Subset<T, entities$tables_messages_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tables_messages_logsPayload<ExtArgs>, T, 'findMany'> | Null>;

    tables_tabletops<T extends entities$tables_tabletopsArgs<ExtArgs> = {}>(args?: Subset<T, entities$tables_tabletopsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tables_tabletopsPayload<ExtArgs>, T, 'findMany'> | Null>;

    videos<T extends entities$videosArgs<ExtArgs> = {}>(args?: Subset<T, entities$videosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the entities model
   */ 
  interface entitiesFieldRefs {
    readonly entity_id: FieldRef<"entities", 'String'>
    readonly entity_username: FieldRef<"entities", 'String'>
    readonly entity_type: FieldRef<"entities", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * entities findUnique
   */
  export type entitiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entitiesInclude<ExtArgs> | null
    /**
     * Filter, which entities to fetch.
     */
    where: entitiesWhereUniqueInput
  }


  /**
   * entities findUniqueOrThrow
   */
  export type entitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entitiesInclude<ExtArgs> | null
    /**
     * Filter, which entities to fetch.
     */
    where: entitiesWhereUniqueInput
  }


  /**
   * entities findFirst
   */
  export type entitiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entitiesInclude<ExtArgs> | null
    /**
     * Filter, which entities to fetch.
     */
    where?: entitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entities to fetch.
     */
    orderBy?: entitiesOrderByWithRelationInput | entitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for entities.
     */
    cursor?: entitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of entities.
     */
    distinct?: EntitiesScalarFieldEnum | EntitiesScalarFieldEnum[]
  }


  /**
   * entities findFirstOrThrow
   */
  export type entitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entitiesInclude<ExtArgs> | null
    /**
     * Filter, which entities to fetch.
     */
    where?: entitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entities to fetch.
     */
    orderBy?: entitiesOrderByWithRelationInput | entitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for entities.
     */
    cursor?: entitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of entities.
     */
    distinct?: EntitiesScalarFieldEnum | EntitiesScalarFieldEnum[]
  }


  /**
   * entities findMany
   */
  export type entitiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entitiesInclude<ExtArgs> | null
    /**
     * Filter, which entities to fetch.
     */
    where?: entitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entities to fetch.
     */
    orderBy?: entitiesOrderByWithRelationInput | entitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing entities.
     */
    cursor?: entitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entities.
     */
    skip?: number
    distinct?: EntitiesScalarFieldEnum | EntitiesScalarFieldEnum[]
  }


  /**
   * entities create
   */
  export type entitiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entitiesInclude<ExtArgs> | null
    /**
     * The data needed to create a entities.
     */
    data: XOR<entitiesCreateInput, entitiesUncheckedCreateInput>
  }


  /**
   * entities createMany
   */
  export type entitiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many entities.
     */
    data: entitiesCreateManyInput | entitiesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * entities update
   */
  export type entitiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entitiesInclude<ExtArgs> | null
    /**
     * The data needed to update a entities.
     */
    data: XOR<entitiesUpdateInput, entitiesUncheckedUpdateInput>
    /**
     * Choose, which entities to update.
     */
    where: entitiesWhereUniqueInput
  }


  /**
   * entities updateMany
   */
  export type entitiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update entities.
     */
    data: XOR<entitiesUpdateManyMutationInput, entitiesUncheckedUpdateManyInput>
    /**
     * Filter which entities to update
     */
    where?: entitiesWhereInput
  }


  /**
   * entities upsert
   */
  export type entitiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entitiesInclude<ExtArgs> | null
    /**
     * The filter to search for the entities to update in case it exists.
     */
    where: entitiesWhereUniqueInput
    /**
     * In case the entities found by the `where` argument doesn't exist, create a new entities with this data.
     */
    create: XOR<entitiesCreateInput, entitiesUncheckedCreateInput>
    /**
     * In case the entities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<entitiesUpdateInput, entitiesUncheckedUpdateInput>
  }


  /**
   * entities delete
   */
  export type entitiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entitiesInclude<ExtArgs> | null
    /**
     * Filter which entities to delete.
     */
    where: entitiesWhereUniqueInput
  }


  /**
   * entities deleteMany
   */
  export type entitiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which entities to delete
     */
    where?: entitiesWhereInput
  }


  /**
   * entities.collections
   */
  export type entities$collectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collections
     */
    select?: collectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collectionsInclude<ExtArgs> | null
    where?: collectionsWhereInput
    orderBy?: collectionsOrderByWithRelationInput | collectionsOrderByWithRelationInput[]
    cursor?: collectionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollectionsScalarFieldEnum | CollectionsScalarFieldEnum[]
  }


  /**
   * entities.contacts_contacts_contact_id_rootToentities
   */
  export type entities$contacts_contacts_contact_id_rootToentitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contactsInclude<ExtArgs> | null
    where?: contactsWhereInput
    orderBy?: contactsOrderByWithRelationInput | contactsOrderByWithRelationInput[]
    cursor?: contactsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }


  /**
   * entities.contacts_contacts_contact_id_targetToentities
   */
  export type entities$contacts_contacts_contact_id_targetToentitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contactsInclude<ExtArgs> | null
    where?: contactsWhereInput
    orderBy?: contactsOrderByWithRelationInput | contactsOrderByWithRelationInput[]
    cursor?: contactsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }


  /**
   * entities.conversations_members
   */
  export type entities$conversations_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_members
     */
    select?: conversations_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_membersInclude<ExtArgs> | null
    where?: conversations_membersWhereInput
    orderBy?: conversations_membersOrderByWithRelationInput | conversations_membersOrderByWithRelationInput[]
    cursor?: conversations_membersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Conversations_membersScalarFieldEnum | Conversations_membersScalarFieldEnum[]
  }


  /**
   * entities.conversations_messages_logs
   */
  export type entities$conversations_messages_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations_messages_logs
     */
    select?: conversations_messages_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: conversations_messages_logsInclude<ExtArgs> | null
    where?: conversations_messages_logsWhereInput
    orderBy?: conversations_messages_logsOrderByWithRelationInput | conversations_messages_logsOrderByWithRelationInput[]
    cursor?: conversations_messages_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Conversations_messages_logsScalarFieldEnum | Conversations_messages_logsScalarFieldEnum[]
  }


  /**
   * entities.entities_content
   */
  export type entities$entities_contentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_content
     */
    select?: entities_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_contentInclude<ExtArgs> | null
    where?: entities_contentWhereInput
    orderBy?: entities_contentOrderByWithRelationInput | entities_contentOrderByWithRelationInput[]
    cursor?: entities_contentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Entities_contentScalarFieldEnum | Entities_contentScalarFieldEnum[]
  }


  /**
   * entities.entities_dislikes
   */
  export type entities$entities_dislikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_dislikes
     */
    select?: entities_dislikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_dislikesInclude<ExtArgs> | null
    where?: entities_dislikesWhereInput
    orderBy?: entities_dislikesOrderByWithRelationInput | entities_dislikesOrderByWithRelationInput[]
    cursor?: entities_dislikesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Entities_dislikesScalarFieldEnum | Entities_dislikesScalarFieldEnum[]
  }


  /**
   * entities.entities_likes
   */
  export type entities$entities_likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_likes
     */
    select?: entities_likesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_likesInclude<ExtArgs> | null
    where?: entities_likesWhereInput
    orderBy?: entities_likesOrderByWithRelationInput | entities_likesOrderByWithRelationInput[]
    cursor?: entities_likesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Entities_likesScalarFieldEnum | Entities_likesScalarFieldEnum[]
  }


  /**
   * entities.entities_references
   */
  export type entities$entities_referencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_references
     */
    select?: entities_referencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_referencesInclude<ExtArgs> | null
    where?: entities_referencesWhereInput
    orderBy?: entities_referencesOrderByWithRelationInput | entities_referencesOrderByWithRelationInput[]
    cursor?: entities_referencesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Entities_referencesScalarFieldEnum | Entities_referencesScalarFieldEnum[]
  }


  /**
   * entities.groups_members
   */
  export type entities$groups_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups_members
     */
    select?: groups_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groups_membersInclude<ExtArgs> | null
    where?: groups_membersWhereInput
    orderBy?: groups_membersOrderByWithRelationInput | groups_membersOrderByWithRelationInput[]
    cursor?: groups_membersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Groups_membersScalarFieldEnum | Groups_membersScalarFieldEnum[]
  }


  /**
   * entities.images
   */
  export type entities$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagesInclude<ExtArgs> | null
    where?: imagesWhereInput
    orderBy?: imagesOrderByWithRelationInput | imagesOrderByWithRelationInput[]
    cursor?: imagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImagesScalarFieldEnum | ImagesScalarFieldEnum[]
  }


  /**
   * entities.organizations_members
   */
  export type entities$organizations_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations_members
     */
    select?: organizations_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizations_membersInclude<ExtArgs> | null
    where?: organizations_membersWhereInput
    orderBy?: organizations_membersOrderByWithRelationInput | organizations_membersOrderByWithRelationInput[]
    cursor?: organizations_membersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Organizations_membersScalarFieldEnum | Organizations_membersScalarFieldEnum[]
  }


  /**
   * entities.sheets
   */
  export type entities$sheetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets
     */
    select?: sheetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheetsInclude<ExtArgs> | null
    where?: sheetsWhereInput
    orderBy?: sheetsOrderByWithRelationInput | sheetsOrderByWithRelationInput[]
    cursor?: sheetsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SheetsScalarFieldEnum | SheetsScalarFieldEnum[]
  }


  /**
   * entities.tables_members
   */
  export type entities$tables_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_members
     */
    select?: tables_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_membersInclude<ExtArgs> | null
    where?: tables_membersWhereInput
    orderBy?: tables_membersOrderByWithRelationInput | tables_membersOrderByWithRelationInput[]
    cursor?: tables_membersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tables_membersScalarFieldEnum | Tables_membersScalarFieldEnum[]
  }


  /**
   * entities.tables_messages_logs
   */
  export type entities$tables_messages_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_messages_logs
     */
    select?: tables_messages_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_messages_logsInclude<ExtArgs> | null
    where?: tables_messages_logsWhereInput
    orderBy?: tables_messages_logsOrderByWithRelationInput | tables_messages_logsOrderByWithRelationInput[]
    cursor?: tables_messages_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tables_messages_logsScalarFieldEnum | Tables_messages_logsScalarFieldEnum[]
  }


  /**
   * entities.tables_tabletops
   */
  export type entities$tables_tabletopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_tabletops
     */
    select?: tables_tabletopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_tabletopsInclude<ExtArgs> | null
    where?: tables_tabletopsWhereInput
    orderBy?: tables_tabletopsOrderByWithRelationInput | tables_tabletopsOrderByWithRelationInput[]
    cursor?: tables_tabletopsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tables_tabletopsScalarFieldEnum | Tables_tabletopsScalarFieldEnum[]
  }


  /**
   * entities.videos
   */
  export type entities$videosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videosInclude<ExtArgs> | null
    where?: videosWhereInput
    orderBy?: videosOrderByWithRelationInput | videosOrderByWithRelationInput[]
    cursor?: videosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideosScalarFieldEnum | VideosScalarFieldEnum[]
  }


  /**
   * entities without action
   */
  export type entitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entitiesInclude<ExtArgs> | null
  }



  /**
   * Model entities_content
   */

  export type AggregateEntities_content = {
    _count: Entities_contentCountAggregateOutputType | null
    _min: Entities_contentMinAggregateOutputType | null
    _max: Entities_contentMaxAggregateOutputType | null
  }

  export type Entities_contentMinAggregateOutputType = {
    entities_content_id: string | null
    entity_id: string | null
    content_id: string | null
    date_added: Date | null
    pinned: boolean | null
    date_pinned: Date | null
  }

  export type Entities_contentMaxAggregateOutputType = {
    entities_content_id: string | null
    entity_id: string | null
    content_id: string | null
    date_added: Date | null
    pinned: boolean | null
    date_pinned: Date | null
  }

  export type Entities_contentCountAggregateOutputType = {
    entities_content_id: number
    entity_id: number
    content_id: number
    date_added: number
    pinned: number
    date_pinned: number
    _all: number
  }


  export type Entities_contentMinAggregateInputType = {
    entities_content_id?: true
    entity_id?: true
    content_id?: true
    date_added?: true
    pinned?: true
    date_pinned?: true
  }

  export type Entities_contentMaxAggregateInputType = {
    entities_content_id?: true
    entity_id?: true
    content_id?: true
    date_added?: true
    pinned?: true
    date_pinned?: true
  }

  export type Entities_contentCountAggregateInputType = {
    entities_content_id?: true
    entity_id?: true
    content_id?: true
    date_added?: true
    pinned?: true
    date_pinned?: true
    _all?: true
  }

  export type Entities_contentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which entities_content to aggregate.
     */
    where?: entities_contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entities_contents to fetch.
     */
    orderBy?: entities_contentOrderByWithRelationInput | entities_contentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: entities_contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entities_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entities_contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned entities_contents
    **/
    _count?: true | Entities_contentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Entities_contentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Entities_contentMaxAggregateInputType
  }

  export type GetEntities_contentAggregateType<T extends Entities_contentAggregateArgs> = {
        [P in keyof T & keyof AggregateEntities_content]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntities_content[P]>
      : GetScalarType<T[P], AggregateEntities_content[P]>
  }




  export type entities_contentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: entities_contentWhereInput
    orderBy?: entities_contentOrderByWithAggregationInput | entities_contentOrderByWithAggregationInput[]
    by: Entities_contentScalarFieldEnum[] | Entities_contentScalarFieldEnum
    having?: entities_contentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Entities_contentCountAggregateInputType | true
    _min?: Entities_contentMinAggregateInputType
    _max?: Entities_contentMaxAggregateInputType
  }

  export type Entities_contentGroupByOutputType = {
    entities_content_id: string
    entity_id: string
    content_id: string
    date_added: Date
    pinned: boolean
    date_pinned: Date | null
    _count: Entities_contentCountAggregateOutputType | null
    _min: Entities_contentMinAggregateOutputType | null
    _max: Entities_contentMaxAggregateOutputType | null
  }

  type GetEntities_contentGroupByPayload<T extends entities_contentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Entities_contentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Entities_contentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Entities_contentGroupByOutputType[P]>
            : GetScalarType<T[P], Entities_contentGroupByOutputType[P]>
        }
      >
    >


  export type entities_contentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    entities_content_id?: boolean
    entity_id?: boolean
    content_id?: boolean
    date_added?: boolean
    pinned?: boolean
    date_pinned?: boolean
    content?: boolean | contentDefaultArgs<ExtArgs>
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entities_content"]>

  export type entities_contentSelectScalar = {
    entities_content_id?: boolean
    entity_id?: boolean
    content_id?: boolean
    date_added?: boolean
    pinned?: boolean
    date_pinned?: boolean
  }

  export type entities_contentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | contentDefaultArgs<ExtArgs>
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
  }


  export type $entities_contentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "entities_content"
    objects: {
      content: Prisma.$contentPayload<ExtArgs>
      entities: Prisma.$entitiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      entities_content_id: string
      entity_id: string
      content_id: string
      date_added: Date
      pinned: boolean
      date_pinned: Date | null
    }, ExtArgs["result"]["entities_content"]>
    composites: {}
  }


  type entities_contentGetPayload<S extends boolean | null | undefined | entities_contentDefaultArgs> = $Result.GetResult<Prisma.$entities_contentPayload, S>

  type entities_contentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<entities_contentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Entities_contentCountAggregateInputType | true
    }

  export interface entities_contentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['entities_content'], meta: { name: 'entities_content' } }
    /**
     * Find zero or one Entities_content that matches the filter.
     * @param {entities_contentFindUniqueArgs} args - Arguments to find a Entities_content
     * @example
     * // Get one Entities_content
     * const entities_content = await prisma.entities_content.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends entities_contentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, entities_contentFindUniqueArgs<ExtArgs>>
    ): Prisma__entities_contentClient<$Result.GetResult<Prisma.$entities_contentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Entities_content that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {entities_contentFindUniqueOrThrowArgs} args - Arguments to find a Entities_content
     * @example
     * // Get one Entities_content
     * const entities_content = await prisma.entities_content.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends entities_contentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, entities_contentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__entities_contentClient<$Result.GetResult<Prisma.$entities_contentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Entities_content that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entities_contentFindFirstArgs} args - Arguments to find a Entities_content
     * @example
     * // Get one Entities_content
     * const entities_content = await prisma.entities_content.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends entities_contentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, entities_contentFindFirstArgs<ExtArgs>>
    ): Prisma__entities_contentClient<$Result.GetResult<Prisma.$entities_contentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Entities_content that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entities_contentFindFirstOrThrowArgs} args - Arguments to find a Entities_content
     * @example
     * // Get one Entities_content
     * const entities_content = await prisma.entities_content.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends entities_contentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, entities_contentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__entities_contentClient<$Result.GetResult<Prisma.$entities_contentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Entities_contents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entities_contentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Entities_contents
     * const entities_contents = await prisma.entities_content.findMany()
     * 
     * // Get first 10 Entities_contents
     * const entities_contents = await prisma.entities_content.findMany({ take: 10 })
     * 
     * // Only select the `entities_content_id`
     * const entities_contentWithEntities_content_idOnly = await prisma.entities_content.findMany({ select: { entities_content_id: true } })
     * 
    **/
    findMany<T extends entities_contentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, entities_contentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$entities_contentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Entities_content.
     * @param {entities_contentCreateArgs} args - Arguments to create a Entities_content.
     * @example
     * // Create one Entities_content
     * const Entities_content = await prisma.entities_content.create({
     *   data: {
     *     // ... data to create a Entities_content
     *   }
     * })
     * 
    **/
    create<T extends entities_contentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, entities_contentCreateArgs<ExtArgs>>
    ): Prisma__entities_contentClient<$Result.GetResult<Prisma.$entities_contentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Entities_contents.
     *     @param {entities_contentCreateManyArgs} args - Arguments to create many Entities_contents.
     *     @example
     *     // Create many Entities_contents
     *     const entities_content = await prisma.entities_content.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends entities_contentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, entities_contentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Entities_content.
     * @param {entities_contentDeleteArgs} args - Arguments to delete one Entities_content.
     * @example
     * // Delete one Entities_content
     * const Entities_content = await prisma.entities_content.delete({
     *   where: {
     *     // ... filter to delete one Entities_content
     *   }
     * })
     * 
    **/
    delete<T extends entities_contentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, entities_contentDeleteArgs<ExtArgs>>
    ): Prisma__entities_contentClient<$Result.GetResult<Prisma.$entities_contentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Entities_content.
     * @param {entities_contentUpdateArgs} args - Arguments to update one Entities_content.
     * @example
     * // Update one Entities_content
     * const entities_content = await prisma.entities_content.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends entities_contentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, entities_contentUpdateArgs<ExtArgs>>
    ): Prisma__entities_contentClient<$Result.GetResult<Prisma.$entities_contentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Entities_contents.
     * @param {entities_contentDeleteManyArgs} args - Arguments to filter Entities_contents to delete.
     * @example
     * // Delete a few Entities_contents
     * const { count } = await prisma.entities_content.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends entities_contentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, entities_contentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entities_contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entities_contentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Entities_contents
     * const entities_content = await prisma.entities_content.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends entities_contentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, entities_contentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Entities_content.
     * @param {entities_contentUpsertArgs} args - Arguments to update or create a Entities_content.
     * @example
     * // Update or create a Entities_content
     * const entities_content = await prisma.entities_content.upsert({
     *   create: {
     *     // ... data to create a Entities_content
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Entities_content we want to update
     *   }
     * })
    **/
    upsert<T extends entities_contentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, entities_contentUpsertArgs<ExtArgs>>
    ): Prisma__entities_contentClient<$Result.GetResult<Prisma.$entities_contentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Entities_contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entities_contentCountArgs} args - Arguments to filter Entities_contents to count.
     * @example
     * // Count the number of Entities_contents
     * const count = await prisma.entities_content.count({
     *   where: {
     *     // ... the filter for the Entities_contents we want to count
     *   }
     * })
    **/
    count<T extends entities_contentCountArgs>(
      args?: Subset<T, entities_contentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Entities_contentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Entities_content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Entities_contentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Entities_contentAggregateArgs>(args: Subset<T, Entities_contentAggregateArgs>): Prisma.PrismaPromise<GetEntities_contentAggregateType<T>>

    /**
     * Group by Entities_content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entities_contentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends entities_contentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: entities_contentGroupByArgs['orderBy'] }
        : { orderBy?: entities_contentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, entities_contentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntities_contentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the entities_content model
   */
  readonly fields: entities_contentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for entities_content.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__entities_contentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    content<T extends contentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, contentDefaultArgs<ExtArgs>>): Prisma__contentClient<$Result.GetResult<Prisma.$contentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    entities<T extends entitiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, entitiesDefaultArgs<ExtArgs>>): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the entities_content model
   */ 
  interface entities_contentFieldRefs {
    readonly entities_content_id: FieldRef<"entities_content", 'String'>
    readonly entity_id: FieldRef<"entities_content", 'String'>
    readonly content_id: FieldRef<"entities_content", 'String'>
    readonly date_added: FieldRef<"entities_content", 'DateTime'>
    readonly pinned: FieldRef<"entities_content", 'Boolean'>
    readonly date_pinned: FieldRef<"entities_content", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * entities_content findUnique
   */
  export type entities_contentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_content
     */
    select?: entities_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_contentInclude<ExtArgs> | null
    /**
     * Filter, which entities_content to fetch.
     */
    where: entities_contentWhereUniqueInput
  }


  /**
   * entities_content findUniqueOrThrow
   */
  export type entities_contentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_content
     */
    select?: entities_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_contentInclude<ExtArgs> | null
    /**
     * Filter, which entities_content to fetch.
     */
    where: entities_contentWhereUniqueInput
  }


  /**
   * entities_content findFirst
   */
  export type entities_contentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_content
     */
    select?: entities_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_contentInclude<ExtArgs> | null
    /**
     * Filter, which entities_content to fetch.
     */
    where?: entities_contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entities_contents to fetch.
     */
    orderBy?: entities_contentOrderByWithRelationInput | entities_contentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for entities_contents.
     */
    cursor?: entities_contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entities_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entities_contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of entities_contents.
     */
    distinct?: Entities_contentScalarFieldEnum | Entities_contentScalarFieldEnum[]
  }


  /**
   * entities_content findFirstOrThrow
   */
  export type entities_contentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_content
     */
    select?: entities_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_contentInclude<ExtArgs> | null
    /**
     * Filter, which entities_content to fetch.
     */
    where?: entities_contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entities_contents to fetch.
     */
    orderBy?: entities_contentOrderByWithRelationInput | entities_contentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for entities_contents.
     */
    cursor?: entities_contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entities_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entities_contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of entities_contents.
     */
    distinct?: Entities_contentScalarFieldEnum | Entities_contentScalarFieldEnum[]
  }


  /**
   * entities_content findMany
   */
  export type entities_contentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_content
     */
    select?: entities_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_contentInclude<ExtArgs> | null
    /**
     * Filter, which entities_contents to fetch.
     */
    where?: entities_contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entities_contents to fetch.
     */
    orderBy?: entities_contentOrderByWithRelationInput | entities_contentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing entities_contents.
     */
    cursor?: entities_contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entities_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entities_contents.
     */
    skip?: number
    distinct?: Entities_contentScalarFieldEnum | Entities_contentScalarFieldEnum[]
  }


  /**
   * entities_content create
   */
  export type entities_contentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_content
     */
    select?: entities_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_contentInclude<ExtArgs> | null
    /**
     * The data needed to create a entities_content.
     */
    data: XOR<entities_contentCreateInput, entities_contentUncheckedCreateInput>
  }


  /**
   * entities_content createMany
   */
  export type entities_contentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many entities_contents.
     */
    data: entities_contentCreateManyInput | entities_contentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * entities_content update
   */
  export type entities_contentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_content
     */
    select?: entities_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_contentInclude<ExtArgs> | null
    /**
     * The data needed to update a entities_content.
     */
    data: XOR<entities_contentUpdateInput, entities_contentUncheckedUpdateInput>
    /**
     * Choose, which entities_content to update.
     */
    where: entities_contentWhereUniqueInput
  }


  /**
   * entities_content updateMany
   */
  export type entities_contentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update entities_contents.
     */
    data: XOR<entities_contentUpdateManyMutationInput, entities_contentUncheckedUpdateManyInput>
    /**
     * Filter which entities_contents to update
     */
    where?: entities_contentWhereInput
  }


  /**
   * entities_content upsert
   */
  export type entities_contentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_content
     */
    select?: entities_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_contentInclude<ExtArgs> | null
    /**
     * The filter to search for the entities_content to update in case it exists.
     */
    where: entities_contentWhereUniqueInput
    /**
     * In case the entities_content found by the `where` argument doesn't exist, create a new entities_content with this data.
     */
    create: XOR<entities_contentCreateInput, entities_contentUncheckedCreateInput>
    /**
     * In case the entities_content was found with the provided `where` argument, update it with this data.
     */
    update: XOR<entities_contentUpdateInput, entities_contentUncheckedUpdateInput>
  }


  /**
   * entities_content delete
   */
  export type entities_contentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_content
     */
    select?: entities_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_contentInclude<ExtArgs> | null
    /**
     * Filter which entities_content to delete.
     */
    where: entities_contentWhereUniqueInput
  }


  /**
   * entities_content deleteMany
   */
  export type entities_contentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which entities_contents to delete
     */
    where?: entities_contentWhereInput
  }


  /**
   * entities_content without action
   */
  export type entities_contentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_content
     */
    select?: entities_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_contentInclude<ExtArgs> | null
  }



  /**
   * Model entities_dislikes
   */

  export type AggregateEntities_dislikes = {
    _count: Entities_dislikesCountAggregateOutputType | null
    _min: Entities_dislikesMinAggregateOutputType | null
    _max: Entities_dislikesMaxAggregateOutputType | null
  }

  export type Entities_dislikesMinAggregateOutputType = {
    dislike_id: string | null
    entity_id: string | null
    content_id: string | null
  }

  export type Entities_dislikesMaxAggregateOutputType = {
    dislike_id: string | null
    entity_id: string | null
    content_id: string | null
  }

  export type Entities_dislikesCountAggregateOutputType = {
    dislike_id: number
    entity_id: number
    content_id: number
    _all: number
  }


  export type Entities_dislikesMinAggregateInputType = {
    dislike_id?: true
    entity_id?: true
    content_id?: true
  }

  export type Entities_dislikesMaxAggregateInputType = {
    dislike_id?: true
    entity_id?: true
    content_id?: true
  }

  export type Entities_dislikesCountAggregateInputType = {
    dislike_id?: true
    entity_id?: true
    content_id?: true
    _all?: true
  }

  export type Entities_dislikesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which entities_dislikes to aggregate.
     */
    where?: entities_dislikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entities_dislikes to fetch.
     */
    orderBy?: entities_dislikesOrderByWithRelationInput | entities_dislikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: entities_dislikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entities_dislikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entities_dislikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned entities_dislikes
    **/
    _count?: true | Entities_dislikesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Entities_dislikesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Entities_dislikesMaxAggregateInputType
  }

  export type GetEntities_dislikesAggregateType<T extends Entities_dislikesAggregateArgs> = {
        [P in keyof T & keyof AggregateEntities_dislikes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntities_dislikes[P]>
      : GetScalarType<T[P], AggregateEntities_dislikes[P]>
  }




  export type entities_dislikesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: entities_dislikesWhereInput
    orderBy?: entities_dislikesOrderByWithAggregationInput | entities_dislikesOrderByWithAggregationInput[]
    by: Entities_dislikesScalarFieldEnum[] | Entities_dislikesScalarFieldEnum
    having?: entities_dislikesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Entities_dislikesCountAggregateInputType | true
    _min?: Entities_dislikesMinAggregateInputType
    _max?: Entities_dislikesMaxAggregateInputType
  }

  export type Entities_dislikesGroupByOutputType = {
    dislike_id: string
    entity_id: string
    content_id: string
    _count: Entities_dislikesCountAggregateOutputType | null
    _min: Entities_dislikesMinAggregateOutputType | null
    _max: Entities_dislikesMaxAggregateOutputType | null
  }

  type GetEntities_dislikesGroupByPayload<T extends entities_dislikesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Entities_dislikesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Entities_dislikesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Entities_dislikesGroupByOutputType[P]>
            : GetScalarType<T[P], Entities_dislikesGroupByOutputType[P]>
        }
      >
    >


  export type entities_dislikesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    dislike_id?: boolean
    entity_id?: boolean
    content_id?: boolean
    content?: boolean | contentDefaultArgs<ExtArgs>
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entities_dislikes"]>

  export type entities_dislikesSelectScalar = {
    dislike_id?: boolean
    entity_id?: boolean
    content_id?: boolean
  }

  export type entities_dislikesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | contentDefaultArgs<ExtArgs>
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
  }


  export type $entities_dislikesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "entities_dislikes"
    objects: {
      content: Prisma.$contentPayload<ExtArgs>
      entities: Prisma.$entitiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      dislike_id: string
      entity_id: string
      content_id: string
    }, ExtArgs["result"]["entities_dislikes"]>
    composites: {}
  }


  type entities_dislikesGetPayload<S extends boolean | null | undefined | entities_dislikesDefaultArgs> = $Result.GetResult<Prisma.$entities_dislikesPayload, S>

  type entities_dislikesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<entities_dislikesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Entities_dislikesCountAggregateInputType | true
    }

  export interface entities_dislikesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['entities_dislikes'], meta: { name: 'entities_dislikes' } }
    /**
     * Find zero or one Entities_dislikes that matches the filter.
     * @param {entities_dislikesFindUniqueArgs} args - Arguments to find a Entities_dislikes
     * @example
     * // Get one Entities_dislikes
     * const entities_dislikes = await prisma.entities_dislikes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends entities_dislikesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, entities_dislikesFindUniqueArgs<ExtArgs>>
    ): Prisma__entities_dislikesClient<$Result.GetResult<Prisma.$entities_dislikesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Entities_dislikes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {entities_dislikesFindUniqueOrThrowArgs} args - Arguments to find a Entities_dislikes
     * @example
     * // Get one Entities_dislikes
     * const entities_dislikes = await prisma.entities_dislikes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends entities_dislikesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, entities_dislikesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__entities_dislikesClient<$Result.GetResult<Prisma.$entities_dislikesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Entities_dislikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entities_dislikesFindFirstArgs} args - Arguments to find a Entities_dislikes
     * @example
     * // Get one Entities_dislikes
     * const entities_dislikes = await prisma.entities_dislikes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends entities_dislikesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, entities_dislikesFindFirstArgs<ExtArgs>>
    ): Prisma__entities_dislikesClient<$Result.GetResult<Prisma.$entities_dislikesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Entities_dislikes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entities_dislikesFindFirstOrThrowArgs} args - Arguments to find a Entities_dislikes
     * @example
     * // Get one Entities_dislikes
     * const entities_dislikes = await prisma.entities_dislikes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends entities_dislikesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, entities_dislikesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__entities_dislikesClient<$Result.GetResult<Prisma.$entities_dislikesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Entities_dislikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entities_dislikesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Entities_dislikes
     * const entities_dislikes = await prisma.entities_dislikes.findMany()
     * 
     * // Get first 10 Entities_dislikes
     * const entities_dislikes = await prisma.entities_dislikes.findMany({ take: 10 })
     * 
     * // Only select the `dislike_id`
     * const entities_dislikesWithDislike_idOnly = await prisma.entities_dislikes.findMany({ select: { dislike_id: true } })
     * 
    **/
    findMany<T extends entities_dislikesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, entities_dislikesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$entities_dislikesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Entities_dislikes.
     * @param {entities_dislikesCreateArgs} args - Arguments to create a Entities_dislikes.
     * @example
     * // Create one Entities_dislikes
     * const Entities_dislikes = await prisma.entities_dislikes.create({
     *   data: {
     *     // ... data to create a Entities_dislikes
     *   }
     * })
     * 
    **/
    create<T extends entities_dislikesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, entities_dislikesCreateArgs<ExtArgs>>
    ): Prisma__entities_dislikesClient<$Result.GetResult<Prisma.$entities_dislikesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Entities_dislikes.
     *     @param {entities_dislikesCreateManyArgs} args - Arguments to create many Entities_dislikes.
     *     @example
     *     // Create many Entities_dislikes
     *     const entities_dislikes = await prisma.entities_dislikes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends entities_dislikesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, entities_dislikesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Entities_dislikes.
     * @param {entities_dislikesDeleteArgs} args - Arguments to delete one Entities_dislikes.
     * @example
     * // Delete one Entities_dislikes
     * const Entities_dislikes = await prisma.entities_dislikes.delete({
     *   where: {
     *     // ... filter to delete one Entities_dislikes
     *   }
     * })
     * 
    **/
    delete<T extends entities_dislikesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, entities_dislikesDeleteArgs<ExtArgs>>
    ): Prisma__entities_dislikesClient<$Result.GetResult<Prisma.$entities_dislikesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Entities_dislikes.
     * @param {entities_dislikesUpdateArgs} args - Arguments to update one Entities_dislikes.
     * @example
     * // Update one Entities_dislikes
     * const entities_dislikes = await prisma.entities_dislikes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends entities_dislikesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, entities_dislikesUpdateArgs<ExtArgs>>
    ): Prisma__entities_dislikesClient<$Result.GetResult<Prisma.$entities_dislikesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Entities_dislikes.
     * @param {entities_dislikesDeleteManyArgs} args - Arguments to filter Entities_dislikes to delete.
     * @example
     * // Delete a few Entities_dislikes
     * const { count } = await prisma.entities_dislikes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends entities_dislikesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, entities_dislikesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entities_dislikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entities_dislikesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Entities_dislikes
     * const entities_dislikes = await prisma.entities_dislikes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends entities_dislikesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, entities_dislikesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Entities_dislikes.
     * @param {entities_dislikesUpsertArgs} args - Arguments to update or create a Entities_dislikes.
     * @example
     * // Update or create a Entities_dislikes
     * const entities_dislikes = await prisma.entities_dislikes.upsert({
     *   create: {
     *     // ... data to create a Entities_dislikes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Entities_dislikes we want to update
     *   }
     * })
    **/
    upsert<T extends entities_dislikesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, entities_dislikesUpsertArgs<ExtArgs>>
    ): Prisma__entities_dislikesClient<$Result.GetResult<Prisma.$entities_dislikesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Entities_dislikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entities_dislikesCountArgs} args - Arguments to filter Entities_dislikes to count.
     * @example
     * // Count the number of Entities_dislikes
     * const count = await prisma.entities_dislikes.count({
     *   where: {
     *     // ... the filter for the Entities_dislikes we want to count
     *   }
     * })
    **/
    count<T extends entities_dislikesCountArgs>(
      args?: Subset<T, entities_dislikesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Entities_dislikesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Entities_dislikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Entities_dislikesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Entities_dislikesAggregateArgs>(args: Subset<T, Entities_dislikesAggregateArgs>): Prisma.PrismaPromise<GetEntities_dislikesAggregateType<T>>

    /**
     * Group by Entities_dislikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entities_dislikesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends entities_dislikesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: entities_dislikesGroupByArgs['orderBy'] }
        : { orderBy?: entities_dislikesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, entities_dislikesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntities_dislikesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the entities_dislikes model
   */
  readonly fields: entities_dislikesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for entities_dislikes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__entities_dislikesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    content<T extends contentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, contentDefaultArgs<ExtArgs>>): Prisma__contentClient<$Result.GetResult<Prisma.$contentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    entities<T extends entitiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, entitiesDefaultArgs<ExtArgs>>): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the entities_dislikes model
   */ 
  interface entities_dislikesFieldRefs {
    readonly dislike_id: FieldRef<"entities_dislikes", 'String'>
    readonly entity_id: FieldRef<"entities_dislikes", 'String'>
    readonly content_id: FieldRef<"entities_dislikes", 'String'>
  }
    

  // Custom InputTypes

  /**
   * entities_dislikes findUnique
   */
  export type entities_dislikesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_dislikes
     */
    select?: entities_dislikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_dislikesInclude<ExtArgs> | null
    /**
     * Filter, which entities_dislikes to fetch.
     */
    where: entities_dislikesWhereUniqueInput
  }


  /**
   * entities_dislikes findUniqueOrThrow
   */
  export type entities_dislikesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_dislikes
     */
    select?: entities_dislikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_dislikesInclude<ExtArgs> | null
    /**
     * Filter, which entities_dislikes to fetch.
     */
    where: entities_dislikesWhereUniqueInput
  }


  /**
   * entities_dislikes findFirst
   */
  export type entities_dislikesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_dislikes
     */
    select?: entities_dislikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_dislikesInclude<ExtArgs> | null
    /**
     * Filter, which entities_dislikes to fetch.
     */
    where?: entities_dislikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entities_dislikes to fetch.
     */
    orderBy?: entities_dislikesOrderByWithRelationInput | entities_dislikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for entities_dislikes.
     */
    cursor?: entities_dislikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entities_dislikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entities_dislikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of entities_dislikes.
     */
    distinct?: Entities_dislikesScalarFieldEnum | Entities_dislikesScalarFieldEnum[]
  }


  /**
   * entities_dislikes findFirstOrThrow
   */
  export type entities_dislikesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_dislikes
     */
    select?: entities_dislikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_dislikesInclude<ExtArgs> | null
    /**
     * Filter, which entities_dislikes to fetch.
     */
    where?: entities_dislikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entities_dislikes to fetch.
     */
    orderBy?: entities_dislikesOrderByWithRelationInput | entities_dislikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for entities_dislikes.
     */
    cursor?: entities_dislikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entities_dislikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entities_dislikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of entities_dislikes.
     */
    distinct?: Entities_dislikesScalarFieldEnum | Entities_dislikesScalarFieldEnum[]
  }


  /**
   * entities_dislikes findMany
   */
  export type entities_dislikesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_dislikes
     */
    select?: entities_dislikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_dislikesInclude<ExtArgs> | null
    /**
     * Filter, which entities_dislikes to fetch.
     */
    where?: entities_dislikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entities_dislikes to fetch.
     */
    orderBy?: entities_dislikesOrderByWithRelationInput | entities_dislikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing entities_dislikes.
     */
    cursor?: entities_dislikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entities_dislikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entities_dislikes.
     */
    skip?: number
    distinct?: Entities_dislikesScalarFieldEnum | Entities_dislikesScalarFieldEnum[]
  }


  /**
   * entities_dislikes create
   */
  export type entities_dislikesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_dislikes
     */
    select?: entities_dislikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_dislikesInclude<ExtArgs> | null
    /**
     * The data needed to create a entities_dislikes.
     */
    data: XOR<entities_dislikesCreateInput, entities_dislikesUncheckedCreateInput>
  }


  /**
   * entities_dislikes createMany
   */
  export type entities_dislikesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many entities_dislikes.
     */
    data: entities_dislikesCreateManyInput | entities_dislikesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * entities_dislikes update
   */
  export type entities_dislikesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_dislikes
     */
    select?: entities_dislikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_dislikesInclude<ExtArgs> | null
    /**
     * The data needed to update a entities_dislikes.
     */
    data: XOR<entities_dislikesUpdateInput, entities_dislikesUncheckedUpdateInput>
    /**
     * Choose, which entities_dislikes to update.
     */
    where: entities_dislikesWhereUniqueInput
  }


  /**
   * entities_dislikes updateMany
   */
  export type entities_dislikesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update entities_dislikes.
     */
    data: XOR<entities_dislikesUpdateManyMutationInput, entities_dislikesUncheckedUpdateManyInput>
    /**
     * Filter which entities_dislikes to update
     */
    where?: entities_dislikesWhereInput
  }


  /**
   * entities_dislikes upsert
   */
  export type entities_dislikesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_dislikes
     */
    select?: entities_dislikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_dislikesInclude<ExtArgs> | null
    /**
     * The filter to search for the entities_dislikes to update in case it exists.
     */
    where: entities_dislikesWhereUniqueInput
    /**
     * In case the entities_dislikes found by the `where` argument doesn't exist, create a new entities_dislikes with this data.
     */
    create: XOR<entities_dislikesCreateInput, entities_dislikesUncheckedCreateInput>
    /**
     * In case the entities_dislikes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<entities_dislikesUpdateInput, entities_dislikesUncheckedUpdateInput>
  }


  /**
   * entities_dislikes delete
   */
  export type entities_dislikesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_dislikes
     */
    select?: entities_dislikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_dislikesInclude<ExtArgs> | null
    /**
     * Filter which entities_dislikes to delete.
     */
    where: entities_dislikesWhereUniqueInput
  }


  /**
   * entities_dislikes deleteMany
   */
  export type entities_dislikesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which entities_dislikes to delete
     */
    where?: entities_dislikesWhereInput
  }


  /**
   * entities_dislikes without action
   */
  export type entities_dislikesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_dislikes
     */
    select?: entities_dislikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_dislikesInclude<ExtArgs> | null
  }



  /**
   * Model entities_likes
   */

  export type AggregateEntities_likes = {
    _count: Entities_likesCountAggregateOutputType | null
    _min: Entities_likesMinAggregateOutputType | null
    _max: Entities_likesMaxAggregateOutputType | null
  }

  export type Entities_likesMinAggregateOutputType = {
    like_id: string | null
    entity_id: string | null
    content_id: string | null
  }

  export type Entities_likesMaxAggregateOutputType = {
    like_id: string | null
    entity_id: string | null
    content_id: string | null
  }

  export type Entities_likesCountAggregateOutputType = {
    like_id: number
    entity_id: number
    content_id: number
    _all: number
  }


  export type Entities_likesMinAggregateInputType = {
    like_id?: true
    entity_id?: true
    content_id?: true
  }

  export type Entities_likesMaxAggregateInputType = {
    like_id?: true
    entity_id?: true
    content_id?: true
  }

  export type Entities_likesCountAggregateInputType = {
    like_id?: true
    entity_id?: true
    content_id?: true
    _all?: true
  }

  export type Entities_likesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which entities_likes to aggregate.
     */
    where?: entities_likesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entities_likes to fetch.
     */
    orderBy?: entities_likesOrderByWithRelationInput | entities_likesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: entities_likesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entities_likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entities_likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned entities_likes
    **/
    _count?: true | Entities_likesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Entities_likesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Entities_likesMaxAggregateInputType
  }

  export type GetEntities_likesAggregateType<T extends Entities_likesAggregateArgs> = {
        [P in keyof T & keyof AggregateEntities_likes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntities_likes[P]>
      : GetScalarType<T[P], AggregateEntities_likes[P]>
  }




  export type entities_likesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: entities_likesWhereInput
    orderBy?: entities_likesOrderByWithAggregationInput | entities_likesOrderByWithAggregationInput[]
    by: Entities_likesScalarFieldEnum[] | Entities_likesScalarFieldEnum
    having?: entities_likesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Entities_likesCountAggregateInputType | true
    _min?: Entities_likesMinAggregateInputType
    _max?: Entities_likesMaxAggregateInputType
  }

  export type Entities_likesGroupByOutputType = {
    like_id: string
    entity_id: string
    content_id: string
    _count: Entities_likesCountAggregateOutputType | null
    _min: Entities_likesMinAggregateOutputType | null
    _max: Entities_likesMaxAggregateOutputType | null
  }

  type GetEntities_likesGroupByPayload<T extends entities_likesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Entities_likesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Entities_likesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Entities_likesGroupByOutputType[P]>
            : GetScalarType<T[P], Entities_likesGroupByOutputType[P]>
        }
      >
    >


  export type entities_likesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    like_id?: boolean
    entity_id?: boolean
    content_id?: boolean
    content?: boolean | contentDefaultArgs<ExtArgs>
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entities_likes"]>

  export type entities_likesSelectScalar = {
    like_id?: boolean
    entity_id?: boolean
    content_id?: boolean
  }

  export type entities_likesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | contentDefaultArgs<ExtArgs>
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
  }


  export type $entities_likesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "entities_likes"
    objects: {
      content: Prisma.$contentPayload<ExtArgs>
      entities: Prisma.$entitiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      like_id: string
      entity_id: string
      content_id: string
    }, ExtArgs["result"]["entities_likes"]>
    composites: {}
  }


  type entities_likesGetPayload<S extends boolean | null | undefined | entities_likesDefaultArgs> = $Result.GetResult<Prisma.$entities_likesPayload, S>

  type entities_likesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<entities_likesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Entities_likesCountAggregateInputType | true
    }

  export interface entities_likesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['entities_likes'], meta: { name: 'entities_likes' } }
    /**
     * Find zero or one Entities_likes that matches the filter.
     * @param {entities_likesFindUniqueArgs} args - Arguments to find a Entities_likes
     * @example
     * // Get one Entities_likes
     * const entities_likes = await prisma.entities_likes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends entities_likesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, entities_likesFindUniqueArgs<ExtArgs>>
    ): Prisma__entities_likesClient<$Result.GetResult<Prisma.$entities_likesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Entities_likes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {entities_likesFindUniqueOrThrowArgs} args - Arguments to find a Entities_likes
     * @example
     * // Get one Entities_likes
     * const entities_likes = await prisma.entities_likes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends entities_likesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, entities_likesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__entities_likesClient<$Result.GetResult<Prisma.$entities_likesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Entities_likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entities_likesFindFirstArgs} args - Arguments to find a Entities_likes
     * @example
     * // Get one Entities_likes
     * const entities_likes = await prisma.entities_likes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends entities_likesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, entities_likesFindFirstArgs<ExtArgs>>
    ): Prisma__entities_likesClient<$Result.GetResult<Prisma.$entities_likesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Entities_likes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entities_likesFindFirstOrThrowArgs} args - Arguments to find a Entities_likes
     * @example
     * // Get one Entities_likes
     * const entities_likes = await prisma.entities_likes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends entities_likesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, entities_likesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__entities_likesClient<$Result.GetResult<Prisma.$entities_likesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Entities_likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entities_likesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Entities_likes
     * const entities_likes = await prisma.entities_likes.findMany()
     * 
     * // Get first 10 Entities_likes
     * const entities_likes = await prisma.entities_likes.findMany({ take: 10 })
     * 
     * // Only select the `like_id`
     * const entities_likesWithLike_idOnly = await prisma.entities_likes.findMany({ select: { like_id: true } })
     * 
    **/
    findMany<T extends entities_likesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, entities_likesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$entities_likesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Entities_likes.
     * @param {entities_likesCreateArgs} args - Arguments to create a Entities_likes.
     * @example
     * // Create one Entities_likes
     * const Entities_likes = await prisma.entities_likes.create({
     *   data: {
     *     // ... data to create a Entities_likes
     *   }
     * })
     * 
    **/
    create<T extends entities_likesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, entities_likesCreateArgs<ExtArgs>>
    ): Prisma__entities_likesClient<$Result.GetResult<Prisma.$entities_likesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Entities_likes.
     *     @param {entities_likesCreateManyArgs} args - Arguments to create many Entities_likes.
     *     @example
     *     // Create many Entities_likes
     *     const entities_likes = await prisma.entities_likes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends entities_likesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, entities_likesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Entities_likes.
     * @param {entities_likesDeleteArgs} args - Arguments to delete one Entities_likes.
     * @example
     * // Delete one Entities_likes
     * const Entities_likes = await prisma.entities_likes.delete({
     *   where: {
     *     // ... filter to delete one Entities_likes
     *   }
     * })
     * 
    **/
    delete<T extends entities_likesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, entities_likesDeleteArgs<ExtArgs>>
    ): Prisma__entities_likesClient<$Result.GetResult<Prisma.$entities_likesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Entities_likes.
     * @param {entities_likesUpdateArgs} args - Arguments to update one Entities_likes.
     * @example
     * // Update one Entities_likes
     * const entities_likes = await prisma.entities_likes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends entities_likesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, entities_likesUpdateArgs<ExtArgs>>
    ): Prisma__entities_likesClient<$Result.GetResult<Prisma.$entities_likesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Entities_likes.
     * @param {entities_likesDeleteManyArgs} args - Arguments to filter Entities_likes to delete.
     * @example
     * // Delete a few Entities_likes
     * const { count } = await prisma.entities_likes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends entities_likesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, entities_likesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entities_likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entities_likesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Entities_likes
     * const entities_likes = await prisma.entities_likes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends entities_likesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, entities_likesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Entities_likes.
     * @param {entities_likesUpsertArgs} args - Arguments to update or create a Entities_likes.
     * @example
     * // Update or create a Entities_likes
     * const entities_likes = await prisma.entities_likes.upsert({
     *   create: {
     *     // ... data to create a Entities_likes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Entities_likes we want to update
     *   }
     * })
    **/
    upsert<T extends entities_likesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, entities_likesUpsertArgs<ExtArgs>>
    ): Prisma__entities_likesClient<$Result.GetResult<Prisma.$entities_likesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Entities_likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entities_likesCountArgs} args - Arguments to filter Entities_likes to count.
     * @example
     * // Count the number of Entities_likes
     * const count = await prisma.entities_likes.count({
     *   where: {
     *     // ... the filter for the Entities_likes we want to count
     *   }
     * })
    **/
    count<T extends entities_likesCountArgs>(
      args?: Subset<T, entities_likesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Entities_likesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Entities_likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Entities_likesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Entities_likesAggregateArgs>(args: Subset<T, Entities_likesAggregateArgs>): Prisma.PrismaPromise<GetEntities_likesAggregateType<T>>

    /**
     * Group by Entities_likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entities_likesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends entities_likesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: entities_likesGroupByArgs['orderBy'] }
        : { orderBy?: entities_likesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, entities_likesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntities_likesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the entities_likes model
   */
  readonly fields: entities_likesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for entities_likes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__entities_likesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    content<T extends contentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, contentDefaultArgs<ExtArgs>>): Prisma__contentClient<$Result.GetResult<Prisma.$contentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    entities<T extends entitiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, entitiesDefaultArgs<ExtArgs>>): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the entities_likes model
   */ 
  interface entities_likesFieldRefs {
    readonly like_id: FieldRef<"entities_likes", 'String'>
    readonly entity_id: FieldRef<"entities_likes", 'String'>
    readonly content_id: FieldRef<"entities_likes", 'String'>
  }
    

  // Custom InputTypes

  /**
   * entities_likes findUnique
   */
  export type entities_likesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_likes
     */
    select?: entities_likesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_likesInclude<ExtArgs> | null
    /**
     * Filter, which entities_likes to fetch.
     */
    where: entities_likesWhereUniqueInput
  }


  /**
   * entities_likes findUniqueOrThrow
   */
  export type entities_likesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_likes
     */
    select?: entities_likesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_likesInclude<ExtArgs> | null
    /**
     * Filter, which entities_likes to fetch.
     */
    where: entities_likesWhereUniqueInput
  }


  /**
   * entities_likes findFirst
   */
  export type entities_likesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_likes
     */
    select?: entities_likesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_likesInclude<ExtArgs> | null
    /**
     * Filter, which entities_likes to fetch.
     */
    where?: entities_likesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entities_likes to fetch.
     */
    orderBy?: entities_likesOrderByWithRelationInput | entities_likesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for entities_likes.
     */
    cursor?: entities_likesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entities_likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entities_likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of entities_likes.
     */
    distinct?: Entities_likesScalarFieldEnum | Entities_likesScalarFieldEnum[]
  }


  /**
   * entities_likes findFirstOrThrow
   */
  export type entities_likesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_likes
     */
    select?: entities_likesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_likesInclude<ExtArgs> | null
    /**
     * Filter, which entities_likes to fetch.
     */
    where?: entities_likesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entities_likes to fetch.
     */
    orderBy?: entities_likesOrderByWithRelationInput | entities_likesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for entities_likes.
     */
    cursor?: entities_likesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entities_likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entities_likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of entities_likes.
     */
    distinct?: Entities_likesScalarFieldEnum | Entities_likesScalarFieldEnum[]
  }


  /**
   * entities_likes findMany
   */
  export type entities_likesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_likes
     */
    select?: entities_likesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_likesInclude<ExtArgs> | null
    /**
     * Filter, which entities_likes to fetch.
     */
    where?: entities_likesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entities_likes to fetch.
     */
    orderBy?: entities_likesOrderByWithRelationInput | entities_likesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing entities_likes.
     */
    cursor?: entities_likesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entities_likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entities_likes.
     */
    skip?: number
    distinct?: Entities_likesScalarFieldEnum | Entities_likesScalarFieldEnum[]
  }


  /**
   * entities_likes create
   */
  export type entities_likesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_likes
     */
    select?: entities_likesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_likesInclude<ExtArgs> | null
    /**
     * The data needed to create a entities_likes.
     */
    data: XOR<entities_likesCreateInput, entities_likesUncheckedCreateInput>
  }


  /**
   * entities_likes createMany
   */
  export type entities_likesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many entities_likes.
     */
    data: entities_likesCreateManyInput | entities_likesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * entities_likes update
   */
  export type entities_likesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_likes
     */
    select?: entities_likesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_likesInclude<ExtArgs> | null
    /**
     * The data needed to update a entities_likes.
     */
    data: XOR<entities_likesUpdateInput, entities_likesUncheckedUpdateInput>
    /**
     * Choose, which entities_likes to update.
     */
    where: entities_likesWhereUniqueInput
  }


  /**
   * entities_likes updateMany
   */
  export type entities_likesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update entities_likes.
     */
    data: XOR<entities_likesUpdateManyMutationInput, entities_likesUncheckedUpdateManyInput>
    /**
     * Filter which entities_likes to update
     */
    where?: entities_likesWhereInput
  }


  /**
   * entities_likes upsert
   */
  export type entities_likesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_likes
     */
    select?: entities_likesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_likesInclude<ExtArgs> | null
    /**
     * The filter to search for the entities_likes to update in case it exists.
     */
    where: entities_likesWhereUniqueInput
    /**
     * In case the entities_likes found by the `where` argument doesn't exist, create a new entities_likes with this data.
     */
    create: XOR<entities_likesCreateInput, entities_likesUncheckedCreateInput>
    /**
     * In case the entities_likes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<entities_likesUpdateInput, entities_likesUncheckedUpdateInput>
  }


  /**
   * entities_likes delete
   */
  export type entities_likesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_likes
     */
    select?: entities_likesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_likesInclude<ExtArgs> | null
    /**
     * Filter which entities_likes to delete.
     */
    where: entities_likesWhereUniqueInput
  }


  /**
   * entities_likes deleteMany
   */
  export type entities_likesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which entities_likes to delete
     */
    where?: entities_likesWhereInput
  }


  /**
   * entities_likes without action
   */
  export type entities_likesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_likes
     */
    select?: entities_likesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_likesInclude<ExtArgs> | null
  }



  /**
   * Model entities_references
   */

  export type AggregateEntities_references = {
    _count: Entities_referencesCountAggregateOutputType | null
    _min: Entities_referencesMinAggregateOutputType | null
    _max: Entities_referencesMaxAggregateOutputType | null
  }

  export type Entities_referencesMinAggregateOutputType = {
    reference_id: string | null
    entity_id: string | null
    title: string | null
    author: string | null
    url: string | null
  }

  export type Entities_referencesMaxAggregateOutputType = {
    reference_id: string | null
    entity_id: string | null
    title: string | null
    author: string | null
    url: string | null
  }

  export type Entities_referencesCountAggregateOutputType = {
    reference_id: number
    entity_id: number
    title: number
    author: number
    url: number
    _all: number
  }


  export type Entities_referencesMinAggregateInputType = {
    reference_id?: true
    entity_id?: true
    title?: true
    author?: true
    url?: true
  }

  export type Entities_referencesMaxAggregateInputType = {
    reference_id?: true
    entity_id?: true
    title?: true
    author?: true
    url?: true
  }

  export type Entities_referencesCountAggregateInputType = {
    reference_id?: true
    entity_id?: true
    title?: true
    author?: true
    url?: true
    _all?: true
  }

  export type Entities_referencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which entities_references to aggregate.
     */
    where?: entities_referencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entities_references to fetch.
     */
    orderBy?: entities_referencesOrderByWithRelationInput | entities_referencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: entities_referencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entities_references from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entities_references.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned entities_references
    **/
    _count?: true | Entities_referencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Entities_referencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Entities_referencesMaxAggregateInputType
  }

  export type GetEntities_referencesAggregateType<T extends Entities_referencesAggregateArgs> = {
        [P in keyof T & keyof AggregateEntities_references]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntities_references[P]>
      : GetScalarType<T[P], AggregateEntities_references[P]>
  }




  export type entities_referencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: entities_referencesWhereInput
    orderBy?: entities_referencesOrderByWithAggregationInput | entities_referencesOrderByWithAggregationInput[]
    by: Entities_referencesScalarFieldEnum[] | Entities_referencesScalarFieldEnum
    having?: entities_referencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Entities_referencesCountAggregateInputType | true
    _min?: Entities_referencesMinAggregateInputType
    _max?: Entities_referencesMaxAggregateInputType
  }

  export type Entities_referencesGroupByOutputType = {
    reference_id: string
    entity_id: string
    title: string
    author: string
    url: string
    _count: Entities_referencesCountAggregateOutputType | null
    _min: Entities_referencesMinAggregateOutputType | null
    _max: Entities_referencesMaxAggregateOutputType | null
  }

  type GetEntities_referencesGroupByPayload<T extends entities_referencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Entities_referencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Entities_referencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Entities_referencesGroupByOutputType[P]>
            : GetScalarType<T[P], Entities_referencesGroupByOutputType[P]>
        }
      >
    >


  export type entities_referencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    reference_id?: boolean
    entity_id?: boolean
    title?: boolean
    author?: boolean
    url?: boolean
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entities_references"]>

  export type entities_referencesSelectScalar = {
    reference_id?: boolean
    entity_id?: boolean
    title?: boolean
    author?: boolean
    url?: boolean
  }

  export type entities_referencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
  }


  export type $entities_referencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "entities_references"
    objects: {
      entities: Prisma.$entitiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      reference_id: string
      entity_id: string
      title: string
      author: string
      url: string
    }, ExtArgs["result"]["entities_references"]>
    composites: {}
  }


  type entities_referencesGetPayload<S extends boolean | null | undefined | entities_referencesDefaultArgs> = $Result.GetResult<Prisma.$entities_referencesPayload, S>

  type entities_referencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<entities_referencesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Entities_referencesCountAggregateInputType | true
    }

  export interface entities_referencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['entities_references'], meta: { name: 'entities_references' } }
    /**
     * Find zero or one Entities_references that matches the filter.
     * @param {entities_referencesFindUniqueArgs} args - Arguments to find a Entities_references
     * @example
     * // Get one Entities_references
     * const entities_references = await prisma.entities_references.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends entities_referencesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, entities_referencesFindUniqueArgs<ExtArgs>>
    ): Prisma__entities_referencesClient<$Result.GetResult<Prisma.$entities_referencesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Entities_references that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {entities_referencesFindUniqueOrThrowArgs} args - Arguments to find a Entities_references
     * @example
     * // Get one Entities_references
     * const entities_references = await prisma.entities_references.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends entities_referencesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, entities_referencesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__entities_referencesClient<$Result.GetResult<Prisma.$entities_referencesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Entities_references that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entities_referencesFindFirstArgs} args - Arguments to find a Entities_references
     * @example
     * // Get one Entities_references
     * const entities_references = await prisma.entities_references.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends entities_referencesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, entities_referencesFindFirstArgs<ExtArgs>>
    ): Prisma__entities_referencesClient<$Result.GetResult<Prisma.$entities_referencesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Entities_references that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entities_referencesFindFirstOrThrowArgs} args - Arguments to find a Entities_references
     * @example
     * // Get one Entities_references
     * const entities_references = await prisma.entities_references.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends entities_referencesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, entities_referencesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__entities_referencesClient<$Result.GetResult<Prisma.$entities_referencesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Entities_references that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entities_referencesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Entities_references
     * const entities_references = await prisma.entities_references.findMany()
     * 
     * // Get first 10 Entities_references
     * const entities_references = await prisma.entities_references.findMany({ take: 10 })
     * 
     * // Only select the `reference_id`
     * const entities_referencesWithReference_idOnly = await prisma.entities_references.findMany({ select: { reference_id: true } })
     * 
    **/
    findMany<T extends entities_referencesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, entities_referencesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$entities_referencesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Entities_references.
     * @param {entities_referencesCreateArgs} args - Arguments to create a Entities_references.
     * @example
     * // Create one Entities_references
     * const Entities_references = await prisma.entities_references.create({
     *   data: {
     *     // ... data to create a Entities_references
     *   }
     * })
     * 
    **/
    create<T extends entities_referencesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, entities_referencesCreateArgs<ExtArgs>>
    ): Prisma__entities_referencesClient<$Result.GetResult<Prisma.$entities_referencesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Entities_references.
     *     @param {entities_referencesCreateManyArgs} args - Arguments to create many Entities_references.
     *     @example
     *     // Create many Entities_references
     *     const entities_references = await prisma.entities_references.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends entities_referencesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, entities_referencesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Entities_references.
     * @param {entities_referencesDeleteArgs} args - Arguments to delete one Entities_references.
     * @example
     * // Delete one Entities_references
     * const Entities_references = await prisma.entities_references.delete({
     *   where: {
     *     // ... filter to delete one Entities_references
     *   }
     * })
     * 
    **/
    delete<T extends entities_referencesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, entities_referencesDeleteArgs<ExtArgs>>
    ): Prisma__entities_referencesClient<$Result.GetResult<Prisma.$entities_referencesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Entities_references.
     * @param {entities_referencesUpdateArgs} args - Arguments to update one Entities_references.
     * @example
     * // Update one Entities_references
     * const entities_references = await prisma.entities_references.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends entities_referencesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, entities_referencesUpdateArgs<ExtArgs>>
    ): Prisma__entities_referencesClient<$Result.GetResult<Prisma.$entities_referencesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Entities_references.
     * @param {entities_referencesDeleteManyArgs} args - Arguments to filter Entities_references to delete.
     * @example
     * // Delete a few Entities_references
     * const { count } = await prisma.entities_references.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends entities_referencesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, entities_referencesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entities_references.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entities_referencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Entities_references
     * const entities_references = await prisma.entities_references.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends entities_referencesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, entities_referencesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Entities_references.
     * @param {entities_referencesUpsertArgs} args - Arguments to update or create a Entities_references.
     * @example
     * // Update or create a Entities_references
     * const entities_references = await prisma.entities_references.upsert({
     *   create: {
     *     // ... data to create a Entities_references
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Entities_references we want to update
     *   }
     * })
    **/
    upsert<T extends entities_referencesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, entities_referencesUpsertArgs<ExtArgs>>
    ): Prisma__entities_referencesClient<$Result.GetResult<Prisma.$entities_referencesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Entities_references.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entities_referencesCountArgs} args - Arguments to filter Entities_references to count.
     * @example
     * // Count the number of Entities_references
     * const count = await prisma.entities_references.count({
     *   where: {
     *     // ... the filter for the Entities_references we want to count
     *   }
     * })
    **/
    count<T extends entities_referencesCountArgs>(
      args?: Subset<T, entities_referencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Entities_referencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Entities_references.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Entities_referencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Entities_referencesAggregateArgs>(args: Subset<T, Entities_referencesAggregateArgs>): Prisma.PrismaPromise<GetEntities_referencesAggregateType<T>>

    /**
     * Group by Entities_references.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entities_referencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends entities_referencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: entities_referencesGroupByArgs['orderBy'] }
        : { orderBy?: entities_referencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, entities_referencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntities_referencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the entities_references model
   */
  readonly fields: entities_referencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for entities_references.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__entities_referencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    entities<T extends entitiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, entitiesDefaultArgs<ExtArgs>>): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the entities_references model
   */ 
  interface entities_referencesFieldRefs {
    readonly reference_id: FieldRef<"entities_references", 'String'>
    readonly entity_id: FieldRef<"entities_references", 'String'>
    readonly title: FieldRef<"entities_references", 'String'>
    readonly author: FieldRef<"entities_references", 'String'>
    readonly url: FieldRef<"entities_references", 'String'>
  }
    

  // Custom InputTypes

  /**
   * entities_references findUnique
   */
  export type entities_referencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_references
     */
    select?: entities_referencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_referencesInclude<ExtArgs> | null
    /**
     * Filter, which entities_references to fetch.
     */
    where: entities_referencesWhereUniqueInput
  }


  /**
   * entities_references findUniqueOrThrow
   */
  export type entities_referencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_references
     */
    select?: entities_referencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_referencesInclude<ExtArgs> | null
    /**
     * Filter, which entities_references to fetch.
     */
    where: entities_referencesWhereUniqueInput
  }


  /**
   * entities_references findFirst
   */
  export type entities_referencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_references
     */
    select?: entities_referencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_referencesInclude<ExtArgs> | null
    /**
     * Filter, which entities_references to fetch.
     */
    where?: entities_referencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entities_references to fetch.
     */
    orderBy?: entities_referencesOrderByWithRelationInput | entities_referencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for entities_references.
     */
    cursor?: entities_referencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entities_references from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entities_references.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of entities_references.
     */
    distinct?: Entities_referencesScalarFieldEnum | Entities_referencesScalarFieldEnum[]
  }


  /**
   * entities_references findFirstOrThrow
   */
  export type entities_referencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_references
     */
    select?: entities_referencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_referencesInclude<ExtArgs> | null
    /**
     * Filter, which entities_references to fetch.
     */
    where?: entities_referencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entities_references to fetch.
     */
    orderBy?: entities_referencesOrderByWithRelationInput | entities_referencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for entities_references.
     */
    cursor?: entities_referencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entities_references from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entities_references.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of entities_references.
     */
    distinct?: Entities_referencesScalarFieldEnum | Entities_referencesScalarFieldEnum[]
  }


  /**
   * entities_references findMany
   */
  export type entities_referencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_references
     */
    select?: entities_referencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_referencesInclude<ExtArgs> | null
    /**
     * Filter, which entities_references to fetch.
     */
    where?: entities_referencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entities_references to fetch.
     */
    orderBy?: entities_referencesOrderByWithRelationInput | entities_referencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing entities_references.
     */
    cursor?: entities_referencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entities_references from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entities_references.
     */
    skip?: number
    distinct?: Entities_referencesScalarFieldEnum | Entities_referencesScalarFieldEnum[]
  }


  /**
   * entities_references create
   */
  export type entities_referencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_references
     */
    select?: entities_referencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_referencesInclude<ExtArgs> | null
    /**
     * The data needed to create a entities_references.
     */
    data: XOR<entities_referencesCreateInput, entities_referencesUncheckedCreateInput>
  }


  /**
   * entities_references createMany
   */
  export type entities_referencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many entities_references.
     */
    data: entities_referencesCreateManyInput | entities_referencesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * entities_references update
   */
  export type entities_referencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_references
     */
    select?: entities_referencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_referencesInclude<ExtArgs> | null
    /**
     * The data needed to update a entities_references.
     */
    data: XOR<entities_referencesUpdateInput, entities_referencesUncheckedUpdateInput>
    /**
     * Choose, which entities_references to update.
     */
    where: entities_referencesWhereUniqueInput
  }


  /**
   * entities_references updateMany
   */
  export type entities_referencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update entities_references.
     */
    data: XOR<entities_referencesUpdateManyMutationInput, entities_referencesUncheckedUpdateManyInput>
    /**
     * Filter which entities_references to update
     */
    where?: entities_referencesWhereInput
  }


  /**
   * entities_references upsert
   */
  export type entities_referencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_references
     */
    select?: entities_referencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_referencesInclude<ExtArgs> | null
    /**
     * The filter to search for the entities_references to update in case it exists.
     */
    where: entities_referencesWhereUniqueInput
    /**
     * In case the entities_references found by the `where` argument doesn't exist, create a new entities_references with this data.
     */
    create: XOR<entities_referencesCreateInput, entities_referencesUncheckedCreateInput>
    /**
     * In case the entities_references was found with the provided `where` argument, update it with this data.
     */
    update: XOR<entities_referencesUpdateInput, entities_referencesUncheckedUpdateInput>
  }


  /**
   * entities_references delete
   */
  export type entities_referencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_references
     */
    select?: entities_referencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_referencesInclude<ExtArgs> | null
    /**
     * Filter which entities_references to delete.
     */
    where: entities_referencesWhereUniqueInput
  }


  /**
   * entities_references deleteMany
   */
  export type entities_referencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which entities_references to delete
     */
    where?: entities_referencesWhereInput
  }


  /**
   * entities_references without action
   */
  export type entities_referencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities_references
     */
    select?: entities_referencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entities_referencesInclude<ExtArgs> | null
  }



  /**
   * Model groups
   */

  export type AggregateGroups = {
    _count: GroupsCountAggregateOutputType | null
    _min: GroupsMinAggregateOutputType | null
    _max: GroupsMaxAggregateOutputType | null
  }

  export type GroupsMinAggregateOutputType = {
    group_id: string | null
    group_handle: string | null
    group_name: string | null
    group_current_issue: string | null
    group_stances: string | null
    group_description: string | null
    profile_picture_id: string | null
  }

  export type GroupsMaxAggregateOutputType = {
    group_id: string | null
    group_handle: string | null
    group_name: string | null
    group_current_issue: string | null
    group_stances: string | null
    group_description: string | null
    profile_picture_id: string | null
  }

  export type GroupsCountAggregateOutputType = {
    group_id: number
    group_handle: number
    group_name: number
    group_current_issue: number
    group_stances: number
    group_description: number
    profile_picture_id: number
    _all: number
  }


  export type GroupsMinAggregateInputType = {
    group_id?: true
    group_handle?: true
    group_name?: true
    group_current_issue?: true
    group_stances?: true
    group_description?: true
    profile_picture_id?: true
  }

  export type GroupsMaxAggregateInputType = {
    group_id?: true
    group_handle?: true
    group_name?: true
    group_current_issue?: true
    group_stances?: true
    group_description?: true
    profile_picture_id?: true
  }

  export type GroupsCountAggregateInputType = {
    group_id?: true
    group_handle?: true
    group_name?: true
    group_current_issue?: true
    group_stances?: true
    group_description?: true
    profile_picture_id?: true
    _all?: true
  }

  export type GroupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which groups to aggregate.
     */
    where?: groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups to fetch.
     */
    orderBy?: groupsOrderByWithRelationInput | groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned groups
    **/
    _count?: true | GroupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupsMaxAggregateInputType
  }

  export type GetGroupsAggregateType<T extends GroupsAggregateArgs> = {
        [P in keyof T & keyof AggregateGroups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroups[P]>
      : GetScalarType<T[P], AggregateGroups[P]>
  }




  export type groupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: groupsWhereInput
    orderBy?: groupsOrderByWithAggregationInput | groupsOrderByWithAggregationInput[]
    by: GroupsScalarFieldEnum[] | GroupsScalarFieldEnum
    having?: groupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupsCountAggregateInputType | true
    _min?: GroupsMinAggregateInputType
    _max?: GroupsMaxAggregateInputType
  }

  export type GroupsGroupByOutputType = {
    group_id: string
    group_handle: string
    group_name: string | null
    group_current_issue: string | null
    group_stances: string | null
    group_description: string | null
    profile_picture_id: string | null
    _count: GroupsCountAggregateOutputType | null
    _min: GroupsMinAggregateOutputType | null
    _max: GroupsMaxAggregateOutputType | null
  }

  type GetGroupsGroupByPayload<T extends groupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupsGroupByOutputType[P]>
            : GetScalarType<T[P], GroupsGroupByOutputType[P]>
        }
      >
    >


  export type groupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    group_id?: boolean
    group_handle?: boolean
    group_name?: boolean
    group_current_issue?: boolean
    group_stances?: boolean
    group_description?: boolean
    profile_picture_id?: boolean
    profile_pictures?: boolean | groups$profile_picturesArgs<ExtArgs>
    groups_members?: boolean | groups$groups_membersArgs<ExtArgs>
    _count?: boolean | GroupsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groups"]>

  export type groupsSelectScalar = {
    group_id?: boolean
    group_handle?: boolean
    group_name?: boolean
    group_current_issue?: boolean
    group_stances?: boolean
    group_description?: boolean
    profile_picture_id?: boolean
  }

  export type groupsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile_pictures?: boolean | groups$profile_picturesArgs<ExtArgs>
    groups_members?: boolean | groups$groups_membersArgs<ExtArgs>
    _count?: boolean | GroupsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $groupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "groups"
    objects: {
      profile_pictures: Prisma.$profile_picturesPayload<ExtArgs> | null
      groups_members: Prisma.$groups_membersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      group_id: string
      group_handle: string
      group_name: string | null
      group_current_issue: string | null
      group_stances: string | null
      group_description: string | null
      profile_picture_id: string | null
    }, ExtArgs["result"]["groups"]>
    composites: {}
  }


  type groupsGetPayload<S extends boolean | null | undefined | groupsDefaultArgs> = $Result.GetResult<Prisma.$groupsPayload, S>

  type groupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<groupsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GroupsCountAggregateInputType | true
    }

  export interface groupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['groups'], meta: { name: 'groups' } }
    /**
     * Find zero or one Groups that matches the filter.
     * @param {groupsFindUniqueArgs} args - Arguments to find a Groups
     * @example
     * // Get one Groups
     * const groups = await prisma.groups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends groupsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, groupsFindUniqueArgs<ExtArgs>>
    ): Prisma__groupsClient<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Groups that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {groupsFindUniqueOrThrowArgs} args - Arguments to find a Groups
     * @example
     * // Get one Groups
     * const groups = await prisma.groups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends groupsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, groupsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__groupsClient<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupsFindFirstArgs} args - Arguments to find a Groups
     * @example
     * // Get one Groups
     * const groups = await prisma.groups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends groupsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, groupsFindFirstArgs<ExtArgs>>
    ): Prisma__groupsClient<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Groups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupsFindFirstOrThrowArgs} args - Arguments to find a Groups
     * @example
     * // Get one Groups
     * const groups = await prisma.groups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends groupsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, groupsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__groupsClient<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.groups.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.groups.findMany({ take: 10 })
     * 
     * // Only select the `group_id`
     * const groupsWithGroup_idOnly = await prisma.groups.findMany({ select: { group_id: true } })
     * 
    **/
    findMany<T extends groupsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, groupsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Groups.
     * @param {groupsCreateArgs} args - Arguments to create a Groups.
     * @example
     * // Create one Groups
     * const Groups = await prisma.groups.create({
     *   data: {
     *     // ... data to create a Groups
     *   }
     * })
     * 
    **/
    create<T extends groupsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, groupsCreateArgs<ExtArgs>>
    ): Prisma__groupsClient<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Groups.
     *     @param {groupsCreateManyArgs} args - Arguments to create many Groups.
     *     @example
     *     // Create many Groups
     *     const groups = await prisma.groups.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends groupsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, groupsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Groups.
     * @param {groupsDeleteArgs} args - Arguments to delete one Groups.
     * @example
     * // Delete one Groups
     * const Groups = await prisma.groups.delete({
     *   where: {
     *     // ... filter to delete one Groups
     *   }
     * })
     * 
    **/
    delete<T extends groupsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, groupsDeleteArgs<ExtArgs>>
    ): Prisma__groupsClient<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Groups.
     * @param {groupsUpdateArgs} args - Arguments to update one Groups.
     * @example
     * // Update one Groups
     * const groups = await prisma.groups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends groupsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, groupsUpdateArgs<ExtArgs>>
    ): Prisma__groupsClient<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Groups.
     * @param {groupsDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.groups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends groupsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, groupsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const groups = await prisma.groups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends groupsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, groupsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Groups.
     * @param {groupsUpsertArgs} args - Arguments to update or create a Groups.
     * @example
     * // Update or create a Groups
     * const groups = await prisma.groups.upsert({
     *   create: {
     *     // ... data to create a Groups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Groups we want to update
     *   }
     * })
    **/
    upsert<T extends groupsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, groupsUpsertArgs<ExtArgs>>
    ): Prisma__groupsClient<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupsCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.groups.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends groupsCountArgs>(
      args?: Subset<T, groupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupsAggregateArgs>(args: Subset<T, GroupsAggregateArgs>): Prisma.PrismaPromise<GetGroupsAggregateType<T>>

    /**
     * Group by Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends groupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: groupsGroupByArgs['orderBy'] }
        : { orderBy?: groupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, groupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the groups model
   */
  readonly fields: groupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for groups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__groupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    profile_pictures<T extends groups$profile_picturesArgs<ExtArgs> = {}>(args?: Subset<T, groups$profile_picturesArgs<ExtArgs>>): Prisma__profile_picturesClient<$Result.GetResult<Prisma.$profile_picturesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    groups_members<T extends groups$groups_membersArgs<ExtArgs> = {}>(args?: Subset<T, groups$groups_membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groups_membersPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the groups model
   */ 
  interface groupsFieldRefs {
    readonly group_id: FieldRef<"groups", 'String'>
    readonly group_handle: FieldRef<"groups", 'String'>
    readonly group_name: FieldRef<"groups", 'String'>
    readonly group_current_issue: FieldRef<"groups", 'String'>
    readonly group_stances: FieldRef<"groups", 'String'>
    readonly group_description: FieldRef<"groups", 'String'>
    readonly profile_picture_id: FieldRef<"groups", 'String'>
  }
    

  // Custom InputTypes

  /**
   * groups findUnique
   */
  export type groupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groupsInclude<ExtArgs> | null
    /**
     * Filter, which groups to fetch.
     */
    where: groupsWhereUniqueInput
  }


  /**
   * groups findUniqueOrThrow
   */
  export type groupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groupsInclude<ExtArgs> | null
    /**
     * Filter, which groups to fetch.
     */
    where: groupsWhereUniqueInput
  }


  /**
   * groups findFirst
   */
  export type groupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groupsInclude<ExtArgs> | null
    /**
     * Filter, which groups to fetch.
     */
    where?: groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups to fetch.
     */
    orderBy?: groupsOrderByWithRelationInput | groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for groups.
     */
    cursor?: groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of groups.
     */
    distinct?: GroupsScalarFieldEnum | GroupsScalarFieldEnum[]
  }


  /**
   * groups findFirstOrThrow
   */
  export type groupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groupsInclude<ExtArgs> | null
    /**
     * Filter, which groups to fetch.
     */
    where?: groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups to fetch.
     */
    orderBy?: groupsOrderByWithRelationInput | groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for groups.
     */
    cursor?: groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of groups.
     */
    distinct?: GroupsScalarFieldEnum | GroupsScalarFieldEnum[]
  }


  /**
   * groups findMany
   */
  export type groupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groupsInclude<ExtArgs> | null
    /**
     * Filter, which groups to fetch.
     */
    where?: groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups to fetch.
     */
    orderBy?: groupsOrderByWithRelationInput | groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing groups.
     */
    cursor?: groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups.
     */
    skip?: number
    distinct?: GroupsScalarFieldEnum | GroupsScalarFieldEnum[]
  }


  /**
   * groups create
   */
  export type groupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groupsInclude<ExtArgs> | null
    /**
     * The data needed to create a groups.
     */
    data: XOR<groupsCreateInput, groupsUncheckedCreateInput>
  }


  /**
   * groups createMany
   */
  export type groupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many groups.
     */
    data: groupsCreateManyInput | groupsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * groups update
   */
  export type groupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groupsInclude<ExtArgs> | null
    /**
     * The data needed to update a groups.
     */
    data: XOR<groupsUpdateInput, groupsUncheckedUpdateInput>
    /**
     * Choose, which groups to update.
     */
    where: groupsWhereUniqueInput
  }


  /**
   * groups updateMany
   */
  export type groupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update groups.
     */
    data: XOR<groupsUpdateManyMutationInput, groupsUncheckedUpdateManyInput>
    /**
     * Filter which groups to update
     */
    where?: groupsWhereInput
  }


  /**
   * groups upsert
   */
  export type groupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groupsInclude<ExtArgs> | null
    /**
     * The filter to search for the groups to update in case it exists.
     */
    where: groupsWhereUniqueInput
    /**
     * In case the groups found by the `where` argument doesn't exist, create a new groups with this data.
     */
    create: XOR<groupsCreateInput, groupsUncheckedCreateInput>
    /**
     * In case the groups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<groupsUpdateInput, groupsUncheckedUpdateInput>
  }


  /**
   * groups delete
   */
  export type groupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groupsInclude<ExtArgs> | null
    /**
     * Filter which groups to delete.
     */
    where: groupsWhereUniqueInput
  }


  /**
   * groups deleteMany
   */
  export type groupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which groups to delete
     */
    where?: groupsWhereInput
  }


  /**
   * groups.profile_pictures
   */
  export type groups$profile_picturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile_pictures
     */
    select?: profile_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profile_picturesInclude<ExtArgs> | null
    where?: profile_picturesWhereInput
  }


  /**
   * groups.groups_members
   */
  export type groups$groups_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups_members
     */
    select?: groups_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groups_membersInclude<ExtArgs> | null
    where?: groups_membersWhereInput
    orderBy?: groups_membersOrderByWithRelationInput | groups_membersOrderByWithRelationInput[]
    cursor?: groups_membersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Groups_membersScalarFieldEnum | Groups_membersScalarFieldEnum[]
  }


  /**
   * groups without action
   */
  export type groupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groupsInclude<ExtArgs> | null
  }



  /**
   * Model groups_members
   */

  export type AggregateGroups_members = {
    _count: Groups_membersCountAggregateOutputType | null
    _min: Groups_membersMinAggregateOutputType | null
    _max: Groups_membersMaxAggregateOutputType | null
  }

  export type Groups_membersMinAggregateOutputType = {
    groups_members_id: string | null
    group_id: string | null
    entity_id: string | null
  }

  export type Groups_membersMaxAggregateOutputType = {
    groups_members_id: string | null
    group_id: string | null
    entity_id: string | null
  }

  export type Groups_membersCountAggregateOutputType = {
    groups_members_id: number
    group_id: number
    entity_id: number
    _all: number
  }


  export type Groups_membersMinAggregateInputType = {
    groups_members_id?: true
    group_id?: true
    entity_id?: true
  }

  export type Groups_membersMaxAggregateInputType = {
    groups_members_id?: true
    group_id?: true
    entity_id?: true
  }

  export type Groups_membersCountAggregateInputType = {
    groups_members_id?: true
    group_id?: true
    entity_id?: true
    _all?: true
  }

  export type Groups_membersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which groups_members to aggregate.
     */
    where?: groups_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups_members to fetch.
     */
    orderBy?: groups_membersOrderByWithRelationInput | groups_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: groups_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned groups_members
    **/
    _count?: true | Groups_membersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Groups_membersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Groups_membersMaxAggregateInputType
  }

  export type GetGroups_membersAggregateType<T extends Groups_membersAggregateArgs> = {
        [P in keyof T & keyof AggregateGroups_members]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroups_members[P]>
      : GetScalarType<T[P], AggregateGroups_members[P]>
  }




  export type groups_membersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: groups_membersWhereInput
    orderBy?: groups_membersOrderByWithAggregationInput | groups_membersOrderByWithAggregationInput[]
    by: Groups_membersScalarFieldEnum[] | Groups_membersScalarFieldEnum
    having?: groups_membersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Groups_membersCountAggregateInputType | true
    _min?: Groups_membersMinAggregateInputType
    _max?: Groups_membersMaxAggregateInputType
  }

  export type Groups_membersGroupByOutputType = {
    groups_members_id: string
    group_id: string
    entity_id: string
    _count: Groups_membersCountAggregateOutputType | null
    _min: Groups_membersMinAggregateOutputType | null
    _max: Groups_membersMaxAggregateOutputType | null
  }

  type GetGroups_membersGroupByPayload<T extends groups_membersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Groups_membersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Groups_membersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Groups_membersGroupByOutputType[P]>
            : GetScalarType<T[P], Groups_membersGroupByOutputType[P]>
        }
      >
    >


  export type groups_membersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    groups_members_id?: boolean
    group_id?: boolean
    entity_id?: boolean
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
    groups?: boolean | groupsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groups_members"]>

  export type groups_membersSelectScalar = {
    groups_members_id?: boolean
    group_id?: boolean
    entity_id?: boolean
  }

  export type groups_membersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
    groups?: boolean | groupsDefaultArgs<ExtArgs>
  }


  export type $groups_membersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "groups_members"
    objects: {
      entities: Prisma.$entitiesPayload<ExtArgs>
      groups: Prisma.$groupsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      groups_members_id: string
      group_id: string
      entity_id: string
    }, ExtArgs["result"]["groups_members"]>
    composites: {}
  }


  type groups_membersGetPayload<S extends boolean | null | undefined | groups_membersDefaultArgs> = $Result.GetResult<Prisma.$groups_membersPayload, S>

  type groups_membersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<groups_membersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Groups_membersCountAggregateInputType | true
    }

  export interface groups_membersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['groups_members'], meta: { name: 'groups_members' } }
    /**
     * Find zero or one Groups_members that matches the filter.
     * @param {groups_membersFindUniqueArgs} args - Arguments to find a Groups_members
     * @example
     * // Get one Groups_members
     * const groups_members = await prisma.groups_members.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends groups_membersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, groups_membersFindUniqueArgs<ExtArgs>>
    ): Prisma__groups_membersClient<$Result.GetResult<Prisma.$groups_membersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Groups_members that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {groups_membersFindUniqueOrThrowArgs} args - Arguments to find a Groups_members
     * @example
     * // Get one Groups_members
     * const groups_members = await prisma.groups_members.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends groups_membersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, groups_membersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__groups_membersClient<$Result.GetResult<Prisma.$groups_membersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Groups_members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groups_membersFindFirstArgs} args - Arguments to find a Groups_members
     * @example
     * // Get one Groups_members
     * const groups_members = await prisma.groups_members.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends groups_membersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, groups_membersFindFirstArgs<ExtArgs>>
    ): Prisma__groups_membersClient<$Result.GetResult<Prisma.$groups_membersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Groups_members that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groups_membersFindFirstOrThrowArgs} args - Arguments to find a Groups_members
     * @example
     * // Get one Groups_members
     * const groups_members = await prisma.groups_members.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends groups_membersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, groups_membersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__groups_membersClient<$Result.GetResult<Prisma.$groups_membersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Groups_members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groups_membersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups_members
     * const groups_members = await prisma.groups_members.findMany()
     * 
     * // Get first 10 Groups_members
     * const groups_members = await prisma.groups_members.findMany({ take: 10 })
     * 
     * // Only select the `groups_members_id`
     * const groups_membersWithGroups_members_idOnly = await prisma.groups_members.findMany({ select: { groups_members_id: true } })
     * 
    **/
    findMany<T extends groups_membersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, groups_membersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groups_membersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Groups_members.
     * @param {groups_membersCreateArgs} args - Arguments to create a Groups_members.
     * @example
     * // Create one Groups_members
     * const Groups_members = await prisma.groups_members.create({
     *   data: {
     *     // ... data to create a Groups_members
     *   }
     * })
     * 
    **/
    create<T extends groups_membersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, groups_membersCreateArgs<ExtArgs>>
    ): Prisma__groups_membersClient<$Result.GetResult<Prisma.$groups_membersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Groups_members.
     *     @param {groups_membersCreateManyArgs} args - Arguments to create many Groups_members.
     *     @example
     *     // Create many Groups_members
     *     const groups_members = await prisma.groups_members.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends groups_membersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, groups_membersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Groups_members.
     * @param {groups_membersDeleteArgs} args - Arguments to delete one Groups_members.
     * @example
     * // Delete one Groups_members
     * const Groups_members = await prisma.groups_members.delete({
     *   where: {
     *     // ... filter to delete one Groups_members
     *   }
     * })
     * 
    **/
    delete<T extends groups_membersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, groups_membersDeleteArgs<ExtArgs>>
    ): Prisma__groups_membersClient<$Result.GetResult<Prisma.$groups_membersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Groups_members.
     * @param {groups_membersUpdateArgs} args - Arguments to update one Groups_members.
     * @example
     * // Update one Groups_members
     * const groups_members = await prisma.groups_members.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends groups_membersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, groups_membersUpdateArgs<ExtArgs>>
    ): Prisma__groups_membersClient<$Result.GetResult<Prisma.$groups_membersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Groups_members.
     * @param {groups_membersDeleteManyArgs} args - Arguments to filter Groups_members to delete.
     * @example
     * // Delete a few Groups_members
     * const { count } = await prisma.groups_members.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends groups_membersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, groups_membersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groups_membersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups_members
     * const groups_members = await prisma.groups_members.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends groups_membersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, groups_membersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Groups_members.
     * @param {groups_membersUpsertArgs} args - Arguments to update or create a Groups_members.
     * @example
     * // Update or create a Groups_members
     * const groups_members = await prisma.groups_members.upsert({
     *   create: {
     *     // ... data to create a Groups_members
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Groups_members we want to update
     *   }
     * })
    **/
    upsert<T extends groups_membersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, groups_membersUpsertArgs<ExtArgs>>
    ): Prisma__groups_membersClient<$Result.GetResult<Prisma.$groups_membersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Groups_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groups_membersCountArgs} args - Arguments to filter Groups_members to count.
     * @example
     * // Count the number of Groups_members
     * const count = await prisma.groups_members.count({
     *   where: {
     *     // ... the filter for the Groups_members we want to count
     *   }
     * })
    **/
    count<T extends groups_membersCountArgs>(
      args?: Subset<T, groups_membersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Groups_membersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Groups_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Groups_membersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Groups_membersAggregateArgs>(args: Subset<T, Groups_membersAggregateArgs>): Prisma.PrismaPromise<GetGroups_membersAggregateType<T>>

    /**
     * Group by Groups_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groups_membersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends groups_membersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: groups_membersGroupByArgs['orderBy'] }
        : { orderBy?: groups_membersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, groups_membersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroups_membersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the groups_members model
   */
  readonly fields: groups_membersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for groups_members.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__groups_membersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    entities<T extends entitiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, entitiesDefaultArgs<ExtArgs>>): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    groups<T extends groupsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, groupsDefaultArgs<ExtArgs>>): Prisma__groupsClient<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the groups_members model
   */ 
  interface groups_membersFieldRefs {
    readonly groups_members_id: FieldRef<"groups_members", 'String'>
    readonly group_id: FieldRef<"groups_members", 'String'>
    readonly entity_id: FieldRef<"groups_members", 'String'>
  }
    

  // Custom InputTypes

  /**
   * groups_members findUnique
   */
  export type groups_membersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups_members
     */
    select?: groups_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groups_membersInclude<ExtArgs> | null
    /**
     * Filter, which groups_members to fetch.
     */
    where: groups_membersWhereUniqueInput
  }


  /**
   * groups_members findUniqueOrThrow
   */
  export type groups_membersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups_members
     */
    select?: groups_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groups_membersInclude<ExtArgs> | null
    /**
     * Filter, which groups_members to fetch.
     */
    where: groups_membersWhereUniqueInput
  }


  /**
   * groups_members findFirst
   */
  export type groups_membersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups_members
     */
    select?: groups_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groups_membersInclude<ExtArgs> | null
    /**
     * Filter, which groups_members to fetch.
     */
    where?: groups_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups_members to fetch.
     */
    orderBy?: groups_membersOrderByWithRelationInput | groups_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for groups_members.
     */
    cursor?: groups_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of groups_members.
     */
    distinct?: Groups_membersScalarFieldEnum | Groups_membersScalarFieldEnum[]
  }


  /**
   * groups_members findFirstOrThrow
   */
  export type groups_membersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups_members
     */
    select?: groups_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groups_membersInclude<ExtArgs> | null
    /**
     * Filter, which groups_members to fetch.
     */
    where?: groups_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups_members to fetch.
     */
    orderBy?: groups_membersOrderByWithRelationInput | groups_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for groups_members.
     */
    cursor?: groups_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of groups_members.
     */
    distinct?: Groups_membersScalarFieldEnum | Groups_membersScalarFieldEnum[]
  }


  /**
   * groups_members findMany
   */
  export type groups_membersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups_members
     */
    select?: groups_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groups_membersInclude<ExtArgs> | null
    /**
     * Filter, which groups_members to fetch.
     */
    where?: groups_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups_members to fetch.
     */
    orderBy?: groups_membersOrderByWithRelationInput | groups_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing groups_members.
     */
    cursor?: groups_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups_members.
     */
    skip?: number
    distinct?: Groups_membersScalarFieldEnum | Groups_membersScalarFieldEnum[]
  }


  /**
   * groups_members create
   */
  export type groups_membersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups_members
     */
    select?: groups_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groups_membersInclude<ExtArgs> | null
    /**
     * The data needed to create a groups_members.
     */
    data: XOR<groups_membersCreateInput, groups_membersUncheckedCreateInput>
  }


  /**
   * groups_members createMany
   */
  export type groups_membersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many groups_members.
     */
    data: groups_membersCreateManyInput | groups_membersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * groups_members update
   */
  export type groups_membersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups_members
     */
    select?: groups_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groups_membersInclude<ExtArgs> | null
    /**
     * The data needed to update a groups_members.
     */
    data: XOR<groups_membersUpdateInput, groups_membersUncheckedUpdateInput>
    /**
     * Choose, which groups_members to update.
     */
    where: groups_membersWhereUniqueInput
  }


  /**
   * groups_members updateMany
   */
  export type groups_membersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update groups_members.
     */
    data: XOR<groups_membersUpdateManyMutationInput, groups_membersUncheckedUpdateManyInput>
    /**
     * Filter which groups_members to update
     */
    where?: groups_membersWhereInput
  }


  /**
   * groups_members upsert
   */
  export type groups_membersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups_members
     */
    select?: groups_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groups_membersInclude<ExtArgs> | null
    /**
     * The filter to search for the groups_members to update in case it exists.
     */
    where: groups_membersWhereUniqueInput
    /**
     * In case the groups_members found by the `where` argument doesn't exist, create a new groups_members with this data.
     */
    create: XOR<groups_membersCreateInput, groups_membersUncheckedCreateInput>
    /**
     * In case the groups_members was found with the provided `where` argument, update it with this data.
     */
    update: XOR<groups_membersUpdateInput, groups_membersUncheckedUpdateInput>
  }


  /**
   * groups_members delete
   */
  export type groups_membersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups_members
     */
    select?: groups_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groups_membersInclude<ExtArgs> | null
    /**
     * Filter which groups_members to delete.
     */
    where: groups_membersWhereUniqueInput
  }


  /**
   * groups_members deleteMany
   */
  export type groups_membersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which groups_members to delete
     */
    where?: groups_membersWhereInput
  }


  /**
   * groups_members without action
   */
  export type groups_membersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups_members
     */
    select?: groups_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groups_membersInclude<ExtArgs> | null
  }



  /**
   * Model images
   */

  export type AggregateImages = {
    _count: ImagesCountAggregateOutputType | null
    _avg: ImagesAvgAggregateOutputType | null
    _sum: ImagesSumAggregateOutputType | null
    _min: ImagesMinAggregateOutputType | null
    _max: ImagesMaxAggregateOutputType | null
  }

  export type ImagesAvgAggregateOutputType = {
    image_likes: number | null
    image_dislikes: number | null
    image_views: number | null
  }

  export type ImagesSumAggregateOutputType = {
    image_likes: number | null
    image_dislikes: number | null
    image_views: number | null
  }

  export type ImagesMinAggregateOutputType = {
    image_id: string | null
    image_creator_id: string | null
    image_title: string | null
    image_description: string | null
    image_filename: string | null
    image_data_id: string | null
    image_likes: number | null
    image_dislikes: number | null
    image_views: number | null
    image_date_posted: Date | null
  }

  export type ImagesMaxAggregateOutputType = {
    image_id: string | null
    image_creator_id: string | null
    image_title: string | null
    image_description: string | null
    image_filename: string | null
    image_data_id: string | null
    image_likes: number | null
    image_dislikes: number | null
    image_views: number | null
    image_date_posted: Date | null
  }

  export type ImagesCountAggregateOutputType = {
    image_id: number
    image_creator_id: number
    image_title: number
    image_description: number
    image_filename: number
    image_data_id: number
    image_likes: number
    image_dislikes: number
    image_views: number
    image_date_posted: number
    _all: number
  }


  export type ImagesAvgAggregateInputType = {
    image_likes?: true
    image_dislikes?: true
    image_views?: true
  }

  export type ImagesSumAggregateInputType = {
    image_likes?: true
    image_dislikes?: true
    image_views?: true
  }

  export type ImagesMinAggregateInputType = {
    image_id?: true
    image_creator_id?: true
    image_title?: true
    image_description?: true
    image_filename?: true
    image_data_id?: true
    image_likes?: true
    image_dislikes?: true
    image_views?: true
    image_date_posted?: true
  }

  export type ImagesMaxAggregateInputType = {
    image_id?: true
    image_creator_id?: true
    image_title?: true
    image_description?: true
    image_filename?: true
    image_data_id?: true
    image_likes?: true
    image_dislikes?: true
    image_views?: true
    image_date_posted?: true
  }

  export type ImagesCountAggregateInputType = {
    image_id?: true
    image_creator_id?: true
    image_title?: true
    image_description?: true
    image_filename?: true
    image_data_id?: true
    image_likes?: true
    image_dislikes?: true
    image_views?: true
    image_date_posted?: true
    _all?: true
  }

  export type ImagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which images to aggregate.
     */
    where?: imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of images to fetch.
     */
    orderBy?: imagesOrderByWithRelationInput | imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned images
    **/
    _count?: true | ImagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImagesMaxAggregateInputType
  }

  export type GetImagesAggregateType<T extends ImagesAggregateArgs> = {
        [P in keyof T & keyof AggregateImages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImages[P]>
      : GetScalarType<T[P], AggregateImages[P]>
  }




  export type imagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: imagesWhereInput
    orderBy?: imagesOrderByWithAggregationInput | imagesOrderByWithAggregationInput[]
    by: ImagesScalarFieldEnum[] | ImagesScalarFieldEnum
    having?: imagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImagesCountAggregateInputType | true
    _avg?: ImagesAvgAggregateInputType
    _sum?: ImagesSumAggregateInputType
    _min?: ImagesMinAggregateInputType
    _max?: ImagesMaxAggregateInputType
  }

  export type ImagesGroupByOutputType = {
    image_id: string
    image_creator_id: string
    image_title: string
    image_description: string
    image_filename: string
    image_data_id: string
    image_likes: number
    image_dislikes: number
    image_views: number
    image_date_posted: Date
    _count: ImagesCountAggregateOutputType | null
    _avg: ImagesAvgAggregateOutputType | null
    _sum: ImagesSumAggregateOutputType | null
    _min: ImagesMinAggregateOutputType | null
    _max: ImagesMaxAggregateOutputType | null
  }

  type GetImagesGroupByPayload<T extends imagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImagesGroupByOutputType[P]>
            : GetScalarType<T[P], ImagesGroupByOutputType[P]>
        }
      >
    >


  export type imagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    image_id?: boolean
    image_creator_id?: boolean
    image_title?: boolean
    image_description?: boolean
    image_filename?: boolean
    image_data_id?: boolean
    image_likes?: boolean
    image_dislikes?: boolean
    image_views?: boolean
    image_date_posted?: boolean
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
    images_data?: boolean | images_dataDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["images"]>

  export type imagesSelectScalar = {
    image_id?: boolean
    image_creator_id?: boolean
    image_title?: boolean
    image_description?: boolean
    image_filename?: boolean
    image_data_id?: boolean
    image_likes?: boolean
    image_dislikes?: boolean
    image_views?: boolean
    image_date_posted?: boolean
  }

  export type imagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
    images_data?: boolean | images_dataDefaultArgs<ExtArgs>
  }


  export type $imagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "images"
    objects: {
      entities: Prisma.$entitiesPayload<ExtArgs>
      images_data: Prisma.$images_dataPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      image_id: string
      image_creator_id: string
      image_title: string
      image_description: string
      image_filename: string
      image_data_id: string
      image_likes: number
      image_dislikes: number
      image_views: number
      image_date_posted: Date
    }, ExtArgs["result"]["images"]>
    composites: {}
  }


  type imagesGetPayload<S extends boolean | null | undefined | imagesDefaultArgs> = $Result.GetResult<Prisma.$imagesPayload, S>

  type imagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<imagesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ImagesCountAggregateInputType | true
    }

  export interface imagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['images'], meta: { name: 'images' } }
    /**
     * Find zero or one Images that matches the filter.
     * @param {imagesFindUniqueArgs} args - Arguments to find a Images
     * @example
     * // Get one Images
     * const images = await prisma.images.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends imagesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, imagesFindUniqueArgs<ExtArgs>>
    ): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Images that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {imagesFindUniqueOrThrowArgs} args - Arguments to find a Images
     * @example
     * // Get one Images
     * const images = await prisma.images.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends imagesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, imagesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesFindFirstArgs} args - Arguments to find a Images
     * @example
     * // Get one Images
     * const images = await prisma.images.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends imagesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, imagesFindFirstArgs<ExtArgs>>
    ): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Images that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesFindFirstOrThrowArgs} args - Arguments to find a Images
     * @example
     * // Get one Images
     * const images = await prisma.images.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends imagesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, imagesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.images.findMany()
     * 
     * // Get first 10 Images
     * const images = await prisma.images.findMany({ take: 10 })
     * 
     * // Only select the `image_id`
     * const imagesWithImage_idOnly = await prisma.images.findMany({ select: { image_id: true } })
     * 
    **/
    findMany<T extends imagesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, imagesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Images.
     * @param {imagesCreateArgs} args - Arguments to create a Images.
     * @example
     * // Create one Images
     * const Images = await prisma.images.create({
     *   data: {
     *     // ... data to create a Images
     *   }
     * })
     * 
    **/
    create<T extends imagesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, imagesCreateArgs<ExtArgs>>
    ): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Images.
     *     @param {imagesCreateManyArgs} args - Arguments to create many Images.
     *     @example
     *     // Create many Images
     *     const images = await prisma.images.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends imagesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, imagesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Images.
     * @param {imagesDeleteArgs} args - Arguments to delete one Images.
     * @example
     * // Delete one Images
     * const Images = await prisma.images.delete({
     *   where: {
     *     // ... filter to delete one Images
     *   }
     * })
     * 
    **/
    delete<T extends imagesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, imagesDeleteArgs<ExtArgs>>
    ): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Images.
     * @param {imagesUpdateArgs} args - Arguments to update one Images.
     * @example
     * // Update one Images
     * const images = await prisma.images.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends imagesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, imagesUpdateArgs<ExtArgs>>
    ): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Images.
     * @param {imagesDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.images.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends imagesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, imagesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const images = await prisma.images.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends imagesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, imagesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Images.
     * @param {imagesUpsertArgs} args - Arguments to update or create a Images.
     * @example
     * // Update or create a Images
     * const images = await prisma.images.upsert({
     *   create: {
     *     // ... data to create a Images
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Images we want to update
     *   }
     * })
    **/
    upsert<T extends imagesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, imagesUpsertArgs<ExtArgs>>
    ): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.images.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
    **/
    count<T extends imagesCountArgs>(
      args?: Subset<T, imagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImagesAggregateArgs>(args: Subset<T, ImagesAggregateArgs>): Prisma.PrismaPromise<GetImagesAggregateType<T>>

    /**
     * Group by Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends imagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: imagesGroupByArgs['orderBy'] }
        : { orderBy?: imagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, imagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the images model
   */
  readonly fields: imagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for images.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__imagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    entities<T extends entitiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, entitiesDefaultArgs<ExtArgs>>): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    images_data<T extends images_dataDefaultArgs<ExtArgs> = {}>(args?: Subset<T, images_dataDefaultArgs<ExtArgs>>): Prisma__images_dataClient<$Result.GetResult<Prisma.$images_dataPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the images model
   */ 
  interface imagesFieldRefs {
    readonly image_id: FieldRef<"images", 'String'>
    readonly image_creator_id: FieldRef<"images", 'String'>
    readonly image_title: FieldRef<"images", 'String'>
    readonly image_description: FieldRef<"images", 'String'>
    readonly image_filename: FieldRef<"images", 'String'>
    readonly image_data_id: FieldRef<"images", 'String'>
    readonly image_likes: FieldRef<"images", 'Int'>
    readonly image_dislikes: FieldRef<"images", 'Int'>
    readonly image_views: FieldRef<"images", 'Int'>
    readonly image_date_posted: FieldRef<"images", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * images findUnique
   */
  export type imagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * Filter, which images to fetch.
     */
    where: imagesWhereUniqueInput
  }


  /**
   * images findUniqueOrThrow
   */
  export type imagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * Filter, which images to fetch.
     */
    where: imagesWhereUniqueInput
  }


  /**
   * images findFirst
   */
  export type imagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * Filter, which images to fetch.
     */
    where?: imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of images to fetch.
     */
    orderBy?: imagesOrderByWithRelationInput | imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for images.
     */
    cursor?: imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of images.
     */
    distinct?: ImagesScalarFieldEnum | ImagesScalarFieldEnum[]
  }


  /**
   * images findFirstOrThrow
   */
  export type imagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * Filter, which images to fetch.
     */
    where?: imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of images to fetch.
     */
    orderBy?: imagesOrderByWithRelationInput | imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for images.
     */
    cursor?: imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of images.
     */
    distinct?: ImagesScalarFieldEnum | ImagesScalarFieldEnum[]
  }


  /**
   * images findMany
   */
  export type imagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * Filter, which images to fetch.
     */
    where?: imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of images to fetch.
     */
    orderBy?: imagesOrderByWithRelationInput | imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing images.
     */
    cursor?: imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` images.
     */
    skip?: number
    distinct?: ImagesScalarFieldEnum | ImagesScalarFieldEnum[]
  }


  /**
   * images create
   */
  export type imagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * The data needed to create a images.
     */
    data: XOR<imagesCreateInput, imagesUncheckedCreateInput>
  }


  /**
   * images createMany
   */
  export type imagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many images.
     */
    data: imagesCreateManyInput | imagesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * images update
   */
  export type imagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * The data needed to update a images.
     */
    data: XOR<imagesUpdateInput, imagesUncheckedUpdateInput>
    /**
     * Choose, which images to update.
     */
    where: imagesWhereUniqueInput
  }


  /**
   * images updateMany
   */
  export type imagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update images.
     */
    data: XOR<imagesUpdateManyMutationInput, imagesUncheckedUpdateManyInput>
    /**
     * Filter which images to update
     */
    where?: imagesWhereInput
  }


  /**
   * images upsert
   */
  export type imagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * The filter to search for the images to update in case it exists.
     */
    where: imagesWhereUniqueInput
    /**
     * In case the images found by the `where` argument doesn't exist, create a new images with this data.
     */
    create: XOR<imagesCreateInput, imagesUncheckedCreateInput>
    /**
     * In case the images was found with the provided `where` argument, update it with this data.
     */
    update: XOR<imagesUpdateInput, imagesUncheckedUpdateInput>
  }


  /**
   * images delete
   */
  export type imagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * Filter which images to delete.
     */
    where: imagesWhereUniqueInput
  }


  /**
   * images deleteMany
   */
  export type imagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which images to delete
     */
    where?: imagesWhereInput
  }


  /**
   * images without action
   */
  export type imagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagesInclude<ExtArgs> | null
  }



  /**
   * Model images_data
   */

  export type AggregateImages_data = {
    _count: Images_dataCountAggregateOutputType | null
    _min: Images_dataMinAggregateOutputType | null
    _max: Images_dataMaxAggregateOutputType | null
  }

  export type Images_dataMinAggregateOutputType = {
    image_data_id: string | null
    image_data: Buffer | null
  }

  export type Images_dataMaxAggregateOutputType = {
    image_data_id: string | null
    image_data: Buffer | null
  }

  export type Images_dataCountAggregateOutputType = {
    image_data_id: number
    image_data: number
    _all: number
  }


  export type Images_dataMinAggregateInputType = {
    image_data_id?: true
    image_data?: true
  }

  export type Images_dataMaxAggregateInputType = {
    image_data_id?: true
    image_data?: true
  }

  export type Images_dataCountAggregateInputType = {
    image_data_id?: true
    image_data?: true
    _all?: true
  }

  export type Images_dataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which images_data to aggregate.
     */
    where?: images_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of images_data to fetch.
     */
    orderBy?: images_dataOrderByWithRelationInput | images_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: images_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` images_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` images_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned images_data
    **/
    _count?: true | Images_dataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Images_dataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Images_dataMaxAggregateInputType
  }

  export type GetImages_dataAggregateType<T extends Images_dataAggregateArgs> = {
        [P in keyof T & keyof AggregateImages_data]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImages_data[P]>
      : GetScalarType<T[P], AggregateImages_data[P]>
  }




  export type images_dataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: images_dataWhereInput
    orderBy?: images_dataOrderByWithAggregationInput | images_dataOrderByWithAggregationInput[]
    by: Images_dataScalarFieldEnum[] | Images_dataScalarFieldEnum
    having?: images_dataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Images_dataCountAggregateInputType | true
    _min?: Images_dataMinAggregateInputType
    _max?: Images_dataMaxAggregateInputType
  }

  export type Images_dataGroupByOutputType = {
    image_data_id: string
    image_data: Buffer
    _count: Images_dataCountAggregateOutputType | null
    _min: Images_dataMinAggregateOutputType | null
    _max: Images_dataMaxAggregateOutputType | null
  }

  type GetImages_dataGroupByPayload<T extends images_dataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Images_dataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Images_dataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Images_dataGroupByOutputType[P]>
            : GetScalarType<T[P], Images_dataGroupByOutputType[P]>
        }
      >
    >


  export type images_dataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    image_data_id?: boolean
    image_data?: boolean
    images?: boolean | images_data$imagesArgs<ExtArgs>
    _count?: boolean | Images_dataCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["images_data"]>

  export type images_dataSelectScalar = {
    image_data_id?: boolean
    image_data?: boolean
  }

  export type images_dataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | images_data$imagesArgs<ExtArgs>
    _count?: boolean | Images_dataCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $images_dataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "images_data"
    objects: {
      images: Prisma.$imagesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      image_data_id: string
      image_data: Buffer
    }, ExtArgs["result"]["images_data"]>
    composites: {}
  }


  type images_dataGetPayload<S extends boolean | null | undefined | images_dataDefaultArgs> = $Result.GetResult<Prisma.$images_dataPayload, S>

  type images_dataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<images_dataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Images_dataCountAggregateInputType | true
    }

  export interface images_dataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['images_data'], meta: { name: 'images_data' } }
    /**
     * Find zero or one Images_data that matches the filter.
     * @param {images_dataFindUniqueArgs} args - Arguments to find a Images_data
     * @example
     * // Get one Images_data
     * const images_data = await prisma.images_data.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends images_dataFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, images_dataFindUniqueArgs<ExtArgs>>
    ): Prisma__images_dataClient<$Result.GetResult<Prisma.$images_dataPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Images_data that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {images_dataFindUniqueOrThrowArgs} args - Arguments to find a Images_data
     * @example
     * // Get one Images_data
     * const images_data = await prisma.images_data.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends images_dataFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, images_dataFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__images_dataClient<$Result.GetResult<Prisma.$images_dataPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Images_data that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {images_dataFindFirstArgs} args - Arguments to find a Images_data
     * @example
     * // Get one Images_data
     * const images_data = await prisma.images_data.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends images_dataFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, images_dataFindFirstArgs<ExtArgs>>
    ): Prisma__images_dataClient<$Result.GetResult<Prisma.$images_dataPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Images_data that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {images_dataFindFirstOrThrowArgs} args - Arguments to find a Images_data
     * @example
     * // Get one Images_data
     * const images_data = await prisma.images_data.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends images_dataFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, images_dataFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__images_dataClient<$Result.GetResult<Prisma.$images_dataPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Images_data that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {images_dataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images_data
     * const images_data = await prisma.images_data.findMany()
     * 
     * // Get first 10 Images_data
     * const images_data = await prisma.images_data.findMany({ take: 10 })
     * 
     * // Only select the `image_data_id`
     * const images_dataWithImage_data_idOnly = await prisma.images_data.findMany({ select: { image_data_id: true } })
     * 
    **/
    findMany<T extends images_dataFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, images_dataFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$images_dataPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Images_data.
     * @param {images_dataCreateArgs} args - Arguments to create a Images_data.
     * @example
     * // Create one Images_data
     * const Images_data = await prisma.images_data.create({
     *   data: {
     *     // ... data to create a Images_data
     *   }
     * })
     * 
    **/
    create<T extends images_dataCreateArgs<ExtArgs>>(
      args: SelectSubset<T, images_dataCreateArgs<ExtArgs>>
    ): Prisma__images_dataClient<$Result.GetResult<Prisma.$images_dataPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Images_data.
     *     @param {images_dataCreateManyArgs} args - Arguments to create many Images_data.
     *     @example
     *     // Create many Images_data
     *     const images_data = await prisma.images_data.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends images_dataCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, images_dataCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Images_data.
     * @param {images_dataDeleteArgs} args - Arguments to delete one Images_data.
     * @example
     * // Delete one Images_data
     * const Images_data = await prisma.images_data.delete({
     *   where: {
     *     // ... filter to delete one Images_data
     *   }
     * })
     * 
    **/
    delete<T extends images_dataDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, images_dataDeleteArgs<ExtArgs>>
    ): Prisma__images_dataClient<$Result.GetResult<Prisma.$images_dataPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Images_data.
     * @param {images_dataUpdateArgs} args - Arguments to update one Images_data.
     * @example
     * // Update one Images_data
     * const images_data = await prisma.images_data.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends images_dataUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, images_dataUpdateArgs<ExtArgs>>
    ): Prisma__images_dataClient<$Result.GetResult<Prisma.$images_dataPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Images_data.
     * @param {images_dataDeleteManyArgs} args - Arguments to filter Images_data to delete.
     * @example
     * // Delete a few Images_data
     * const { count } = await prisma.images_data.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends images_dataDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, images_dataDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {images_dataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images_data
     * const images_data = await prisma.images_data.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends images_dataUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, images_dataUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Images_data.
     * @param {images_dataUpsertArgs} args - Arguments to update or create a Images_data.
     * @example
     * // Update or create a Images_data
     * const images_data = await prisma.images_data.upsert({
     *   create: {
     *     // ... data to create a Images_data
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Images_data we want to update
     *   }
     * })
    **/
    upsert<T extends images_dataUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, images_dataUpsertArgs<ExtArgs>>
    ): Prisma__images_dataClient<$Result.GetResult<Prisma.$images_dataPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Images_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {images_dataCountArgs} args - Arguments to filter Images_data to count.
     * @example
     * // Count the number of Images_data
     * const count = await prisma.images_data.count({
     *   where: {
     *     // ... the filter for the Images_data we want to count
     *   }
     * })
    **/
    count<T extends images_dataCountArgs>(
      args?: Subset<T, images_dataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Images_dataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Images_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Images_dataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Images_dataAggregateArgs>(args: Subset<T, Images_dataAggregateArgs>): Prisma.PrismaPromise<GetImages_dataAggregateType<T>>

    /**
     * Group by Images_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {images_dataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends images_dataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: images_dataGroupByArgs['orderBy'] }
        : { orderBy?: images_dataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, images_dataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImages_dataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the images_data model
   */
  readonly fields: images_dataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for images_data.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__images_dataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    images<T extends images_data$imagesArgs<ExtArgs> = {}>(args?: Subset<T, images_data$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the images_data model
   */ 
  interface images_dataFieldRefs {
    readonly image_data_id: FieldRef<"images_data", 'String'>
    readonly image_data: FieldRef<"images_data", 'Bytes'>
  }
    

  // Custom InputTypes

  /**
   * images_data findUnique
   */
  export type images_dataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images_data
     */
    select?: images_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: images_dataInclude<ExtArgs> | null
    /**
     * Filter, which images_data to fetch.
     */
    where: images_dataWhereUniqueInput
  }


  /**
   * images_data findUniqueOrThrow
   */
  export type images_dataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images_data
     */
    select?: images_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: images_dataInclude<ExtArgs> | null
    /**
     * Filter, which images_data to fetch.
     */
    where: images_dataWhereUniqueInput
  }


  /**
   * images_data findFirst
   */
  export type images_dataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images_data
     */
    select?: images_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: images_dataInclude<ExtArgs> | null
    /**
     * Filter, which images_data to fetch.
     */
    where?: images_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of images_data to fetch.
     */
    orderBy?: images_dataOrderByWithRelationInput | images_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for images_data.
     */
    cursor?: images_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` images_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` images_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of images_data.
     */
    distinct?: Images_dataScalarFieldEnum | Images_dataScalarFieldEnum[]
  }


  /**
   * images_data findFirstOrThrow
   */
  export type images_dataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images_data
     */
    select?: images_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: images_dataInclude<ExtArgs> | null
    /**
     * Filter, which images_data to fetch.
     */
    where?: images_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of images_data to fetch.
     */
    orderBy?: images_dataOrderByWithRelationInput | images_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for images_data.
     */
    cursor?: images_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` images_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` images_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of images_data.
     */
    distinct?: Images_dataScalarFieldEnum | Images_dataScalarFieldEnum[]
  }


  /**
   * images_data findMany
   */
  export type images_dataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images_data
     */
    select?: images_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: images_dataInclude<ExtArgs> | null
    /**
     * Filter, which images_data to fetch.
     */
    where?: images_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of images_data to fetch.
     */
    orderBy?: images_dataOrderByWithRelationInput | images_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing images_data.
     */
    cursor?: images_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` images_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` images_data.
     */
    skip?: number
    distinct?: Images_dataScalarFieldEnum | Images_dataScalarFieldEnum[]
  }


  /**
   * images_data create
   */
  export type images_dataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images_data
     */
    select?: images_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: images_dataInclude<ExtArgs> | null
    /**
     * The data needed to create a images_data.
     */
    data: XOR<images_dataCreateInput, images_dataUncheckedCreateInput>
  }


  /**
   * images_data createMany
   */
  export type images_dataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many images_data.
     */
    data: images_dataCreateManyInput | images_dataCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * images_data update
   */
  export type images_dataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images_data
     */
    select?: images_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: images_dataInclude<ExtArgs> | null
    /**
     * The data needed to update a images_data.
     */
    data: XOR<images_dataUpdateInput, images_dataUncheckedUpdateInput>
    /**
     * Choose, which images_data to update.
     */
    where: images_dataWhereUniqueInput
  }


  /**
   * images_data updateMany
   */
  export type images_dataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update images_data.
     */
    data: XOR<images_dataUpdateManyMutationInput, images_dataUncheckedUpdateManyInput>
    /**
     * Filter which images_data to update
     */
    where?: images_dataWhereInput
  }


  /**
   * images_data upsert
   */
  export type images_dataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images_data
     */
    select?: images_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: images_dataInclude<ExtArgs> | null
    /**
     * The filter to search for the images_data to update in case it exists.
     */
    where: images_dataWhereUniqueInput
    /**
     * In case the images_data found by the `where` argument doesn't exist, create a new images_data with this data.
     */
    create: XOR<images_dataCreateInput, images_dataUncheckedCreateInput>
    /**
     * In case the images_data was found with the provided `where` argument, update it with this data.
     */
    update: XOR<images_dataUpdateInput, images_dataUncheckedUpdateInput>
  }


  /**
   * images_data delete
   */
  export type images_dataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images_data
     */
    select?: images_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: images_dataInclude<ExtArgs> | null
    /**
     * Filter which images_data to delete.
     */
    where: images_dataWhereUniqueInput
  }


  /**
   * images_data deleteMany
   */
  export type images_dataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which images_data to delete
     */
    where?: images_dataWhereInput
  }


  /**
   * images_data.images
   */
  export type images_data$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagesInclude<ExtArgs> | null
    where?: imagesWhereInput
    orderBy?: imagesOrderByWithRelationInput | imagesOrderByWithRelationInput[]
    cursor?: imagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImagesScalarFieldEnum | ImagesScalarFieldEnum[]
  }


  /**
   * images_data without action
   */
  export type images_dataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images_data
     */
    select?: images_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: images_dataInclude<ExtArgs> | null
  }



  /**
   * Model individuals
   */

  export type AggregateIndividuals = {
    _count: IndividualsCountAggregateOutputType | null
    _min: IndividualsMinAggregateOutputType | null
    _max: IndividualsMaxAggregateOutputType | null
  }

  export type IndividualsMinAggregateOutputType = {
    individual_id: string | null
    individual_username: string | null
    individual_name: string | null
    individual_current_issue: string | null
    individual_roles: string | null
    individual_description: string | null
    profile_picture_id: string | null
  }

  export type IndividualsMaxAggregateOutputType = {
    individual_id: string | null
    individual_username: string | null
    individual_name: string | null
    individual_current_issue: string | null
    individual_roles: string | null
    individual_description: string | null
    profile_picture_id: string | null
  }

  export type IndividualsCountAggregateOutputType = {
    individual_id: number
    individual_username: number
    individual_name: number
    individual_current_issue: number
    individual_roles: number
    individual_description: number
    profile_picture_id: number
    _all: number
  }


  export type IndividualsMinAggregateInputType = {
    individual_id?: true
    individual_username?: true
    individual_name?: true
    individual_current_issue?: true
    individual_roles?: true
    individual_description?: true
    profile_picture_id?: true
  }

  export type IndividualsMaxAggregateInputType = {
    individual_id?: true
    individual_username?: true
    individual_name?: true
    individual_current_issue?: true
    individual_roles?: true
    individual_description?: true
    profile_picture_id?: true
  }

  export type IndividualsCountAggregateInputType = {
    individual_id?: true
    individual_username?: true
    individual_name?: true
    individual_current_issue?: true
    individual_roles?: true
    individual_description?: true
    profile_picture_id?: true
    _all?: true
  }

  export type IndividualsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which individuals to aggregate.
     */
    where?: individualsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of individuals to fetch.
     */
    orderBy?: individualsOrderByWithRelationInput | individualsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: individualsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` individuals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` individuals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned individuals
    **/
    _count?: true | IndividualsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndividualsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndividualsMaxAggregateInputType
  }

  export type GetIndividualsAggregateType<T extends IndividualsAggregateArgs> = {
        [P in keyof T & keyof AggregateIndividuals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndividuals[P]>
      : GetScalarType<T[P], AggregateIndividuals[P]>
  }




  export type individualsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: individualsWhereInput
    orderBy?: individualsOrderByWithAggregationInput | individualsOrderByWithAggregationInput[]
    by: IndividualsScalarFieldEnum[] | IndividualsScalarFieldEnum
    having?: individualsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndividualsCountAggregateInputType | true
    _min?: IndividualsMinAggregateInputType
    _max?: IndividualsMaxAggregateInputType
  }

  export type IndividualsGroupByOutputType = {
    individual_id: string
    individual_username: string
    individual_name: string | null
    individual_current_issue: string | null
    individual_roles: string | null
    individual_description: string | null
    profile_picture_id: string | null
    _count: IndividualsCountAggregateOutputType | null
    _min: IndividualsMinAggregateOutputType | null
    _max: IndividualsMaxAggregateOutputType | null
  }

  type GetIndividualsGroupByPayload<T extends individualsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndividualsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndividualsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndividualsGroupByOutputType[P]>
            : GetScalarType<T[P], IndividualsGroupByOutputType[P]>
        }
      >
    >


  export type individualsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    individual_id?: boolean
    individual_username?: boolean
    individual_name?: boolean
    individual_current_issue?: boolean
    individual_roles?: boolean
    individual_description?: boolean
    profile_picture_id?: boolean
    user_credentials?: boolean | user_credentialsDefaultArgs<ExtArgs>
    profile_pictures?: boolean | individuals$profile_picturesArgs<ExtArgs>
  }, ExtArgs["result"]["individuals"]>

  export type individualsSelectScalar = {
    individual_id?: boolean
    individual_username?: boolean
    individual_name?: boolean
    individual_current_issue?: boolean
    individual_roles?: boolean
    individual_description?: boolean
    profile_picture_id?: boolean
  }

  export type individualsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_credentials?: boolean | user_credentialsDefaultArgs<ExtArgs>
    profile_pictures?: boolean | individuals$profile_picturesArgs<ExtArgs>
  }


  export type $individualsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "individuals"
    objects: {
      user_credentials: Prisma.$user_credentialsPayload<ExtArgs>
      profile_pictures: Prisma.$profile_picturesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      individual_id: string
      individual_username: string
      individual_name: string | null
      individual_current_issue: string | null
      individual_roles: string | null
      individual_description: string | null
      profile_picture_id: string | null
    }, ExtArgs["result"]["individuals"]>
    composites: {}
  }


  type individualsGetPayload<S extends boolean | null | undefined | individualsDefaultArgs> = $Result.GetResult<Prisma.$individualsPayload, S>

  type individualsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<individualsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IndividualsCountAggregateInputType | true
    }

  export interface individualsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['individuals'], meta: { name: 'individuals' } }
    /**
     * Find zero or one Individuals that matches the filter.
     * @param {individualsFindUniqueArgs} args - Arguments to find a Individuals
     * @example
     * // Get one Individuals
     * const individuals = await prisma.individuals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends individualsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, individualsFindUniqueArgs<ExtArgs>>
    ): Prisma__individualsClient<$Result.GetResult<Prisma.$individualsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Individuals that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {individualsFindUniqueOrThrowArgs} args - Arguments to find a Individuals
     * @example
     * // Get one Individuals
     * const individuals = await prisma.individuals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends individualsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, individualsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__individualsClient<$Result.GetResult<Prisma.$individualsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Individuals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {individualsFindFirstArgs} args - Arguments to find a Individuals
     * @example
     * // Get one Individuals
     * const individuals = await prisma.individuals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends individualsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, individualsFindFirstArgs<ExtArgs>>
    ): Prisma__individualsClient<$Result.GetResult<Prisma.$individualsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Individuals that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {individualsFindFirstOrThrowArgs} args - Arguments to find a Individuals
     * @example
     * // Get one Individuals
     * const individuals = await prisma.individuals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends individualsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, individualsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__individualsClient<$Result.GetResult<Prisma.$individualsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Individuals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {individualsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Individuals
     * const individuals = await prisma.individuals.findMany()
     * 
     * // Get first 10 Individuals
     * const individuals = await prisma.individuals.findMany({ take: 10 })
     * 
     * // Only select the `individual_id`
     * const individualsWithIndividual_idOnly = await prisma.individuals.findMany({ select: { individual_id: true } })
     * 
    **/
    findMany<T extends individualsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, individualsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$individualsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Individuals.
     * @param {individualsCreateArgs} args - Arguments to create a Individuals.
     * @example
     * // Create one Individuals
     * const Individuals = await prisma.individuals.create({
     *   data: {
     *     // ... data to create a Individuals
     *   }
     * })
     * 
    **/
    create<T extends individualsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, individualsCreateArgs<ExtArgs>>
    ): Prisma__individualsClient<$Result.GetResult<Prisma.$individualsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Individuals.
     *     @param {individualsCreateManyArgs} args - Arguments to create many Individuals.
     *     @example
     *     // Create many Individuals
     *     const individuals = await prisma.individuals.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends individualsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, individualsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Individuals.
     * @param {individualsDeleteArgs} args - Arguments to delete one Individuals.
     * @example
     * // Delete one Individuals
     * const Individuals = await prisma.individuals.delete({
     *   where: {
     *     // ... filter to delete one Individuals
     *   }
     * })
     * 
    **/
    delete<T extends individualsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, individualsDeleteArgs<ExtArgs>>
    ): Prisma__individualsClient<$Result.GetResult<Prisma.$individualsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Individuals.
     * @param {individualsUpdateArgs} args - Arguments to update one Individuals.
     * @example
     * // Update one Individuals
     * const individuals = await prisma.individuals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends individualsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, individualsUpdateArgs<ExtArgs>>
    ): Prisma__individualsClient<$Result.GetResult<Prisma.$individualsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Individuals.
     * @param {individualsDeleteManyArgs} args - Arguments to filter Individuals to delete.
     * @example
     * // Delete a few Individuals
     * const { count } = await prisma.individuals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends individualsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, individualsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Individuals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {individualsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Individuals
     * const individuals = await prisma.individuals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends individualsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, individualsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Individuals.
     * @param {individualsUpsertArgs} args - Arguments to update or create a Individuals.
     * @example
     * // Update or create a Individuals
     * const individuals = await prisma.individuals.upsert({
     *   create: {
     *     // ... data to create a Individuals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Individuals we want to update
     *   }
     * })
    **/
    upsert<T extends individualsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, individualsUpsertArgs<ExtArgs>>
    ): Prisma__individualsClient<$Result.GetResult<Prisma.$individualsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Individuals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {individualsCountArgs} args - Arguments to filter Individuals to count.
     * @example
     * // Count the number of Individuals
     * const count = await prisma.individuals.count({
     *   where: {
     *     // ... the filter for the Individuals we want to count
     *   }
     * })
    **/
    count<T extends individualsCountArgs>(
      args?: Subset<T, individualsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndividualsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Individuals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndividualsAggregateArgs>(args: Subset<T, IndividualsAggregateArgs>): Prisma.PrismaPromise<GetIndividualsAggregateType<T>>

    /**
     * Group by Individuals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {individualsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends individualsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: individualsGroupByArgs['orderBy'] }
        : { orderBy?: individualsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, individualsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndividualsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the individuals model
   */
  readonly fields: individualsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for individuals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__individualsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user_credentials<T extends user_credentialsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, user_credentialsDefaultArgs<ExtArgs>>): Prisma__user_credentialsClient<$Result.GetResult<Prisma.$user_credentialsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    profile_pictures<T extends individuals$profile_picturesArgs<ExtArgs> = {}>(args?: Subset<T, individuals$profile_picturesArgs<ExtArgs>>): Prisma__profile_picturesClient<$Result.GetResult<Prisma.$profile_picturesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the individuals model
   */ 
  interface individualsFieldRefs {
    readonly individual_id: FieldRef<"individuals", 'String'>
    readonly individual_username: FieldRef<"individuals", 'String'>
    readonly individual_name: FieldRef<"individuals", 'String'>
    readonly individual_current_issue: FieldRef<"individuals", 'String'>
    readonly individual_roles: FieldRef<"individuals", 'String'>
    readonly individual_description: FieldRef<"individuals", 'String'>
    readonly profile_picture_id: FieldRef<"individuals", 'String'>
  }
    

  // Custom InputTypes

  /**
   * individuals findUnique
   */
  export type individualsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the individuals
     */
    select?: individualsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: individualsInclude<ExtArgs> | null
    /**
     * Filter, which individuals to fetch.
     */
    where: individualsWhereUniqueInput
  }


  /**
   * individuals findUniqueOrThrow
   */
  export type individualsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the individuals
     */
    select?: individualsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: individualsInclude<ExtArgs> | null
    /**
     * Filter, which individuals to fetch.
     */
    where: individualsWhereUniqueInput
  }


  /**
   * individuals findFirst
   */
  export type individualsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the individuals
     */
    select?: individualsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: individualsInclude<ExtArgs> | null
    /**
     * Filter, which individuals to fetch.
     */
    where?: individualsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of individuals to fetch.
     */
    orderBy?: individualsOrderByWithRelationInput | individualsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for individuals.
     */
    cursor?: individualsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` individuals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` individuals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of individuals.
     */
    distinct?: IndividualsScalarFieldEnum | IndividualsScalarFieldEnum[]
  }


  /**
   * individuals findFirstOrThrow
   */
  export type individualsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the individuals
     */
    select?: individualsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: individualsInclude<ExtArgs> | null
    /**
     * Filter, which individuals to fetch.
     */
    where?: individualsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of individuals to fetch.
     */
    orderBy?: individualsOrderByWithRelationInput | individualsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for individuals.
     */
    cursor?: individualsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` individuals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` individuals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of individuals.
     */
    distinct?: IndividualsScalarFieldEnum | IndividualsScalarFieldEnum[]
  }


  /**
   * individuals findMany
   */
  export type individualsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the individuals
     */
    select?: individualsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: individualsInclude<ExtArgs> | null
    /**
     * Filter, which individuals to fetch.
     */
    where?: individualsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of individuals to fetch.
     */
    orderBy?: individualsOrderByWithRelationInput | individualsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing individuals.
     */
    cursor?: individualsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` individuals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` individuals.
     */
    skip?: number
    distinct?: IndividualsScalarFieldEnum | IndividualsScalarFieldEnum[]
  }


  /**
   * individuals create
   */
  export type individualsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the individuals
     */
    select?: individualsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: individualsInclude<ExtArgs> | null
    /**
     * The data needed to create a individuals.
     */
    data: XOR<individualsCreateInput, individualsUncheckedCreateInput>
  }


  /**
   * individuals createMany
   */
  export type individualsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many individuals.
     */
    data: individualsCreateManyInput | individualsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * individuals update
   */
  export type individualsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the individuals
     */
    select?: individualsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: individualsInclude<ExtArgs> | null
    /**
     * The data needed to update a individuals.
     */
    data: XOR<individualsUpdateInput, individualsUncheckedUpdateInput>
    /**
     * Choose, which individuals to update.
     */
    where: individualsWhereUniqueInput
  }


  /**
   * individuals updateMany
   */
  export type individualsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update individuals.
     */
    data: XOR<individualsUpdateManyMutationInput, individualsUncheckedUpdateManyInput>
    /**
     * Filter which individuals to update
     */
    where?: individualsWhereInput
  }


  /**
   * individuals upsert
   */
  export type individualsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the individuals
     */
    select?: individualsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: individualsInclude<ExtArgs> | null
    /**
     * The filter to search for the individuals to update in case it exists.
     */
    where: individualsWhereUniqueInput
    /**
     * In case the individuals found by the `where` argument doesn't exist, create a new individuals with this data.
     */
    create: XOR<individualsCreateInput, individualsUncheckedCreateInput>
    /**
     * In case the individuals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<individualsUpdateInput, individualsUncheckedUpdateInput>
  }


  /**
   * individuals delete
   */
  export type individualsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the individuals
     */
    select?: individualsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: individualsInclude<ExtArgs> | null
    /**
     * Filter which individuals to delete.
     */
    where: individualsWhereUniqueInput
  }


  /**
   * individuals deleteMany
   */
  export type individualsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which individuals to delete
     */
    where?: individualsWhereInput
  }


  /**
   * individuals.profile_pictures
   */
  export type individuals$profile_picturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile_pictures
     */
    select?: profile_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profile_picturesInclude<ExtArgs> | null
    where?: profile_picturesWhereInput
  }


  /**
   * individuals without action
   */
  export type individualsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the individuals
     */
    select?: individualsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: individualsInclude<ExtArgs> | null
  }



  /**
   * Model organizations
   */

  export type AggregateOrganizations = {
    _count: OrganizationsCountAggregateOutputType | null
    _min: OrganizationsMinAggregateOutputType | null
    _max: OrganizationsMaxAggregateOutputType | null
  }

  export type OrganizationsMinAggregateOutputType = {
    organization_id: string | null
    organization_handle: string | null
    organization_name: string | null
    organization_current_issue: string | null
    organization_stances: string | null
    organization_description: string | null
    profile_picture_id: string | null
  }

  export type OrganizationsMaxAggregateOutputType = {
    organization_id: string | null
    organization_handle: string | null
    organization_name: string | null
    organization_current_issue: string | null
    organization_stances: string | null
    organization_description: string | null
    profile_picture_id: string | null
  }

  export type OrganizationsCountAggregateOutputType = {
    organization_id: number
    organization_handle: number
    organization_name: number
    organization_current_issue: number
    organization_stances: number
    organization_description: number
    profile_picture_id: number
    _all: number
  }


  export type OrganizationsMinAggregateInputType = {
    organization_id?: true
    organization_handle?: true
    organization_name?: true
    organization_current_issue?: true
    organization_stances?: true
    organization_description?: true
    profile_picture_id?: true
  }

  export type OrganizationsMaxAggregateInputType = {
    organization_id?: true
    organization_handle?: true
    organization_name?: true
    organization_current_issue?: true
    organization_stances?: true
    organization_description?: true
    profile_picture_id?: true
  }

  export type OrganizationsCountAggregateInputType = {
    organization_id?: true
    organization_handle?: true
    organization_name?: true
    organization_current_issue?: true
    organization_stances?: true
    organization_description?: true
    profile_picture_id?: true
    _all?: true
  }

  export type OrganizationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which organizations to aggregate.
     */
    where?: organizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations to fetch.
     */
    orderBy?: organizationsOrderByWithRelationInput | organizationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: organizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned organizations
    **/
    _count?: true | OrganizationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationsMaxAggregateInputType
  }

  export type GetOrganizationsAggregateType<T extends OrganizationsAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizations[P]>
      : GetScalarType<T[P], AggregateOrganizations[P]>
  }




  export type organizationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: organizationsWhereInput
    orderBy?: organizationsOrderByWithAggregationInput | organizationsOrderByWithAggregationInput[]
    by: OrganizationsScalarFieldEnum[] | OrganizationsScalarFieldEnum
    having?: organizationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationsCountAggregateInputType | true
    _min?: OrganizationsMinAggregateInputType
    _max?: OrganizationsMaxAggregateInputType
  }

  export type OrganizationsGroupByOutputType = {
    organization_id: string
    organization_handle: string
    organization_name: string | null
    organization_current_issue: string | null
    organization_stances: string | null
    organization_description: string | null
    profile_picture_id: string | null
    _count: OrganizationsCountAggregateOutputType | null
    _min: OrganizationsMinAggregateOutputType | null
    _max: OrganizationsMaxAggregateOutputType | null
  }

  type GetOrganizationsGroupByPayload<T extends organizationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationsGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationsGroupByOutputType[P]>
        }
      >
    >


  export type organizationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    organization_id?: boolean
    organization_handle?: boolean
    organization_name?: boolean
    organization_current_issue?: boolean
    organization_stances?: boolean
    organization_description?: boolean
    profile_picture_id?: boolean
    profile_pictures?: boolean | organizations$profile_picturesArgs<ExtArgs>
    organizations_members?: boolean | organizations$organizations_membersArgs<ExtArgs>
    _count?: boolean | OrganizationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizations"]>

  export type organizationsSelectScalar = {
    organization_id?: boolean
    organization_handle?: boolean
    organization_name?: boolean
    organization_current_issue?: boolean
    organization_stances?: boolean
    organization_description?: boolean
    profile_picture_id?: boolean
  }

  export type organizationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile_pictures?: boolean | organizations$profile_picturesArgs<ExtArgs>
    organizations_members?: boolean | organizations$organizations_membersArgs<ExtArgs>
    _count?: boolean | OrganizationsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $organizationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "organizations"
    objects: {
      profile_pictures: Prisma.$profile_picturesPayload<ExtArgs> | null
      organizations_members: Prisma.$organizations_membersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      organization_id: string
      organization_handle: string
      organization_name: string | null
      organization_current_issue: string | null
      organization_stances: string | null
      organization_description: string | null
      profile_picture_id: string | null
    }, ExtArgs["result"]["organizations"]>
    composites: {}
  }


  type organizationsGetPayload<S extends boolean | null | undefined | organizationsDefaultArgs> = $Result.GetResult<Prisma.$organizationsPayload, S>

  type organizationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<organizationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrganizationsCountAggregateInputType | true
    }

  export interface organizationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['organizations'], meta: { name: 'organizations' } }
    /**
     * Find zero or one Organizations that matches the filter.
     * @param {organizationsFindUniqueArgs} args - Arguments to find a Organizations
     * @example
     * // Get one Organizations
     * const organizations = await prisma.organizations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends organizationsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, organizationsFindUniqueArgs<ExtArgs>>
    ): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Organizations that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {organizationsFindUniqueOrThrowArgs} args - Arguments to find a Organizations
     * @example
     * // Get one Organizations
     * const organizations = await prisma.organizations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends organizationsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, organizationsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationsFindFirstArgs} args - Arguments to find a Organizations
     * @example
     * // Get one Organizations
     * const organizations = await prisma.organizations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends organizationsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, organizationsFindFirstArgs<ExtArgs>>
    ): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Organizations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationsFindFirstOrThrowArgs} args - Arguments to find a Organizations
     * @example
     * // Get one Organizations
     * const organizations = await prisma.organizations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends organizationsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, organizationsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organizations.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organizations.findMany({ take: 10 })
     * 
     * // Only select the `organization_id`
     * const organizationsWithOrganization_idOnly = await prisma.organizations.findMany({ select: { organization_id: true } })
     * 
    **/
    findMany<T extends organizationsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, organizationsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Organizations.
     * @param {organizationsCreateArgs} args - Arguments to create a Organizations.
     * @example
     * // Create one Organizations
     * const Organizations = await prisma.organizations.create({
     *   data: {
     *     // ... data to create a Organizations
     *   }
     * })
     * 
    **/
    create<T extends organizationsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, organizationsCreateArgs<ExtArgs>>
    ): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Organizations.
     *     @param {organizationsCreateManyArgs} args - Arguments to create many Organizations.
     *     @example
     *     // Create many Organizations
     *     const organizations = await prisma.organizations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends organizationsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, organizationsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Organizations.
     * @param {organizationsDeleteArgs} args - Arguments to delete one Organizations.
     * @example
     * // Delete one Organizations
     * const Organizations = await prisma.organizations.delete({
     *   where: {
     *     // ... filter to delete one Organizations
     *   }
     * })
     * 
    **/
    delete<T extends organizationsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, organizationsDeleteArgs<ExtArgs>>
    ): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Organizations.
     * @param {organizationsUpdateArgs} args - Arguments to update one Organizations.
     * @example
     * // Update one Organizations
     * const organizations = await prisma.organizations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends organizationsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, organizationsUpdateArgs<ExtArgs>>
    ): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Organizations.
     * @param {organizationsDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organizations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends organizationsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, organizationsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organizations = await prisma.organizations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends organizationsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, organizationsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organizations.
     * @param {organizationsUpsertArgs} args - Arguments to update or create a Organizations.
     * @example
     * // Update or create a Organizations
     * const organizations = await prisma.organizations.upsert({
     *   create: {
     *     // ... data to create a Organizations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organizations we want to update
     *   }
     * })
    **/
    upsert<T extends organizationsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, organizationsUpsertArgs<ExtArgs>>
    ): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationsCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organizations.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends organizationsCountArgs>(
      args?: Subset<T, organizationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationsAggregateArgs>(args: Subset<T, OrganizationsAggregateArgs>): Prisma.PrismaPromise<GetOrganizationsAggregateType<T>>

    /**
     * Group by Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends organizationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: organizationsGroupByArgs['orderBy'] }
        : { orderBy?: organizationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, organizationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the organizations model
   */
  readonly fields: organizationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for organizations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__organizationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    profile_pictures<T extends organizations$profile_picturesArgs<ExtArgs> = {}>(args?: Subset<T, organizations$profile_picturesArgs<ExtArgs>>): Prisma__profile_picturesClient<$Result.GetResult<Prisma.$profile_picturesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    organizations_members<T extends organizations$organizations_membersArgs<ExtArgs> = {}>(args?: Subset<T, organizations$organizations_membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$organizations_membersPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the organizations model
   */ 
  interface organizationsFieldRefs {
    readonly organization_id: FieldRef<"organizations", 'String'>
    readonly organization_handle: FieldRef<"organizations", 'String'>
    readonly organization_name: FieldRef<"organizations", 'String'>
    readonly organization_current_issue: FieldRef<"organizations", 'String'>
    readonly organization_stances: FieldRef<"organizations", 'String'>
    readonly organization_description: FieldRef<"organizations", 'String'>
    readonly profile_picture_id: FieldRef<"organizations", 'String'>
  }
    

  // Custom InputTypes

  /**
   * organizations findUnique
   */
  export type organizationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude<ExtArgs> | null
    /**
     * Filter, which organizations to fetch.
     */
    where: organizationsWhereUniqueInput
  }


  /**
   * organizations findUniqueOrThrow
   */
  export type organizationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude<ExtArgs> | null
    /**
     * Filter, which organizations to fetch.
     */
    where: organizationsWhereUniqueInput
  }


  /**
   * organizations findFirst
   */
  export type organizationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude<ExtArgs> | null
    /**
     * Filter, which organizations to fetch.
     */
    where?: organizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations to fetch.
     */
    orderBy?: organizationsOrderByWithRelationInput | organizationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organizations.
     */
    cursor?: organizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organizations.
     */
    distinct?: OrganizationsScalarFieldEnum | OrganizationsScalarFieldEnum[]
  }


  /**
   * organizations findFirstOrThrow
   */
  export type organizationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude<ExtArgs> | null
    /**
     * Filter, which organizations to fetch.
     */
    where?: organizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations to fetch.
     */
    orderBy?: organizationsOrderByWithRelationInput | organizationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organizations.
     */
    cursor?: organizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organizations.
     */
    distinct?: OrganizationsScalarFieldEnum | OrganizationsScalarFieldEnum[]
  }


  /**
   * organizations findMany
   */
  export type organizationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude<ExtArgs> | null
    /**
     * Filter, which organizations to fetch.
     */
    where?: organizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations to fetch.
     */
    orderBy?: organizationsOrderByWithRelationInput | organizationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing organizations.
     */
    cursor?: organizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations.
     */
    skip?: number
    distinct?: OrganizationsScalarFieldEnum | OrganizationsScalarFieldEnum[]
  }


  /**
   * organizations create
   */
  export type organizationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude<ExtArgs> | null
    /**
     * The data needed to create a organizations.
     */
    data: XOR<organizationsCreateInput, organizationsUncheckedCreateInput>
  }


  /**
   * organizations createMany
   */
  export type organizationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many organizations.
     */
    data: organizationsCreateManyInput | organizationsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * organizations update
   */
  export type organizationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude<ExtArgs> | null
    /**
     * The data needed to update a organizations.
     */
    data: XOR<organizationsUpdateInput, organizationsUncheckedUpdateInput>
    /**
     * Choose, which organizations to update.
     */
    where: organizationsWhereUniqueInput
  }


  /**
   * organizations updateMany
   */
  export type organizationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update organizations.
     */
    data: XOR<organizationsUpdateManyMutationInput, organizationsUncheckedUpdateManyInput>
    /**
     * Filter which organizations to update
     */
    where?: organizationsWhereInput
  }


  /**
   * organizations upsert
   */
  export type organizationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude<ExtArgs> | null
    /**
     * The filter to search for the organizations to update in case it exists.
     */
    where: organizationsWhereUniqueInput
    /**
     * In case the organizations found by the `where` argument doesn't exist, create a new organizations with this data.
     */
    create: XOR<organizationsCreateInput, organizationsUncheckedCreateInput>
    /**
     * In case the organizations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<organizationsUpdateInput, organizationsUncheckedUpdateInput>
  }


  /**
   * organizations delete
   */
  export type organizationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude<ExtArgs> | null
    /**
     * Filter which organizations to delete.
     */
    where: organizationsWhereUniqueInput
  }


  /**
   * organizations deleteMany
   */
  export type organizationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which organizations to delete
     */
    where?: organizationsWhereInput
  }


  /**
   * organizations.profile_pictures
   */
  export type organizations$profile_picturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile_pictures
     */
    select?: profile_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profile_picturesInclude<ExtArgs> | null
    where?: profile_picturesWhereInput
  }


  /**
   * organizations.organizations_members
   */
  export type organizations$organizations_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations_members
     */
    select?: organizations_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizations_membersInclude<ExtArgs> | null
    where?: organizations_membersWhereInput
    orderBy?: organizations_membersOrderByWithRelationInput | organizations_membersOrderByWithRelationInput[]
    cursor?: organizations_membersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Organizations_membersScalarFieldEnum | Organizations_membersScalarFieldEnum[]
  }


  /**
   * organizations without action
   */
  export type organizationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude<ExtArgs> | null
  }



  /**
   * Model organizations_members
   */

  export type AggregateOrganizations_members = {
    _count: Organizations_membersCountAggregateOutputType | null
    _min: Organizations_membersMinAggregateOutputType | null
    _max: Organizations_membersMaxAggregateOutputType | null
  }

  export type Organizations_membersMinAggregateOutputType = {
    organizations_members_id: string | null
    organization_id: string | null
    entity_id: string | null
  }

  export type Organizations_membersMaxAggregateOutputType = {
    organizations_members_id: string | null
    organization_id: string | null
    entity_id: string | null
  }

  export type Organizations_membersCountAggregateOutputType = {
    organizations_members_id: number
    organization_id: number
    entity_id: number
    _all: number
  }


  export type Organizations_membersMinAggregateInputType = {
    organizations_members_id?: true
    organization_id?: true
    entity_id?: true
  }

  export type Organizations_membersMaxAggregateInputType = {
    organizations_members_id?: true
    organization_id?: true
    entity_id?: true
  }

  export type Organizations_membersCountAggregateInputType = {
    organizations_members_id?: true
    organization_id?: true
    entity_id?: true
    _all?: true
  }

  export type Organizations_membersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which organizations_members to aggregate.
     */
    where?: organizations_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations_members to fetch.
     */
    orderBy?: organizations_membersOrderByWithRelationInput | organizations_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: organizations_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned organizations_members
    **/
    _count?: true | Organizations_membersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Organizations_membersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Organizations_membersMaxAggregateInputType
  }

  export type GetOrganizations_membersAggregateType<T extends Organizations_membersAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizations_members]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizations_members[P]>
      : GetScalarType<T[P], AggregateOrganizations_members[P]>
  }




  export type organizations_membersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: organizations_membersWhereInput
    orderBy?: organizations_membersOrderByWithAggregationInput | organizations_membersOrderByWithAggregationInput[]
    by: Organizations_membersScalarFieldEnum[] | Organizations_membersScalarFieldEnum
    having?: organizations_membersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Organizations_membersCountAggregateInputType | true
    _min?: Organizations_membersMinAggregateInputType
    _max?: Organizations_membersMaxAggregateInputType
  }

  export type Organizations_membersGroupByOutputType = {
    organizations_members_id: string
    organization_id: string
    entity_id: string
    _count: Organizations_membersCountAggregateOutputType | null
    _min: Organizations_membersMinAggregateOutputType | null
    _max: Organizations_membersMaxAggregateOutputType | null
  }

  type GetOrganizations_membersGroupByPayload<T extends organizations_membersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Organizations_membersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Organizations_membersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Organizations_membersGroupByOutputType[P]>
            : GetScalarType<T[P], Organizations_membersGroupByOutputType[P]>
        }
      >
    >


  export type organizations_membersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    organizations_members_id?: boolean
    organization_id?: boolean
    entity_id?: boolean
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizations_members"]>

  export type organizations_membersSelectScalar = {
    organizations_members_id?: boolean
    organization_id?: boolean
    entity_id?: boolean
  }

  export type organizations_membersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }


  export type $organizations_membersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "organizations_members"
    objects: {
      entities: Prisma.$entitiesPayload<ExtArgs>
      organizations: Prisma.$organizationsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      organizations_members_id: string
      organization_id: string
      entity_id: string
    }, ExtArgs["result"]["organizations_members"]>
    composites: {}
  }


  type organizations_membersGetPayload<S extends boolean | null | undefined | organizations_membersDefaultArgs> = $Result.GetResult<Prisma.$organizations_membersPayload, S>

  type organizations_membersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<organizations_membersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Organizations_membersCountAggregateInputType | true
    }

  export interface organizations_membersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['organizations_members'], meta: { name: 'organizations_members' } }
    /**
     * Find zero or one Organizations_members that matches the filter.
     * @param {organizations_membersFindUniqueArgs} args - Arguments to find a Organizations_members
     * @example
     * // Get one Organizations_members
     * const organizations_members = await prisma.organizations_members.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends organizations_membersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, organizations_membersFindUniqueArgs<ExtArgs>>
    ): Prisma__organizations_membersClient<$Result.GetResult<Prisma.$organizations_membersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Organizations_members that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {organizations_membersFindUniqueOrThrowArgs} args - Arguments to find a Organizations_members
     * @example
     * // Get one Organizations_members
     * const organizations_members = await prisma.organizations_members.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends organizations_membersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, organizations_membersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__organizations_membersClient<$Result.GetResult<Prisma.$organizations_membersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Organizations_members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizations_membersFindFirstArgs} args - Arguments to find a Organizations_members
     * @example
     * // Get one Organizations_members
     * const organizations_members = await prisma.organizations_members.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends organizations_membersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, organizations_membersFindFirstArgs<ExtArgs>>
    ): Prisma__organizations_membersClient<$Result.GetResult<Prisma.$organizations_membersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Organizations_members that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizations_membersFindFirstOrThrowArgs} args - Arguments to find a Organizations_members
     * @example
     * // Get one Organizations_members
     * const organizations_members = await prisma.organizations_members.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends organizations_membersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, organizations_membersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__organizations_membersClient<$Result.GetResult<Prisma.$organizations_membersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Organizations_members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizations_membersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations_members
     * const organizations_members = await prisma.organizations_members.findMany()
     * 
     * // Get first 10 Organizations_members
     * const organizations_members = await prisma.organizations_members.findMany({ take: 10 })
     * 
     * // Only select the `organizations_members_id`
     * const organizations_membersWithOrganizations_members_idOnly = await prisma.organizations_members.findMany({ select: { organizations_members_id: true } })
     * 
    **/
    findMany<T extends organizations_membersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, organizations_membersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$organizations_membersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Organizations_members.
     * @param {organizations_membersCreateArgs} args - Arguments to create a Organizations_members.
     * @example
     * // Create one Organizations_members
     * const Organizations_members = await prisma.organizations_members.create({
     *   data: {
     *     // ... data to create a Organizations_members
     *   }
     * })
     * 
    **/
    create<T extends organizations_membersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, organizations_membersCreateArgs<ExtArgs>>
    ): Prisma__organizations_membersClient<$Result.GetResult<Prisma.$organizations_membersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Organizations_members.
     *     @param {organizations_membersCreateManyArgs} args - Arguments to create many Organizations_members.
     *     @example
     *     // Create many Organizations_members
     *     const organizations_members = await prisma.organizations_members.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends organizations_membersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, organizations_membersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Organizations_members.
     * @param {organizations_membersDeleteArgs} args - Arguments to delete one Organizations_members.
     * @example
     * // Delete one Organizations_members
     * const Organizations_members = await prisma.organizations_members.delete({
     *   where: {
     *     // ... filter to delete one Organizations_members
     *   }
     * })
     * 
    **/
    delete<T extends organizations_membersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, organizations_membersDeleteArgs<ExtArgs>>
    ): Prisma__organizations_membersClient<$Result.GetResult<Prisma.$organizations_membersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Organizations_members.
     * @param {organizations_membersUpdateArgs} args - Arguments to update one Organizations_members.
     * @example
     * // Update one Organizations_members
     * const organizations_members = await prisma.organizations_members.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends organizations_membersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, organizations_membersUpdateArgs<ExtArgs>>
    ): Prisma__organizations_membersClient<$Result.GetResult<Prisma.$organizations_membersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Organizations_members.
     * @param {organizations_membersDeleteManyArgs} args - Arguments to filter Organizations_members to delete.
     * @example
     * // Delete a few Organizations_members
     * const { count } = await prisma.organizations_members.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends organizations_membersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, organizations_membersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizations_membersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations_members
     * const organizations_members = await prisma.organizations_members.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends organizations_membersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, organizations_membersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organizations_members.
     * @param {organizations_membersUpsertArgs} args - Arguments to update or create a Organizations_members.
     * @example
     * // Update or create a Organizations_members
     * const organizations_members = await prisma.organizations_members.upsert({
     *   create: {
     *     // ... data to create a Organizations_members
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organizations_members we want to update
     *   }
     * })
    **/
    upsert<T extends organizations_membersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, organizations_membersUpsertArgs<ExtArgs>>
    ): Prisma__organizations_membersClient<$Result.GetResult<Prisma.$organizations_membersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Organizations_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizations_membersCountArgs} args - Arguments to filter Organizations_members to count.
     * @example
     * // Count the number of Organizations_members
     * const count = await prisma.organizations_members.count({
     *   where: {
     *     // ... the filter for the Organizations_members we want to count
     *   }
     * })
    **/
    count<T extends organizations_membersCountArgs>(
      args?: Subset<T, organizations_membersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Organizations_membersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organizations_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Organizations_membersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Organizations_membersAggregateArgs>(args: Subset<T, Organizations_membersAggregateArgs>): Prisma.PrismaPromise<GetOrganizations_membersAggregateType<T>>

    /**
     * Group by Organizations_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizations_membersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends organizations_membersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: organizations_membersGroupByArgs['orderBy'] }
        : { orderBy?: organizations_membersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, organizations_membersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizations_membersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the organizations_members model
   */
  readonly fields: organizations_membersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for organizations_members.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__organizations_membersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    entities<T extends entitiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, entitiesDefaultArgs<ExtArgs>>): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    organizations<T extends organizationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, organizationsDefaultArgs<ExtArgs>>): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the organizations_members model
   */ 
  interface organizations_membersFieldRefs {
    readonly organizations_members_id: FieldRef<"organizations_members", 'String'>
    readonly organization_id: FieldRef<"organizations_members", 'String'>
    readonly entity_id: FieldRef<"organizations_members", 'String'>
  }
    

  // Custom InputTypes

  /**
   * organizations_members findUnique
   */
  export type organizations_membersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations_members
     */
    select?: organizations_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizations_membersInclude<ExtArgs> | null
    /**
     * Filter, which organizations_members to fetch.
     */
    where: organizations_membersWhereUniqueInput
  }


  /**
   * organizations_members findUniqueOrThrow
   */
  export type organizations_membersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations_members
     */
    select?: organizations_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizations_membersInclude<ExtArgs> | null
    /**
     * Filter, which organizations_members to fetch.
     */
    where: organizations_membersWhereUniqueInput
  }


  /**
   * organizations_members findFirst
   */
  export type organizations_membersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations_members
     */
    select?: organizations_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizations_membersInclude<ExtArgs> | null
    /**
     * Filter, which organizations_members to fetch.
     */
    where?: organizations_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations_members to fetch.
     */
    orderBy?: organizations_membersOrderByWithRelationInput | organizations_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organizations_members.
     */
    cursor?: organizations_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organizations_members.
     */
    distinct?: Organizations_membersScalarFieldEnum | Organizations_membersScalarFieldEnum[]
  }


  /**
   * organizations_members findFirstOrThrow
   */
  export type organizations_membersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations_members
     */
    select?: organizations_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizations_membersInclude<ExtArgs> | null
    /**
     * Filter, which organizations_members to fetch.
     */
    where?: organizations_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations_members to fetch.
     */
    orderBy?: organizations_membersOrderByWithRelationInput | organizations_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organizations_members.
     */
    cursor?: organizations_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organizations_members.
     */
    distinct?: Organizations_membersScalarFieldEnum | Organizations_membersScalarFieldEnum[]
  }


  /**
   * organizations_members findMany
   */
  export type organizations_membersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations_members
     */
    select?: organizations_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizations_membersInclude<ExtArgs> | null
    /**
     * Filter, which organizations_members to fetch.
     */
    where?: organizations_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations_members to fetch.
     */
    orderBy?: organizations_membersOrderByWithRelationInput | organizations_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing organizations_members.
     */
    cursor?: organizations_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations_members.
     */
    skip?: number
    distinct?: Organizations_membersScalarFieldEnum | Organizations_membersScalarFieldEnum[]
  }


  /**
   * organizations_members create
   */
  export type organizations_membersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations_members
     */
    select?: organizations_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizations_membersInclude<ExtArgs> | null
    /**
     * The data needed to create a organizations_members.
     */
    data: XOR<organizations_membersCreateInput, organizations_membersUncheckedCreateInput>
  }


  /**
   * organizations_members createMany
   */
  export type organizations_membersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many organizations_members.
     */
    data: organizations_membersCreateManyInput | organizations_membersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * organizations_members update
   */
  export type organizations_membersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations_members
     */
    select?: organizations_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizations_membersInclude<ExtArgs> | null
    /**
     * The data needed to update a organizations_members.
     */
    data: XOR<organizations_membersUpdateInput, organizations_membersUncheckedUpdateInput>
    /**
     * Choose, which organizations_members to update.
     */
    where: organizations_membersWhereUniqueInput
  }


  /**
   * organizations_members updateMany
   */
  export type organizations_membersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update organizations_members.
     */
    data: XOR<organizations_membersUpdateManyMutationInput, organizations_membersUncheckedUpdateManyInput>
    /**
     * Filter which organizations_members to update
     */
    where?: organizations_membersWhereInput
  }


  /**
   * organizations_members upsert
   */
  export type organizations_membersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations_members
     */
    select?: organizations_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizations_membersInclude<ExtArgs> | null
    /**
     * The filter to search for the organizations_members to update in case it exists.
     */
    where: organizations_membersWhereUniqueInput
    /**
     * In case the organizations_members found by the `where` argument doesn't exist, create a new organizations_members with this data.
     */
    create: XOR<organizations_membersCreateInput, organizations_membersUncheckedCreateInput>
    /**
     * In case the organizations_members was found with the provided `where` argument, update it with this data.
     */
    update: XOR<organizations_membersUpdateInput, organizations_membersUncheckedUpdateInput>
  }


  /**
   * organizations_members delete
   */
  export type organizations_membersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations_members
     */
    select?: organizations_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizations_membersInclude<ExtArgs> | null
    /**
     * Filter which organizations_members to delete.
     */
    where: organizations_membersWhereUniqueInput
  }


  /**
   * organizations_members deleteMany
   */
  export type organizations_membersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which organizations_members to delete
     */
    where?: organizations_membersWhereInput
  }


  /**
   * organizations_members without action
   */
  export type organizations_membersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations_members
     */
    select?: organizations_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizations_membersInclude<ExtArgs> | null
  }



  /**
   * Model profile_pictures
   */

  export type AggregateProfile_pictures = {
    _count: Profile_picturesCountAggregateOutputType | null
    _min: Profile_picturesMinAggregateOutputType | null
    _max: Profile_picturesMaxAggregateOutputType | null
  }

  export type Profile_picturesMinAggregateOutputType = {
    profile_picture_id: string | null
    profile_picture_data: Buffer | null
    profile_picture_filename: string | null
  }

  export type Profile_picturesMaxAggregateOutputType = {
    profile_picture_id: string | null
    profile_picture_data: Buffer | null
    profile_picture_filename: string | null
  }

  export type Profile_picturesCountAggregateOutputType = {
    profile_picture_id: number
    profile_picture_data: number
    profile_picture_filename: number
    _all: number
  }


  export type Profile_picturesMinAggregateInputType = {
    profile_picture_id?: true
    profile_picture_data?: true
    profile_picture_filename?: true
  }

  export type Profile_picturesMaxAggregateInputType = {
    profile_picture_id?: true
    profile_picture_data?: true
    profile_picture_filename?: true
  }

  export type Profile_picturesCountAggregateInputType = {
    profile_picture_id?: true
    profile_picture_data?: true
    profile_picture_filename?: true
    _all?: true
  }

  export type Profile_picturesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which profile_pictures to aggregate.
     */
    where?: profile_picturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profile_pictures to fetch.
     */
    orderBy?: profile_picturesOrderByWithRelationInput | profile_picturesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: profile_picturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profile_pictures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profile_pictures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned profile_pictures
    **/
    _count?: true | Profile_picturesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Profile_picturesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Profile_picturesMaxAggregateInputType
  }

  export type GetProfile_picturesAggregateType<T extends Profile_picturesAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile_pictures]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile_pictures[P]>
      : GetScalarType<T[P], AggregateProfile_pictures[P]>
  }




  export type profile_picturesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: profile_picturesWhereInput
    orderBy?: profile_picturesOrderByWithAggregationInput | profile_picturesOrderByWithAggregationInput[]
    by: Profile_picturesScalarFieldEnum[] | Profile_picturesScalarFieldEnum
    having?: profile_picturesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Profile_picturesCountAggregateInputType | true
    _min?: Profile_picturesMinAggregateInputType
    _max?: Profile_picturesMaxAggregateInputType
  }

  export type Profile_picturesGroupByOutputType = {
    profile_picture_id: string
    profile_picture_data: Buffer
    profile_picture_filename: string
    _count: Profile_picturesCountAggregateOutputType | null
    _min: Profile_picturesMinAggregateOutputType | null
    _max: Profile_picturesMaxAggregateOutputType | null
  }

  type GetProfile_picturesGroupByPayload<T extends profile_picturesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Profile_picturesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Profile_picturesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Profile_picturesGroupByOutputType[P]>
            : GetScalarType<T[P], Profile_picturesGroupByOutputType[P]>
        }
      >
    >


  export type profile_picturesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    profile_picture_id?: boolean
    profile_picture_data?: boolean
    profile_picture_filename?: boolean
    groups?: boolean | profile_pictures$groupsArgs<ExtArgs>
    individuals?: boolean | profile_pictures$individualsArgs<ExtArgs>
    organizations?: boolean | profile_pictures$organizationsArgs<ExtArgs>
    _count?: boolean | Profile_picturesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile_pictures"]>

  export type profile_picturesSelectScalar = {
    profile_picture_id?: boolean
    profile_picture_data?: boolean
    profile_picture_filename?: boolean
  }

  export type profile_picturesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groups?: boolean | profile_pictures$groupsArgs<ExtArgs>
    individuals?: boolean | profile_pictures$individualsArgs<ExtArgs>
    organizations?: boolean | profile_pictures$organizationsArgs<ExtArgs>
    _count?: boolean | Profile_picturesCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $profile_picturesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "profile_pictures"
    objects: {
      groups: Prisma.$groupsPayload<ExtArgs>[]
      individuals: Prisma.$individualsPayload<ExtArgs>[]
      organizations: Prisma.$organizationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      profile_picture_id: string
      profile_picture_data: Buffer
      profile_picture_filename: string
    }, ExtArgs["result"]["profile_pictures"]>
    composites: {}
  }


  type profile_picturesGetPayload<S extends boolean | null | undefined | profile_picturesDefaultArgs> = $Result.GetResult<Prisma.$profile_picturesPayload, S>

  type profile_picturesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<profile_picturesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Profile_picturesCountAggregateInputType | true
    }

  export interface profile_picturesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['profile_pictures'], meta: { name: 'profile_pictures' } }
    /**
     * Find zero or one Profile_pictures that matches the filter.
     * @param {profile_picturesFindUniqueArgs} args - Arguments to find a Profile_pictures
     * @example
     * // Get one Profile_pictures
     * const profile_pictures = await prisma.profile_pictures.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends profile_picturesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, profile_picturesFindUniqueArgs<ExtArgs>>
    ): Prisma__profile_picturesClient<$Result.GetResult<Prisma.$profile_picturesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Profile_pictures that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {profile_picturesFindUniqueOrThrowArgs} args - Arguments to find a Profile_pictures
     * @example
     * // Get one Profile_pictures
     * const profile_pictures = await prisma.profile_pictures.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends profile_picturesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, profile_picturesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__profile_picturesClient<$Result.GetResult<Prisma.$profile_picturesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Profile_pictures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profile_picturesFindFirstArgs} args - Arguments to find a Profile_pictures
     * @example
     * // Get one Profile_pictures
     * const profile_pictures = await prisma.profile_pictures.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends profile_picturesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, profile_picturesFindFirstArgs<ExtArgs>>
    ): Prisma__profile_picturesClient<$Result.GetResult<Prisma.$profile_picturesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Profile_pictures that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profile_picturesFindFirstOrThrowArgs} args - Arguments to find a Profile_pictures
     * @example
     * // Get one Profile_pictures
     * const profile_pictures = await prisma.profile_pictures.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends profile_picturesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, profile_picturesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__profile_picturesClient<$Result.GetResult<Prisma.$profile_picturesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Profile_pictures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profile_picturesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profile_pictures
     * const profile_pictures = await prisma.profile_pictures.findMany()
     * 
     * // Get first 10 Profile_pictures
     * const profile_pictures = await prisma.profile_pictures.findMany({ take: 10 })
     * 
     * // Only select the `profile_picture_id`
     * const profile_picturesWithProfile_picture_idOnly = await prisma.profile_pictures.findMany({ select: { profile_picture_id: true } })
     * 
    **/
    findMany<T extends profile_picturesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, profile_picturesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$profile_picturesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Profile_pictures.
     * @param {profile_picturesCreateArgs} args - Arguments to create a Profile_pictures.
     * @example
     * // Create one Profile_pictures
     * const Profile_pictures = await prisma.profile_pictures.create({
     *   data: {
     *     // ... data to create a Profile_pictures
     *   }
     * })
     * 
    **/
    create<T extends profile_picturesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, profile_picturesCreateArgs<ExtArgs>>
    ): Prisma__profile_picturesClient<$Result.GetResult<Prisma.$profile_picturesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Profile_pictures.
     *     @param {profile_picturesCreateManyArgs} args - Arguments to create many Profile_pictures.
     *     @example
     *     // Create many Profile_pictures
     *     const profile_pictures = await prisma.profile_pictures.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends profile_picturesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, profile_picturesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Profile_pictures.
     * @param {profile_picturesDeleteArgs} args - Arguments to delete one Profile_pictures.
     * @example
     * // Delete one Profile_pictures
     * const Profile_pictures = await prisma.profile_pictures.delete({
     *   where: {
     *     // ... filter to delete one Profile_pictures
     *   }
     * })
     * 
    **/
    delete<T extends profile_picturesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, profile_picturesDeleteArgs<ExtArgs>>
    ): Prisma__profile_picturesClient<$Result.GetResult<Prisma.$profile_picturesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Profile_pictures.
     * @param {profile_picturesUpdateArgs} args - Arguments to update one Profile_pictures.
     * @example
     * // Update one Profile_pictures
     * const profile_pictures = await prisma.profile_pictures.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends profile_picturesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, profile_picturesUpdateArgs<ExtArgs>>
    ): Prisma__profile_picturesClient<$Result.GetResult<Prisma.$profile_picturesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Profile_pictures.
     * @param {profile_picturesDeleteManyArgs} args - Arguments to filter Profile_pictures to delete.
     * @example
     * // Delete a few Profile_pictures
     * const { count } = await prisma.profile_pictures.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends profile_picturesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, profile_picturesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profile_pictures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profile_picturesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profile_pictures
     * const profile_pictures = await prisma.profile_pictures.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends profile_picturesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, profile_picturesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile_pictures.
     * @param {profile_picturesUpsertArgs} args - Arguments to update or create a Profile_pictures.
     * @example
     * // Update or create a Profile_pictures
     * const profile_pictures = await prisma.profile_pictures.upsert({
     *   create: {
     *     // ... data to create a Profile_pictures
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile_pictures we want to update
     *   }
     * })
    **/
    upsert<T extends profile_picturesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, profile_picturesUpsertArgs<ExtArgs>>
    ): Prisma__profile_picturesClient<$Result.GetResult<Prisma.$profile_picturesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Profile_pictures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profile_picturesCountArgs} args - Arguments to filter Profile_pictures to count.
     * @example
     * // Count the number of Profile_pictures
     * const count = await prisma.profile_pictures.count({
     *   where: {
     *     // ... the filter for the Profile_pictures we want to count
     *   }
     * })
    **/
    count<T extends profile_picturesCountArgs>(
      args?: Subset<T, profile_picturesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Profile_picturesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile_pictures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Profile_picturesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Profile_picturesAggregateArgs>(args: Subset<T, Profile_picturesAggregateArgs>): Prisma.PrismaPromise<GetProfile_picturesAggregateType<T>>

    /**
     * Group by Profile_pictures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profile_picturesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends profile_picturesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: profile_picturesGroupByArgs['orderBy'] }
        : { orderBy?: profile_picturesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, profile_picturesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfile_picturesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the profile_pictures model
   */
  readonly fields: profile_picturesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for profile_pictures.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__profile_picturesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    groups<T extends profile_pictures$groupsArgs<ExtArgs> = {}>(args?: Subset<T, profile_pictures$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, 'findMany'> | Null>;

    individuals<T extends profile_pictures$individualsArgs<ExtArgs> = {}>(args?: Subset<T, profile_pictures$individualsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$individualsPayload<ExtArgs>, T, 'findMany'> | Null>;

    organizations<T extends profile_pictures$organizationsArgs<ExtArgs> = {}>(args?: Subset<T, profile_pictures$organizationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the profile_pictures model
   */ 
  interface profile_picturesFieldRefs {
    readonly profile_picture_id: FieldRef<"profile_pictures", 'String'>
    readonly profile_picture_data: FieldRef<"profile_pictures", 'Bytes'>
    readonly profile_picture_filename: FieldRef<"profile_pictures", 'String'>
  }
    

  // Custom InputTypes

  /**
   * profile_pictures findUnique
   */
  export type profile_picturesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile_pictures
     */
    select?: profile_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profile_picturesInclude<ExtArgs> | null
    /**
     * Filter, which profile_pictures to fetch.
     */
    where: profile_picturesWhereUniqueInput
  }


  /**
   * profile_pictures findUniqueOrThrow
   */
  export type profile_picturesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile_pictures
     */
    select?: profile_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profile_picturesInclude<ExtArgs> | null
    /**
     * Filter, which profile_pictures to fetch.
     */
    where: profile_picturesWhereUniqueInput
  }


  /**
   * profile_pictures findFirst
   */
  export type profile_picturesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile_pictures
     */
    select?: profile_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profile_picturesInclude<ExtArgs> | null
    /**
     * Filter, which profile_pictures to fetch.
     */
    where?: profile_picturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profile_pictures to fetch.
     */
    orderBy?: profile_picturesOrderByWithRelationInput | profile_picturesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for profile_pictures.
     */
    cursor?: profile_picturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profile_pictures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profile_pictures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of profile_pictures.
     */
    distinct?: Profile_picturesScalarFieldEnum | Profile_picturesScalarFieldEnum[]
  }


  /**
   * profile_pictures findFirstOrThrow
   */
  export type profile_picturesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile_pictures
     */
    select?: profile_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profile_picturesInclude<ExtArgs> | null
    /**
     * Filter, which profile_pictures to fetch.
     */
    where?: profile_picturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profile_pictures to fetch.
     */
    orderBy?: profile_picturesOrderByWithRelationInput | profile_picturesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for profile_pictures.
     */
    cursor?: profile_picturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profile_pictures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profile_pictures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of profile_pictures.
     */
    distinct?: Profile_picturesScalarFieldEnum | Profile_picturesScalarFieldEnum[]
  }


  /**
   * profile_pictures findMany
   */
  export type profile_picturesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile_pictures
     */
    select?: profile_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profile_picturesInclude<ExtArgs> | null
    /**
     * Filter, which profile_pictures to fetch.
     */
    where?: profile_picturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profile_pictures to fetch.
     */
    orderBy?: profile_picturesOrderByWithRelationInput | profile_picturesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing profile_pictures.
     */
    cursor?: profile_picturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profile_pictures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profile_pictures.
     */
    skip?: number
    distinct?: Profile_picturesScalarFieldEnum | Profile_picturesScalarFieldEnum[]
  }


  /**
   * profile_pictures create
   */
  export type profile_picturesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile_pictures
     */
    select?: profile_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profile_picturesInclude<ExtArgs> | null
    /**
     * The data needed to create a profile_pictures.
     */
    data: XOR<profile_picturesCreateInput, profile_picturesUncheckedCreateInput>
  }


  /**
   * profile_pictures createMany
   */
  export type profile_picturesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many profile_pictures.
     */
    data: profile_picturesCreateManyInput | profile_picturesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * profile_pictures update
   */
  export type profile_picturesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile_pictures
     */
    select?: profile_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profile_picturesInclude<ExtArgs> | null
    /**
     * The data needed to update a profile_pictures.
     */
    data: XOR<profile_picturesUpdateInput, profile_picturesUncheckedUpdateInput>
    /**
     * Choose, which profile_pictures to update.
     */
    where: profile_picturesWhereUniqueInput
  }


  /**
   * profile_pictures updateMany
   */
  export type profile_picturesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update profile_pictures.
     */
    data: XOR<profile_picturesUpdateManyMutationInput, profile_picturesUncheckedUpdateManyInput>
    /**
     * Filter which profile_pictures to update
     */
    where?: profile_picturesWhereInput
  }


  /**
   * profile_pictures upsert
   */
  export type profile_picturesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile_pictures
     */
    select?: profile_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profile_picturesInclude<ExtArgs> | null
    /**
     * The filter to search for the profile_pictures to update in case it exists.
     */
    where: profile_picturesWhereUniqueInput
    /**
     * In case the profile_pictures found by the `where` argument doesn't exist, create a new profile_pictures with this data.
     */
    create: XOR<profile_picturesCreateInput, profile_picturesUncheckedCreateInput>
    /**
     * In case the profile_pictures was found with the provided `where` argument, update it with this data.
     */
    update: XOR<profile_picturesUpdateInput, profile_picturesUncheckedUpdateInput>
  }


  /**
   * profile_pictures delete
   */
  export type profile_picturesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile_pictures
     */
    select?: profile_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profile_picturesInclude<ExtArgs> | null
    /**
     * Filter which profile_pictures to delete.
     */
    where: profile_picturesWhereUniqueInput
  }


  /**
   * profile_pictures deleteMany
   */
  export type profile_picturesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which profile_pictures to delete
     */
    where?: profile_picturesWhereInput
  }


  /**
   * profile_pictures.groups
   */
  export type profile_pictures$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groupsInclude<ExtArgs> | null
    where?: groupsWhereInput
    orderBy?: groupsOrderByWithRelationInput | groupsOrderByWithRelationInput[]
    cursor?: groupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupsScalarFieldEnum | GroupsScalarFieldEnum[]
  }


  /**
   * profile_pictures.individuals
   */
  export type profile_pictures$individualsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the individuals
     */
    select?: individualsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: individualsInclude<ExtArgs> | null
    where?: individualsWhereInput
    orderBy?: individualsOrderByWithRelationInput | individualsOrderByWithRelationInput[]
    cursor?: individualsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IndividualsScalarFieldEnum | IndividualsScalarFieldEnum[]
  }


  /**
   * profile_pictures.organizations
   */
  export type profile_pictures$organizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude<ExtArgs> | null
    where?: organizationsWhereInput
    orderBy?: organizationsOrderByWithRelationInput | organizationsOrderByWithRelationInput[]
    cursor?: organizationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationsScalarFieldEnum | OrganizationsScalarFieldEnum[]
  }


  /**
   * profile_pictures without action
   */
  export type profile_picturesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile_pictures
     */
    select?: profile_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profile_picturesInclude<ExtArgs> | null
  }



  /**
   * Model sheets
   */

  export type AggregateSheets = {
    _count: SheetsCountAggregateOutputType | null
    _avg: SheetsAvgAggregateOutputType | null
    _sum: SheetsSumAggregateOutputType | null
    _min: SheetsMinAggregateOutputType | null
    _max: SheetsMaxAggregateOutputType | null
  }

  export type SheetsAvgAggregateOutputType = {
    sheet_likes: number | null
    sheet_dislikes: number | null
    sheet_views: number | null
  }

  export type SheetsSumAggregateOutputType = {
    sheet_likes: number | null
    sheet_dislikes: number | null
    sheet_views: number | null
  }

  export type SheetsMinAggregateOutputType = {
    sheet_id: string | null
    sheet_author_id: string | null
    sheet_title: string | null
    sheet_subject: string | null
    sheet_filename: string | null
    sheet_data_id: string | null
    sheet_thumbnail_id: string | null
    sheet_likes: number | null
    sheet_dislikes: number | null
    sheet_views: number | null
    sheet_date_posted: Date | null
  }

  export type SheetsMaxAggregateOutputType = {
    sheet_id: string | null
    sheet_author_id: string | null
    sheet_title: string | null
    sheet_subject: string | null
    sheet_filename: string | null
    sheet_data_id: string | null
    sheet_thumbnail_id: string | null
    sheet_likes: number | null
    sheet_dislikes: number | null
    sheet_views: number | null
    sheet_date_posted: Date | null
  }

  export type SheetsCountAggregateOutputType = {
    sheet_id: number
    sheet_author_id: number
    sheet_title: number
    sheet_subject: number
    sheet_filename: number
    sheet_data_id: number
    sheet_thumbnail_id: number
    sheet_likes: number
    sheet_dislikes: number
    sheet_views: number
    sheet_date_posted: number
    _all: number
  }


  export type SheetsAvgAggregateInputType = {
    sheet_likes?: true
    sheet_dislikes?: true
    sheet_views?: true
  }

  export type SheetsSumAggregateInputType = {
    sheet_likes?: true
    sheet_dislikes?: true
    sheet_views?: true
  }

  export type SheetsMinAggregateInputType = {
    sheet_id?: true
    sheet_author_id?: true
    sheet_title?: true
    sheet_subject?: true
    sheet_filename?: true
    sheet_data_id?: true
    sheet_thumbnail_id?: true
    sheet_likes?: true
    sheet_dislikes?: true
    sheet_views?: true
    sheet_date_posted?: true
  }

  export type SheetsMaxAggregateInputType = {
    sheet_id?: true
    sheet_author_id?: true
    sheet_title?: true
    sheet_subject?: true
    sheet_filename?: true
    sheet_data_id?: true
    sheet_thumbnail_id?: true
    sheet_likes?: true
    sheet_dislikes?: true
    sheet_views?: true
    sheet_date_posted?: true
  }

  export type SheetsCountAggregateInputType = {
    sheet_id?: true
    sheet_author_id?: true
    sheet_title?: true
    sheet_subject?: true
    sheet_filename?: true
    sheet_data_id?: true
    sheet_thumbnail_id?: true
    sheet_likes?: true
    sheet_dislikes?: true
    sheet_views?: true
    sheet_date_posted?: true
    _all?: true
  }

  export type SheetsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sheets to aggregate.
     */
    where?: sheetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sheets to fetch.
     */
    orderBy?: sheetsOrderByWithRelationInput | sheetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sheetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sheets
    **/
    _count?: true | SheetsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SheetsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SheetsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SheetsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SheetsMaxAggregateInputType
  }

  export type GetSheetsAggregateType<T extends SheetsAggregateArgs> = {
        [P in keyof T & keyof AggregateSheets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSheets[P]>
      : GetScalarType<T[P], AggregateSheets[P]>
  }




  export type sheetsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sheetsWhereInput
    orderBy?: sheetsOrderByWithAggregationInput | sheetsOrderByWithAggregationInput[]
    by: SheetsScalarFieldEnum[] | SheetsScalarFieldEnum
    having?: sheetsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SheetsCountAggregateInputType | true
    _avg?: SheetsAvgAggregateInputType
    _sum?: SheetsSumAggregateInputType
    _min?: SheetsMinAggregateInputType
    _max?: SheetsMaxAggregateInputType
  }

  export type SheetsGroupByOutputType = {
    sheet_id: string
    sheet_author_id: string
    sheet_title: string
    sheet_subject: string
    sheet_filename: string
    sheet_data_id: string
    sheet_thumbnail_id: string | null
    sheet_likes: number
    sheet_dislikes: number
    sheet_views: number
    sheet_date_posted: Date
    _count: SheetsCountAggregateOutputType | null
    _avg: SheetsAvgAggregateOutputType | null
    _sum: SheetsSumAggregateOutputType | null
    _min: SheetsMinAggregateOutputType | null
    _max: SheetsMaxAggregateOutputType | null
  }

  type GetSheetsGroupByPayload<T extends sheetsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SheetsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SheetsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SheetsGroupByOutputType[P]>
            : GetScalarType<T[P], SheetsGroupByOutputType[P]>
        }
      >
    >


  export type sheetsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sheet_id?: boolean
    sheet_author_id?: boolean
    sheet_title?: boolean
    sheet_subject?: boolean
    sheet_filename?: boolean
    sheet_data_id?: boolean
    sheet_thumbnail_id?: boolean
    sheet_likes?: boolean
    sheet_dislikes?: boolean
    sheet_views?: boolean
    sheet_date_posted?: boolean
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
    sheets_data?: boolean | sheets_dataDefaultArgs<ExtArgs>
    sheets_thumbnails?: boolean | sheets$sheets_thumbnailsArgs<ExtArgs>
  }, ExtArgs["result"]["sheets"]>

  export type sheetsSelectScalar = {
    sheet_id?: boolean
    sheet_author_id?: boolean
    sheet_title?: boolean
    sheet_subject?: boolean
    sheet_filename?: boolean
    sheet_data_id?: boolean
    sheet_thumbnail_id?: boolean
    sheet_likes?: boolean
    sheet_dislikes?: boolean
    sheet_views?: boolean
    sheet_date_posted?: boolean
  }

  export type sheetsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
    sheets_data?: boolean | sheets_dataDefaultArgs<ExtArgs>
    sheets_thumbnails?: boolean | sheets$sheets_thumbnailsArgs<ExtArgs>
  }


  export type $sheetsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sheets"
    objects: {
      entities: Prisma.$entitiesPayload<ExtArgs>
      sheets_data: Prisma.$sheets_dataPayload<ExtArgs>
      sheets_thumbnails: Prisma.$sheets_thumbnailsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      sheet_id: string
      sheet_author_id: string
      sheet_title: string
      sheet_subject: string
      sheet_filename: string
      sheet_data_id: string
      sheet_thumbnail_id: string | null
      sheet_likes: number
      sheet_dislikes: number
      sheet_views: number
      sheet_date_posted: Date
    }, ExtArgs["result"]["sheets"]>
    composites: {}
  }


  type sheetsGetPayload<S extends boolean | null | undefined | sheetsDefaultArgs> = $Result.GetResult<Prisma.$sheetsPayload, S>

  type sheetsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<sheetsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SheetsCountAggregateInputType | true
    }

  export interface sheetsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sheets'], meta: { name: 'sheets' } }
    /**
     * Find zero or one Sheets that matches the filter.
     * @param {sheetsFindUniqueArgs} args - Arguments to find a Sheets
     * @example
     * // Get one Sheets
     * const sheets = await prisma.sheets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sheetsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, sheetsFindUniqueArgs<ExtArgs>>
    ): Prisma__sheetsClient<$Result.GetResult<Prisma.$sheetsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Sheets that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {sheetsFindUniqueOrThrowArgs} args - Arguments to find a Sheets
     * @example
     * // Get one Sheets
     * const sheets = await prisma.sheets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends sheetsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sheetsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__sheetsClient<$Result.GetResult<Prisma.$sheetsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Sheets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sheetsFindFirstArgs} args - Arguments to find a Sheets
     * @example
     * // Get one Sheets
     * const sheets = await prisma.sheets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sheetsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, sheetsFindFirstArgs<ExtArgs>>
    ): Prisma__sheetsClient<$Result.GetResult<Prisma.$sheetsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Sheets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sheetsFindFirstOrThrowArgs} args - Arguments to find a Sheets
     * @example
     * // Get one Sheets
     * const sheets = await prisma.sheets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends sheetsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sheetsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__sheetsClient<$Result.GetResult<Prisma.$sheetsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Sheets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sheetsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sheets
     * const sheets = await prisma.sheets.findMany()
     * 
     * // Get first 10 Sheets
     * const sheets = await prisma.sheets.findMany({ take: 10 })
     * 
     * // Only select the `sheet_id`
     * const sheetsWithSheet_idOnly = await prisma.sheets.findMany({ select: { sheet_id: true } })
     * 
    **/
    findMany<T extends sheetsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sheetsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sheetsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Sheets.
     * @param {sheetsCreateArgs} args - Arguments to create a Sheets.
     * @example
     * // Create one Sheets
     * const Sheets = await prisma.sheets.create({
     *   data: {
     *     // ... data to create a Sheets
     *   }
     * })
     * 
    **/
    create<T extends sheetsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, sheetsCreateArgs<ExtArgs>>
    ): Prisma__sheetsClient<$Result.GetResult<Prisma.$sheetsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Sheets.
     *     @param {sheetsCreateManyArgs} args - Arguments to create many Sheets.
     *     @example
     *     // Create many Sheets
     *     const sheets = await prisma.sheets.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends sheetsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sheetsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sheets.
     * @param {sheetsDeleteArgs} args - Arguments to delete one Sheets.
     * @example
     * // Delete one Sheets
     * const Sheets = await prisma.sheets.delete({
     *   where: {
     *     // ... filter to delete one Sheets
     *   }
     * })
     * 
    **/
    delete<T extends sheetsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, sheetsDeleteArgs<ExtArgs>>
    ): Prisma__sheetsClient<$Result.GetResult<Prisma.$sheetsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Sheets.
     * @param {sheetsUpdateArgs} args - Arguments to update one Sheets.
     * @example
     * // Update one Sheets
     * const sheets = await prisma.sheets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sheetsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, sheetsUpdateArgs<ExtArgs>>
    ): Prisma__sheetsClient<$Result.GetResult<Prisma.$sheetsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Sheets.
     * @param {sheetsDeleteManyArgs} args - Arguments to filter Sheets to delete.
     * @example
     * // Delete a few Sheets
     * const { count } = await prisma.sheets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sheetsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sheetsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sheets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sheetsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sheets
     * const sheets = await prisma.sheets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sheetsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, sheetsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sheets.
     * @param {sheetsUpsertArgs} args - Arguments to update or create a Sheets.
     * @example
     * // Update or create a Sheets
     * const sheets = await prisma.sheets.upsert({
     *   create: {
     *     // ... data to create a Sheets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sheets we want to update
     *   }
     * })
    **/
    upsert<T extends sheetsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, sheetsUpsertArgs<ExtArgs>>
    ): Prisma__sheetsClient<$Result.GetResult<Prisma.$sheetsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Sheets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sheetsCountArgs} args - Arguments to filter Sheets to count.
     * @example
     * // Count the number of Sheets
     * const count = await prisma.sheets.count({
     *   where: {
     *     // ... the filter for the Sheets we want to count
     *   }
     * })
    **/
    count<T extends sheetsCountArgs>(
      args?: Subset<T, sheetsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SheetsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sheets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SheetsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SheetsAggregateArgs>(args: Subset<T, SheetsAggregateArgs>): Prisma.PrismaPromise<GetSheetsAggregateType<T>>

    /**
     * Group by Sheets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sheetsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sheetsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sheetsGroupByArgs['orderBy'] }
        : { orderBy?: sheetsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sheetsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSheetsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sheets model
   */
  readonly fields: sheetsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sheets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sheetsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    entities<T extends entitiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, entitiesDefaultArgs<ExtArgs>>): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    sheets_data<T extends sheets_dataDefaultArgs<ExtArgs> = {}>(args?: Subset<T, sheets_dataDefaultArgs<ExtArgs>>): Prisma__sheets_dataClient<$Result.GetResult<Prisma.$sheets_dataPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    sheets_thumbnails<T extends sheets$sheets_thumbnailsArgs<ExtArgs> = {}>(args?: Subset<T, sheets$sheets_thumbnailsArgs<ExtArgs>>): Prisma__sheets_thumbnailsClient<$Result.GetResult<Prisma.$sheets_thumbnailsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the sheets model
   */ 
  interface sheetsFieldRefs {
    readonly sheet_id: FieldRef<"sheets", 'String'>
    readonly sheet_author_id: FieldRef<"sheets", 'String'>
    readonly sheet_title: FieldRef<"sheets", 'String'>
    readonly sheet_subject: FieldRef<"sheets", 'String'>
    readonly sheet_filename: FieldRef<"sheets", 'String'>
    readonly sheet_data_id: FieldRef<"sheets", 'String'>
    readonly sheet_thumbnail_id: FieldRef<"sheets", 'String'>
    readonly sheet_likes: FieldRef<"sheets", 'Int'>
    readonly sheet_dislikes: FieldRef<"sheets", 'Int'>
    readonly sheet_views: FieldRef<"sheets", 'Int'>
    readonly sheet_date_posted: FieldRef<"sheets", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * sheets findUnique
   */
  export type sheetsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets
     */
    select?: sheetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheetsInclude<ExtArgs> | null
    /**
     * Filter, which sheets to fetch.
     */
    where: sheetsWhereUniqueInput
  }


  /**
   * sheets findUniqueOrThrow
   */
  export type sheetsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets
     */
    select?: sheetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheetsInclude<ExtArgs> | null
    /**
     * Filter, which sheets to fetch.
     */
    where: sheetsWhereUniqueInput
  }


  /**
   * sheets findFirst
   */
  export type sheetsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets
     */
    select?: sheetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheetsInclude<ExtArgs> | null
    /**
     * Filter, which sheets to fetch.
     */
    where?: sheetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sheets to fetch.
     */
    orderBy?: sheetsOrderByWithRelationInput | sheetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sheets.
     */
    cursor?: sheetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sheets.
     */
    distinct?: SheetsScalarFieldEnum | SheetsScalarFieldEnum[]
  }


  /**
   * sheets findFirstOrThrow
   */
  export type sheetsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets
     */
    select?: sheetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheetsInclude<ExtArgs> | null
    /**
     * Filter, which sheets to fetch.
     */
    where?: sheetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sheets to fetch.
     */
    orderBy?: sheetsOrderByWithRelationInput | sheetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sheets.
     */
    cursor?: sheetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sheets.
     */
    distinct?: SheetsScalarFieldEnum | SheetsScalarFieldEnum[]
  }


  /**
   * sheets findMany
   */
  export type sheetsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets
     */
    select?: sheetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheetsInclude<ExtArgs> | null
    /**
     * Filter, which sheets to fetch.
     */
    where?: sheetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sheets to fetch.
     */
    orderBy?: sheetsOrderByWithRelationInput | sheetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sheets.
     */
    cursor?: sheetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sheets.
     */
    skip?: number
    distinct?: SheetsScalarFieldEnum | SheetsScalarFieldEnum[]
  }


  /**
   * sheets create
   */
  export type sheetsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets
     */
    select?: sheetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheetsInclude<ExtArgs> | null
    /**
     * The data needed to create a sheets.
     */
    data: XOR<sheetsCreateInput, sheetsUncheckedCreateInput>
  }


  /**
   * sheets createMany
   */
  export type sheetsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sheets.
     */
    data: sheetsCreateManyInput | sheetsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * sheets update
   */
  export type sheetsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets
     */
    select?: sheetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheetsInclude<ExtArgs> | null
    /**
     * The data needed to update a sheets.
     */
    data: XOR<sheetsUpdateInput, sheetsUncheckedUpdateInput>
    /**
     * Choose, which sheets to update.
     */
    where: sheetsWhereUniqueInput
  }


  /**
   * sheets updateMany
   */
  export type sheetsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sheets.
     */
    data: XOR<sheetsUpdateManyMutationInput, sheetsUncheckedUpdateManyInput>
    /**
     * Filter which sheets to update
     */
    where?: sheetsWhereInput
  }


  /**
   * sheets upsert
   */
  export type sheetsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets
     */
    select?: sheetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheetsInclude<ExtArgs> | null
    /**
     * The filter to search for the sheets to update in case it exists.
     */
    where: sheetsWhereUniqueInput
    /**
     * In case the sheets found by the `where` argument doesn't exist, create a new sheets with this data.
     */
    create: XOR<sheetsCreateInput, sheetsUncheckedCreateInput>
    /**
     * In case the sheets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sheetsUpdateInput, sheetsUncheckedUpdateInput>
  }


  /**
   * sheets delete
   */
  export type sheetsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets
     */
    select?: sheetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheetsInclude<ExtArgs> | null
    /**
     * Filter which sheets to delete.
     */
    where: sheetsWhereUniqueInput
  }


  /**
   * sheets deleteMany
   */
  export type sheetsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sheets to delete
     */
    where?: sheetsWhereInput
  }


  /**
   * sheets.sheets_thumbnails
   */
  export type sheets$sheets_thumbnailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets_thumbnails
     */
    select?: sheets_thumbnailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheets_thumbnailsInclude<ExtArgs> | null
    where?: sheets_thumbnailsWhereInput
  }


  /**
   * sheets without action
   */
  export type sheetsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets
     */
    select?: sheetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheetsInclude<ExtArgs> | null
  }



  /**
   * Model sheets_data
   */

  export type AggregateSheets_data = {
    _count: Sheets_dataCountAggregateOutputType | null
    _min: Sheets_dataMinAggregateOutputType | null
    _max: Sheets_dataMaxAggregateOutputType | null
  }

  export type Sheets_dataMinAggregateOutputType = {
    sheet_data_id: string | null
    sheet_data: Buffer | null
  }

  export type Sheets_dataMaxAggregateOutputType = {
    sheet_data_id: string | null
    sheet_data: Buffer | null
  }

  export type Sheets_dataCountAggregateOutputType = {
    sheet_data_id: number
    sheet_data: number
    _all: number
  }


  export type Sheets_dataMinAggregateInputType = {
    sheet_data_id?: true
    sheet_data?: true
  }

  export type Sheets_dataMaxAggregateInputType = {
    sheet_data_id?: true
    sheet_data?: true
  }

  export type Sheets_dataCountAggregateInputType = {
    sheet_data_id?: true
    sheet_data?: true
    _all?: true
  }

  export type Sheets_dataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sheets_data to aggregate.
     */
    where?: sheets_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sheets_data to fetch.
     */
    orderBy?: sheets_dataOrderByWithRelationInput | sheets_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sheets_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sheets_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sheets_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sheets_data
    **/
    _count?: true | Sheets_dataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sheets_dataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sheets_dataMaxAggregateInputType
  }

  export type GetSheets_dataAggregateType<T extends Sheets_dataAggregateArgs> = {
        [P in keyof T & keyof AggregateSheets_data]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSheets_data[P]>
      : GetScalarType<T[P], AggregateSheets_data[P]>
  }




  export type sheets_dataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sheets_dataWhereInput
    orderBy?: sheets_dataOrderByWithAggregationInput | sheets_dataOrderByWithAggregationInput[]
    by: Sheets_dataScalarFieldEnum[] | Sheets_dataScalarFieldEnum
    having?: sheets_dataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sheets_dataCountAggregateInputType | true
    _min?: Sheets_dataMinAggregateInputType
    _max?: Sheets_dataMaxAggregateInputType
  }

  export type Sheets_dataGroupByOutputType = {
    sheet_data_id: string
    sheet_data: Buffer
    _count: Sheets_dataCountAggregateOutputType | null
    _min: Sheets_dataMinAggregateOutputType | null
    _max: Sheets_dataMaxAggregateOutputType | null
  }

  type GetSheets_dataGroupByPayload<T extends sheets_dataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sheets_dataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sheets_dataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sheets_dataGroupByOutputType[P]>
            : GetScalarType<T[P], Sheets_dataGroupByOutputType[P]>
        }
      >
    >


  export type sheets_dataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sheet_data_id?: boolean
    sheet_data?: boolean
    sheets?: boolean | sheets_data$sheetsArgs<ExtArgs>
    _count?: boolean | Sheets_dataCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sheets_data"]>

  export type sheets_dataSelectScalar = {
    sheet_data_id?: boolean
    sheet_data?: boolean
  }

  export type sheets_dataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sheets?: boolean | sheets_data$sheetsArgs<ExtArgs>
    _count?: boolean | Sheets_dataCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $sheets_dataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sheets_data"
    objects: {
      sheets: Prisma.$sheetsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      sheet_data_id: string
      sheet_data: Buffer
    }, ExtArgs["result"]["sheets_data"]>
    composites: {}
  }


  type sheets_dataGetPayload<S extends boolean | null | undefined | sheets_dataDefaultArgs> = $Result.GetResult<Prisma.$sheets_dataPayload, S>

  type sheets_dataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<sheets_dataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Sheets_dataCountAggregateInputType | true
    }

  export interface sheets_dataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sheets_data'], meta: { name: 'sheets_data' } }
    /**
     * Find zero or one Sheets_data that matches the filter.
     * @param {sheets_dataFindUniqueArgs} args - Arguments to find a Sheets_data
     * @example
     * // Get one Sheets_data
     * const sheets_data = await prisma.sheets_data.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sheets_dataFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, sheets_dataFindUniqueArgs<ExtArgs>>
    ): Prisma__sheets_dataClient<$Result.GetResult<Prisma.$sheets_dataPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Sheets_data that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {sheets_dataFindUniqueOrThrowArgs} args - Arguments to find a Sheets_data
     * @example
     * // Get one Sheets_data
     * const sheets_data = await prisma.sheets_data.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends sheets_dataFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sheets_dataFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__sheets_dataClient<$Result.GetResult<Prisma.$sheets_dataPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Sheets_data that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sheets_dataFindFirstArgs} args - Arguments to find a Sheets_data
     * @example
     * // Get one Sheets_data
     * const sheets_data = await prisma.sheets_data.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sheets_dataFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, sheets_dataFindFirstArgs<ExtArgs>>
    ): Prisma__sheets_dataClient<$Result.GetResult<Prisma.$sheets_dataPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Sheets_data that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sheets_dataFindFirstOrThrowArgs} args - Arguments to find a Sheets_data
     * @example
     * // Get one Sheets_data
     * const sheets_data = await prisma.sheets_data.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends sheets_dataFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sheets_dataFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__sheets_dataClient<$Result.GetResult<Prisma.$sheets_dataPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Sheets_data that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sheets_dataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sheets_data
     * const sheets_data = await prisma.sheets_data.findMany()
     * 
     * // Get first 10 Sheets_data
     * const sheets_data = await prisma.sheets_data.findMany({ take: 10 })
     * 
     * // Only select the `sheet_data_id`
     * const sheets_dataWithSheet_data_idOnly = await prisma.sheets_data.findMany({ select: { sheet_data_id: true } })
     * 
    **/
    findMany<T extends sheets_dataFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sheets_dataFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sheets_dataPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Sheets_data.
     * @param {sheets_dataCreateArgs} args - Arguments to create a Sheets_data.
     * @example
     * // Create one Sheets_data
     * const Sheets_data = await prisma.sheets_data.create({
     *   data: {
     *     // ... data to create a Sheets_data
     *   }
     * })
     * 
    **/
    create<T extends sheets_dataCreateArgs<ExtArgs>>(
      args: SelectSubset<T, sheets_dataCreateArgs<ExtArgs>>
    ): Prisma__sheets_dataClient<$Result.GetResult<Prisma.$sheets_dataPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Sheets_data.
     *     @param {sheets_dataCreateManyArgs} args - Arguments to create many Sheets_data.
     *     @example
     *     // Create many Sheets_data
     *     const sheets_data = await prisma.sheets_data.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends sheets_dataCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sheets_dataCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sheets_data.
     * @param {sheets_dataDeleteArgs} args - Arguments to delete one Sheets_data.
     * @example
     * // Delete one Sheets_data
     * const Sheets_data = await prisma.sheets_data.delete({
     *   where: {
     *     // ... filter to delete one Sheets_data
     *   }
     * })
     * 
    **/
    delete<T extends sheets_dataDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, sheets_dataDeleteArgs<ExtArgs>>
    ): Prisma__sheets_dataClient<$Result.GetResult<Prisma.$sheets_dataPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Sheets_data.
     * @param {sheets_dataUpdateArgs} args - Arguments to update one Sheets_data.
     * @example
     * // Update one Sheets_data
     * const sheets_data = await prisma.sheets_data.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sheets_dataUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, sheets_dataUpdateArgs<ExtArgs>>
    ): Prisma__sheets_dataClient<$Result.GetResult<Prisma.$sheets_dataPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Sheets_data.
     * @param {sheets_dataDeleteManyArgs} args - Arguments to filter Sheets_data to delete.
     * @example
     * // Delete a few Sheets_data
     * const { count } = await prisma.sheets_data.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sheets_dataDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sheets_dataDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sheets_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sheets_dataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sheets_data
     * const sheets_data = await prisma.sheets_data.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sheets_dataUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, sheets_dataUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sheets_data.
     * @param {sheets_dataUpsertArgs} args - Arguments to update or create a Sheets_data.
     * @example
     * // Update or create a Sheets_data
     * const sheets_data = await prisma.sheets_data.upsert({
     *   create: {
     *     // ... data to create a Sheets_data
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sheets_data we want to update
     *   }
     * })
    **/
    upsert<T extends sheets_dataUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, sheets_dataUpsertArgs<ExtArgs>>
    ): Prisma__sheets_dataClient<$Result.GetResult<Prisma.$sheets_dataPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Sheets_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sheets_dataCountArgs} args - Arguments to filter Sheets_data to count.
     * @example
     * // Count the number of Sheets_data
     * const count = await prisma.sheets_data.count({
     *   where: {
     *     // ... the filter for the Sheets_data we want to count
     *   }
     * })
    **/
    count<T extends sheets_dataCountArgs>(
      args?: Subset<T, sheets_dataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sheets_dataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sheets_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sheets_dataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sheets_dataAggregateArgs>(args: Subset<T, Sheets_dataAggregateArgs>): Prisma.PrismaPromise<GetSheets_dataAggregateType<T>>

    /**
     * Group by Sheets_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sheets_dataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sheets_dataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sheets_dataGroupByArgs['orderBy'] }
        : { orderBy?: sheets_dataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sheets_dataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSheets_dataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sheets_data model
   */
  readonly fields: sheets_dataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sheets_data.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sheets_dataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    sheets<T extends sheets_data$sheetsArgs<ExtArgs> = {}>(args?: Subset<T, sheets_data$sheetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sheetsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the sheets_data model
   */ 
  interface sheets_dataFieldRefs {
    readonly sheet_data_id: FieldRef<"sheets_data", 'String'>
    readonly sheet_data: FieldRef<"sheets_data", 'Bytes'>
  }
    

  // Custom InputTypes

  /**
   * sheets_data findUnique
   */
  export type sheets_dataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets_data
     */
    select?: sheets_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheets_dataInclude<ExtArgs> | null
    /**
     * Filter, which sheets_data to fetch.
     */
    where: sheets_dataWhereUniqueInput
  }


  /**
   * sheets_data findUniqueOrThrow
   */
  export type sheets_dataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets_data
     */
    select?: sheets_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheets_dataInclude<ExtArgs> | null
    /**
     * Filter, which sheets_data to fetch.
     */
    where: sheets_dataWhereUniqueInput
  }


  /**
   * sheets_data findFirst
   */
  export type sheets_dataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets_data
     */
    select?: sheets_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheets_dataInclude<ExtArgs> | null
    /**
     * Filter, which sheets_data to fetch.
     */
    where?: sheets_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sheets_data to fetch.
     */
    orderBy?: sheets_dataOrderByWithRelationInput | sheets_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sheets_data.
     */
    cursor?: sheets_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sheets_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sheets_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sheets_data.
     */
    distinct?: Sheets_dataScalarFieldEnum | Sheets_dataScalarFieldEnum[]
  }


  /**
   * sheets_data findFirstOrThrow
   */
  export type sheets_dataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets_data
     */
    select?: sheets_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheets_dataInclude<ExtArgs> | null
    /**
     * Filter, which sheets_data to fetch.
     */
    where?: sheets_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sheets_data to fetch.
     */
    orderBy?: sheets_dataOrderByWithRelationInput | sheets_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sheets_data.
     */
    cursor?: sheets_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sheets_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sheets_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sheets_data.
     */
    distinct?: Sheets_dataScalarFieldEnum | Sheets_dataScalarFieldEnum[]
  }


  /**
   * sheets_data findMany
   */
  export type sheets_dataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets_data
     */
    select?: sheets_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheets_dataInclude<ExtArgs> | null
    /**
     * Filter, which sheets_data to fetch.
     */
    where?: sheets_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sheets_data to fetch.
     */
    orderBy?: sheets_dataOrderByWithRelationInput | sheets_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sheets_data.
     */
    cursor?: sheets_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sheets_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sheets_data.
     */
    skip?: number
    distinct?: Sheets_dataScalarFieldEnum | Sheets_dataScalarFieldEnum[]
  }


  /**
   * sheets_data create
   */
  export type sheets_dataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets_data
     */
    select?: sheets_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheets_dataInclude<ExtArgs> | null
    /**
     * The data needed to create a sheets_data.
     */
    data: XOR<sheets_dataCreateInput, sheets_dataUncheckedCreateInput>
  }


  /**
   * sheets_data createMany
   */
  export type sheets_dataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sheets_data.
     */
    data: sheets_dataCreateManyInput | sheets_dataCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * sheets_data update
   */
  export type sheets_dataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets_data
     */
    select?: sheets_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheets_dataInclude<ExtArgs> | null
    /**
     * The data needed to update a sheets_data.
     */
    data: XOR<sheets_dataUpdateInput, sheets_dataUncheckedUpdateInput>
    /**
     * Choose, which sheets_data to update.
     */
    where: sheets_dataWhereUniqueInput
  }


  /**
   * sheets_data updateMany
   */
  export type sheets_dataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sheets_data.
     */
    data: XOR<sheets_dataUpdateManyMutationInput, sheets_dataUncheckedUpdateManyInput>
    /**
     * Filter which sheets_data to update
     */
    where?: sheets_dataWhereInput
  }


  /**
   * sheets_data upsert
   */
  export type sheets_dataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets_data
     */
    select?: sheets_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheets_dataInclude<ExtArgs> | null
    /**
     * The filter to search for the sheets_data to update in case it exists.
     */
    where: sheets_dataWhereUniqueInput
    /**
     * In case the sheets_data found by the `where` argument doesn't exist, create a new sheets_data with this data.
     */
    create: XOR<sheets_dataCreateInput, sheets_dataUncheckedCreateInput>
    /**
     * In case the sheets_data was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sheets_dataUpdateInput, sheets_dataUncheckedUpdateInput>
  }


  /**
   * sheets_data delete
   */
  export type sheets_dataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets_data
     */
    select?: sheets_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheets_dataInclude<ExtArgs> | null
    /**
     * Filter which sheets_data to delete.
     */
    where: sheets_dataWhereUniqueInput
  }


  /**
   * sheets_data deleteMany
   */
  export type sheets_dataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sheets_data to delete
     */
    where?: sheets_dataWhereInput
  }


  /**
   * sheets_data.sheets
   */
  export type sheets_data$sheetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets
     */
    select?: sheetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheetsInclude<ExtArgs> | null
    where?: sheetsWhereInput
    orderBy?: sheetsOrderByWithRelationInput | sheetsOrderByWithRelationInput[]
    cursor?: sheetsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SheetsScalarFieldEnum | SheetsScalarFieldEnum[]
  }


  /**
   * sheets_data without action
   */
  export type sheets_dataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets_data
     */
    select?: sheets_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheets_dataInclude<ExtArgs> | null
  }



  /**
   * Model sheets_thumbnails
   */

  export type AggregateSheets_thumbnails = {
    _count: Sheets_thumbnailsCountAggregateOutputType | null
    _min: Sheets_thumbnailsMinAggregateOutputType | null
    _max: Sheets_thumbnailsMaxAggregateOutputType | null
  }

  export type Sheets_thumbnailsMinAggregateOutputType = {
    sheet_thumbnail_id: string | null
    sheet_thumbnail_data: Buffer | null
    sheet_thumbnail_filename: string | null
    sheet_thumbnail_description: string | null
  }

  export type Sheets_thumbnailsMaxAggregateOutputType = {
    sheet_thumbnail_id: string | null
    sheet_thumbnail_data: Buffer | null
    sheet_thumbnail_filename: string | null
    sheet_thumbnail_description: string | null
  }

  export type Sheets_thumbnailsCountAggregateOutputType = {
    sheet_thumbnail_id: number
    sheet_thumbnail_data: number
    sheet_thumbnail_filename: number
    sheet_thumbnail_description: number
    _all: number
  }


  export type Sheets_thumbnailsMinAggregateInputType = {
    sheet_thumbnail_id?: true
    sheet_thumbnail_data?: true
    sheet_thumbnail_filename?: true
    sheet_thumbnail_description?: true
  }

  export type Sheets_thumbnailsMaxAggregateInputType = {
    sheet_thumbnail_id?: true
    sheet_thumbnail_data?: true
    sheet_thumbnail_filename?: true
    sheet_thumbnail_description?: true
  }

  export type Sheets_thumbnailsCountAggregateInputType = {
    sheet_thumbnail_id?: true
    sheet_thumbnail_data?: true
    sheet_thumbnail_filename?: true
    sheet_thumbnail_description?: true
    _all?: true
  }

  export type Sheets_thumbnailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sheets_thumbnails to aggregate.
     */
    where?: sheets_thumbnailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sheets_thumbnails to fetch.
     */
    orderBy?: sheets_thumbnailsOrderByWithRelationInput | sheets_thumbnailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sheets_thumbnailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sheets_thumbnails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sheets_thumbnails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sheets_thumbnails
    **/
    _count?: true | Sheets_thumbnailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sheets_thumbnailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sheets_thumbnailsMaxAggregateInputType
  }

  export type GetSheets_thumbnailsAggregateType<T extends Sheets_thumbnailsAggregateArgs> = {
        [P in keyof T & keyof AggregateSheets_thumbnails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSheets_thumbnails[P]>
      : GetScalarType<T[P], AggregateSheets_thumbnails[P]>
  }




  export type sheets_thumbnailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sheets_thumbnailsWhereInput
    orderBy?: sheets_thumbnailsOrderByWithAggregationInput | sheets_thumbnailsOrderByWithAggregationInput[]
    by: Sheets_thumbnailsScalarFieldEnum[] | Sheets_thumbnailsScalarFieldEnum
    having?: sheets_thumbnailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sheets_thumbnailsCountAggregateInputType | true
    _min?: Sheets_thumbnailsMinAggregateInputType
    _max?: Sheets_thumbnailsMaxAggregateInputType
  }

  export type Sheets_thumbnailsGroupByOutputType = {
    sheet_thumbnail_id: string
    sheet_thumbnail_data: Buffer
    sheet_thumbnail_filename: string
    sheet_thumbnail_description: string | null
    _count: Sheets_thumbnailsCountAggregateOutputType | null
    _min: Sheets_thumbnailsMinAggregateOutputType | null
    _max: Sheets_thumbnailsMaxAggregateOutputType | null
  }

  type GetSheets_thumbnailsGroupByPayload<T extends sheets_thumbnailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sheets_thumbnailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sheets_thumbnailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sheets_thumbnailsGroupByOutputType[P]>
            : GetScalarType<T[P], Sheets_thumbnailsGroupByOutputType[P]>
        }
      >
    >


  export type sheets_thumbnailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sheet_thumbnail_id?: boolean
    sheet_thumbnail_data?: boolean
    sheet_thumbnail_filename?: boolean
    sheet_thumbnail_description?: boolean
    sheets?: boolean | sheets_thumbnails$sheetsArgs<ExtArgs>
    _count?: boolean | Sheets_thumbnailsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sheets_thumbnails"]>

  export type sheets_thumbnailsSelectScalar = {
    sheet_thumbnail_id?: boolean
    sheet_thumbnail_data?: boolean
    sheet_thumbnail_filename?: boolean
    sheet_thumbnail_description?: boolean
  }

  export type sheets_thumbnailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sheets?: boolean | sheets_thumbnails$sheetsArgs<ExtArgs>
    _count?: boolean | Sheets_thumbnailsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $sheets_thumbnailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sheets_thumbnails"
    objects: {
      sheets: Prisma.$sheetsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      sheet_thumbnail_id: string
      sheet_thumbnail_data: Buffer
      sheet_thumbnail_filename: string
      sheet_thumbnail_description: string | null
    }, ExtArgs["result"]["sheets_thumbnails"]>
    composites: {}
  }


  type sheets_thumbnailsGetPayload<S extends boolean | null | undefined | sheets_thumbnailsDefaultArgs> = $Result.GetResult<Prisma.$sheets_thumbnailsPayload, S>

  type sheets_thumbnailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<sheets_thumbnailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Sheets_thumbnailsCountAggregateInputType | true
    }

  export interface sheets_thumbnailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sheets_thumbnails'], meta: { name: 'sheets_thumbnails' } }
    /**
     * Find zero or one Sheets_thumbnails that matches the filter.
     * @param {sheets_thumbnailsFindUniqueArgs} args - Arguments to find a Sheets_thumbnails
     * @example
     * // Get one Sheets_thumbnails
     * const sheets_thumbnails = await prisma.sheets_thumbnails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sheets_thumbnailsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, sheets_thumbnailsFindUniqueArgs<ExtArgs>>
    ): Prisma__sheets_thumbnailsClient<$Result.GetResult<Prisma.$sheets_thumbnailsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Sheets_thumbnails that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {sheets_thumbnailsFindUniqueOrThrowArgs} args - Arguments to find a Sheets_thumbnails
     * @example
     * // Get one Sheets_thumbnails
     * const sheets_thumbnails = await prisma.sheets_thumbnails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends sheets_thumbnailsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sheets_thumbnailsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__sheets_thumbnailsClient<$Result.GetResult<Prisma.$sheets_thumbnailsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Sheets_thumbnails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sheets_thumbnailsFindFirstArgs} args - Arguments to find a Sheets_thumbnails
     * @example
     * // Get one Sheets_thumbnails
     * const sheets_thumbnails = await prisma.sheets_thumbnails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sheets_thumbnailsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, sheets_thumbnailsFindFirstArgs<ExtArgs>>
    ): Prisma__sheets_thumbnailsClient<$Result.GetResult<Prisma.$sheets_thumbnailsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Sheets_thumbnails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sheets_thumbnailsFindFirstOrThrowArgs} args - Arguments to find a Sheets_thumbnails
     * @example
     * // Get one Sheets_thumbnails
     * const sheets_thumbnails = await prisma.sheets_thumbnails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends sheets_thumbnailsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sheets_thumbnailsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__sheets_thumbnailsClient<$Result.GetResult<Prisma.$sheets_thumbnailsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Sheets_thumbnails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sheets_thumbnailsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sheets_thumbnails
     * const sheets_thumbnails = await prisma.sheets_thumbnails.findMany()
     * 
     * // Get first 10 Sheets_thumbnails
     * const sheets_thumbnails = await prisma.sheets_thumbnails.findMany({ take: 10 })
     * 
     * // Only select the `sheet_thumbnail_id`
     * const sheets_thumbnailsWithSheet_thumbnail_idOnly = await prisma.sheets_thumbnails.findMany({ select: { sheet_thumbnail_id: true } })
     * 
    **/
    findMany<T extends sheets_thumbnailsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sheets_thumbnailsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sheets_thumbnailsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Sheets_thumbnails.
     * @param {sheets_thumbnailsCreateArgs} args - Arguments to create a Sheets_thumbnails.
     * @example
     * // Create one Sheets_thumbnails
     * const Sheets_thumbnails = await prisma.sheets_thumbnails.create({
     *   data: {
     *     // ... data to create a Sheets_thumbnails
     *   }
     * })
     * 
    **/
    create<T extends sheets_thumbnailsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, sheets_thumbnailsCreateArgs<ExtArgs>>
    ): Prisma__sheets_thumbnailsClient<$Result.GetResult<Prisma.$sheets_thumbnailsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Sheets_thumbnails.
     *     @param {sheets_thumbnailsCreateManyArgs} args - Arguments to create many Sheets_thumbnails.
     *     @example
     *     // Create many Sheets_thumbnails
     *     const sheets_thumbnails = await prisma.sheets_thumbnails.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends sheets_thumbnailsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sheets_thumbnailsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sheets_thumbnails.
     * @param {sheets_thumbnailsDeleteArgs} args - Arguments to delete one Sheets_thumbnails.
     * @example
     * // Delete one Sheets_thumbnails
     * const Sheets_thumbnails = await prisma.sheets_thumbnails.delete({
     *   where: {
     *     // ... filter to delete one Sheets_thumbnails
     *   }
     * })
     * 
    **/
    delete<T extends sheets_thumbnailsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, sheets_thumbnailsDeleteArgs<ExtArgs>>
    ): Prisma__sheets_thumbnailsClient<$Result.GetResult<Prisma.$sheets_thumbnailsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Sheets_thumbnails.
     * @param {sheets_thumbnailsUpdateArgs} args - Arguments to update one Sheets_thumbnails.
     * @example
     * // Update one Sheets_thumbnails
     * const sheets_thumbnails = await prisma.sheets_thumbnails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sheets_thumbnailsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, sheets_thumbnailsUpdateArgs<ExtArgs>>
    ): Prisma__sheets_thumbnailsClient<$Result.GetResult<Prisma.$sheets_thumbnailsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Sheets_thumbnails.
     * @param {sheets_thumbnailsDeleteManyArgs} args - Arguments to filter Sheets_thumbnails to delete.
     * @example
     * // Delete a few Sheets_thumbnails
     * const { count } = await prisma.sheets_thumbnails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sheets_thumbnailsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sheets_thumbnailsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sheets_thumbnails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sheets_thumbnailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sheets_thumbnails
     * const sheets_thumbnails = await prisma.sheets_thumbnails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sheets_thumbnailsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, sheets_thumbnailsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sheets_thumbnails.
     * @param {sheets_thumbnailsUpsertArgs} args - Arguments to update or create a Sheets_thumbnails.
     * @example
     * // Update or create a Sheets_thumbnails
     * const sheets_thumbnails = await prisma.sheets_thumbnails.upsert({
     *   create: {
     *     // ... data to create a Sheets_thumbnails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sheets_thumbnails we want to update
     *   }
     * })
    **/
    upsert<T extends sheets_thumbnailsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, sheets_thumbnailsUpsertArgs<ExtArgs>>
    ): Prisma__sheets_thumbnailsClient<$Result.GetResult<Prisma.$sheets_thumbnailsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Sheets_thumbnails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sheets_thumbnailsCountArgs} args - Arguments to filter Sheets_thumbnails to count.
     * @example
     * // Count the number of Sheets_thumbnails
     * const count = await prisma.sheets_thumbnails.count({
     *   where: {
     *     // ... the filter for the Sheets_thumbnails we want to count
     *   }
     * })
    **/
    count<T extends sheets_thumbnailsCountArgs>(
      args?: Subset<T, sheets_thumbnailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sheets_thumbnailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sheets_thumbnails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sheets_thumbnailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sheets_thumbnailsAggregateArgs>(args: Subset<T, Sheets_thumbnailsAggregateArgs>): Prisma.PrismaPromise<GetSheets_thumbnailsAggregateType<T>>

    /**
     * Group by Sheets_thumbnails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sheets_thumbnailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sheets_thumbnailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sheets_thumbnailsGroupByArgs['orderBy'] }
        : { orderBy?: sheets_thumbnailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sheets_thumbnailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSheets_thumbnailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sheets_thumbnails model
   */
  readonly fields: sheets_thumbnailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sheets_thumbnails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sheets_thumbnailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    sheets<T extends sheets_thumbnails$sheetsArgs<ExtArgs> = {}>(args?: Subset<T, sheets_thumbnails$sheetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sheetsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the sheets_thumbnails model
   */ 
  interface sheets_thumbnailsFieldRefs {
    readonly sheet_thumbnail_id: FieldRef<"sheets_thumbnails", 'String'>
    readonly sheet_thumbnail_data: FieldRef<"sheets_thumbnails", 'Bytes'>
    readonly sheet_thumbnail_filename: FieldRef<"sheets_thumbnails", 'String'>
    readonly sheet_thumbnail_description: FieldRef<"sheets_thumbnails", 'String'>
  }
    

  // Custom InputTypes

  /**
   * sheets_thumbnails findUnique
   */
  export type sheets_thumbnailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets_thumbnails
     */
    select?: sheets_thumbnailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheets_thumbnailsInclude<ExtArgs> | null
    /**
     * Filter, which sheets_thumbnails to fetch.
     */
    where: sheets_thumbnailsWhereUniqueInput
  }


  /**
   * sheets_thumbnails findUniqueOrThrow
   */
  export type sheets_thumbnailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets_thumbnails
     */
    select?: sheets_thumbnailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheets_thumbnailsInclude<ExtArgs> | null
    /**
     * Filter, which sheets_thumbnails to fetch.
     */
    where: sheets_thumbnailsWhereUniqueInput
  }


  /**
   * sheets_thumbnails findFirst
   */
  export type sheets_thumbnailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets_thumbnails
     */
    select?: sheets_thumbnailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheets_thumbnailsInclude<ExtArgs> | null
    /**
     * Filter, which sheets_thumbnails to fetch.
     */
    where?: sheets_thumbnailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sheets_thumbnails to fetch.
     */
    orderBy?: sheets_thumbnailsOrderByWithRelationInput | sheets_thumbnailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sheets_thumbnails.
     */
    cursor?: sheets_thumbnailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sheets_thumbnails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sheets_thumbnails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sheets_thumbnails.
     */
    distinct?: Sheets_thumbnailsScalarFieldEnum | Sheets_thumbnailsScalarFieldEnum[]
  }


  /**
   * sheets_thumbnails findFirstOrThrow
   */
  export type sheets_thumbnailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets_thumbnails
     */
    select?: sheets_thumbnailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheets_thumbnailsInclude<ExtArgs> | null
    /**
     * Filter, which sheets_thumbnails to fetch.
     */
    where?: sheets_thumbnailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sheets_thumbnails to fetch.
     */
    orderBy?: sheets_thumbnailsOrderByWithRelationInput | sheets_thumbnailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sheets_thumbnails.
     */
    cursor?: sheets_thumbnailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sheets_thumbnails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sheets_thumbnails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sheets_thumbnails.
     */
    distinct?: Sheets_thumbnailsScalarFieldEnum | Sheets_thumbnailsScalarFieldEnum[]
  }


  /**
   * sheets_thumbnails findMany
   */
  export type sheets_thumbnailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets_thumbnails
     */
    select?: sheets_thumbnailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheets_thumbnailsInclude<ExtArgs> | null
    /**
     * Filter, which sheets_thumbnails to fetch.
     */
    where?: sheets_thumbnailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sheets_thumbnails to fetch.
     */
    orderBy?: sheets_thumbnailsOrderByWithRelationInput | sheets_thumbnailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sheets_thumbnails.
     */
    cursor?: sheets_thumbnailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sheets_thumbnails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sheets_thumbnails.
     */
    skip?: number
    distinct?: Sheets_thumbnailsScalarFieldEnum | Sheets_thumbnailsScalarFieldEnum[]
  }


  /**
   * sheets_thumbnails create
   */
  export type sheets_thumbnailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets_thumbnails
     */
    select?: sheets_thumbnailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheets_thumbnailsInclude<ExtArgs> | null
    /**
     * The data needed to create a sheets_thumbnails.
     */
    data: XOR<sheets_thumbnailsCreateInput, sheets_thumbnailsUncheckedCreateInput>
  }


  /**
   * sheets_thumbnails createMany
   */
  export type sheets_thumbnailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sheets_thumbnails.
     */
    data: sheets_thumbnailsCreateManyInput | sheets_thumbnailsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * sheets_thumbnails update
   */
  export type sheets_thumbnailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets_thumbnails
     */
    select?: sheets_thumbnailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheets_thumbnailsInclude<ExtArgs> | null
    /**
     * The data needed to update a sheets_thumbnails.
     */
    data: XOR<sheets_thumbnailsUpdateInput, sheets_thumbnailsUncheckedUpdateInput>
    /**
     * Choose, which sheets_thumbnails to update.
     */
    where: sheets_thumbnailsWhereUniqueInput
  }


  /**
   * sheets_thumbnails updateMany
   */
  export type sheets_thumbnailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sheets_thumbnails.
     */
    data: XOR<sheets_thumbnailsUpdateManyMutationInput, sheets_thumbnailsUncheckedUpdateManyInput>
    /**
     * Filter which sheets_thumbnails to update
     */
    where?: sheets_thumbnailsWhereInput
  }


  /**
   * sheets_thumbnails upsert
   */
  export type sheets_thumbnailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets_thumbnails
     */
    select?: sheets_thumbnailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheets_thumbnailsInclude<ExtArgs> | null
    /**
     * The filter to search for the sheets_thumbnails to update in case it exists.
     */
    where: sheets_thumbnailsWhereUniqueInput
    /**
     * In case the sheets_thumbnails found by the `where` argument doesn't exist, create a new sheets_thumbnails with this data.
     */
    create: XOR<sheets_thumbnailsCreateInput, sheets_thumbnailsUncheckedCreateInput>
    /**
     * In case the sheets_thumbnails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sheets_thumbnailsUpdateInput, sheets_thumbnailsUncheckedUpdateInput>
  }


  /**
   * sheets_thumbnails delete
   */
  export type sheets_thumbnailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets_thumbnails
     */
    select?: sheets_thumbnailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheets_thumbnailsInclude<ExtArgs> | null
    /**
     * Filter which sheets_thumbnails to delete.
     */
    where: sheets_thumbnailsWhereUniqueInput
  }


  /**
   * sheets_thumbnails deleteMany
   */
  export type sheets_thumbnailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sheets_thumbnails to delete
     */
    where?: sheets_thumbnailsWhereInput
  }


  /**
   * sheets_thumbnails.sheets
   */
  export type sheets_thumbnails$sheetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets
     */
    select?: sheetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheetsInclude<ExtArgs> | null
    where?: sheetsWhereInput
    orderBy?: sheetsOrderByWithRelationInput | sheetsOrderByWithRelationInput[]
    cursor?: sheetsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SheetsScalarFieldEnum | SheetsScalarFieldEnum[]
  }


  /**
   * sheets_thumbnails without action
   */
  export type sheets_thumbnailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sheets_thumbnails
     */
    select?: sheets_thumbnailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sheets_thumbnailsInclude<ExtArgs> | null
  }



  /**
   * Model tables
   */

  export type AggregateTables = {
    _count: TablesCountAggregateOutputType | null
    _min: TablesMinAggregateOutputType | null
    _max: TablesMaxAggregateOutputType | null
  }

  export type TablesMinAggregateOutputType = {
    table_id: string | null
    table_name: string | null
    table_creation_date: Date | null
    last_message: string | null
    last_message_date: Date | null
    tables_pictures_id: string | null
  }

  export type TablesMaxAggregateOutputType = {
    table_id: string | null
    table_name: string | null
    table_creation_date: Date | null
    last_message: string | null
    last_message_date: Date | null
    tables_pictures_id: string | null
  }

  export type TablesCountAggregateOutputType = {
    table_id: number
    table_name: number
    table_creation_date: number
    last_message: number
    last_message_date: number
    tables_pictures_id: number
    _all: number
  }


  export type TablesMinAggregateInputType = {
    table_id?: true
    table_name?: true
    table_creation_date?: true
    last_message?: true
    last_message_date?: true
    tables_pictures_id?: true
  }

  export type TablesMaxAggregateInputType = {
    table_id?: true
    table_name?: true
    table_creation_date?: true
    last_message?: true
    last_message_date?: true
    tables_pictures_id?: true
  }

  export type TablesCountAggregateInputType = {
    table_id?: true
    table_name?: true
    table_creation_date?: true
    last_message?: true
    last_message_date?: true
    tables_pictures_id?: true
    _all?: true
  }

  export type TablesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tables to aggregate.
     */
    where?: tablesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tables to fetch.
     */
    orderBy?: tablesOrderByWithRelationInput | tablesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tablesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tables
    **/
    _count?: true | TablesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TablesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TablesMaxAggregateInputType
  }

  export type GetTablesAggregateType<T extends TablesAggregateArgs> = {
        [P in keyof T & keyof AggregateTables]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTables[P]>
      : GetScalarType<T[P], AggregateTables[P]>
  }




  export type tablesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tablesWhereInput
    orderBy?: tablesOrderByWithAggregationInput | tablesOrderByWithAggregationInput[]
    by: TablesScalarFieldEnum[] | TablesScalarFieldEnum
    having?: tablesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TablesCountAggregateInputType | true
    _min?: TablesMinAggregateInputType
    _max?: TablesMaxAggregateInputType
  }

  export type TablesGroupByOutputType = {
    table_id: string
    table_name: string | null
    table_creation_date: Date
    last_message: string | null
    last_message_date: Date | null
    tables_pictures_id: string | null
    _count: TablesCountAggregateOutputType | null
    _min: TablesMinAggregateOutputType | null
    _max: TablesMaxAggregateOutputType | null
  }

  type GetTablesGroupByPayload<T extends tablesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TablesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TablesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TablesGroupByOutputType[P]>
            : GetScalarType<T[P], TablesGroupByOutputType[P]>
        }
      >
    >


  export type tablesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    table_id?: boolean
    table_name?: boolean
    table_creation_date?: boolean
    last_message?: boolean
    last_message_date?: boolean
    tables_pictures_id?: boolean
    tables_pictures?: boolean | tables$tables_picturesArgs<ExtArgs>
    tables_members?: boolean | tables$tables_membersArgs<ExtArgs>
    tables_messages_logs?: boolean | tables$tables_messages_logsArgs<ExtArgs>
    tables_tabletops?: boolean | tables$tables_tabletopsArgs<ExtArgs>
    _count?: boolean | TablesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tables"]>

  export type tablesSelectScalar = {
    table_id?: boolean
    table_name?: boolean
    table_creation_date?: boolean
    last_message?: boolean
    last_message_date?: boolean
    tables_pictures_id?: boolean
  }

  export type tablesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tables_pictures?: boolean | tables$tables_picturesArgs<ExtArgs>
    tables_members?: boolean | tables$tables_membersArgs<ExtArgs>
    tables_messages_logs?: boolean | tables$tables_messages_logsArgs<ExtArgs>
    tables_tabletops?: boolean | tables$tables_tabletopsArgs<ExtArgs>
    _count?: boolean | TablesCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $tablesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tables"
    objects: {
      tables_pictures: Prisma.$tables_picturesPayload<ExtArgs> | null
      tables_members: Prisma.$tables_membersPayload<ExtArgs>[]
      tables_messages_logs: Prisma.$tables_messages_logsPayload<ExtArgs>[]
      tables_tabletops: Prisma.$tables_tabletopsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      table_id: string
      table_name: string | null
      table_creation_date: Date
      last_message: string | null
      last_message_date: Date | null
      tables_pictures_id: string | null
    }, ExtArgs["result"]["tables"]>
    composites: {}
  }


  type tablesGetPayload<S extends boolean | null | undefined | tablesDefaultArgs> = $Result.GetResult<Prisma.$tablesPayload, S>

  type tablesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tablesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TablesCountAggregateInputType | true
    }

  export interface tablesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tables'], meta: { name: 'tables' } }
    /**
     * Find zero or one Tables that matches the filter.
     * @param {tablesFindUniqueArgs} args - Arguments to find a Tables
     * @example
     * // Get one Tables
     * const tables = await prisma.tables.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tablesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, tablesFindUniqueArgs<ExtArgs>>
    ): Prisma__tablesClient<$Result.GetResult<Prisma.$tablesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tables that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tablesFindUniqueOrThrowArgs} args - Arguments to find a Tables
     * @example
     * // Get one Tables
     * const tables = await prisma.tables.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tablesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tablesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tablesClient<$Result.GetResult<Prisma.$tablesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tablesFindFirstArgs} args - Arguments to find a Tables
     * @example
     * // Get one Tables
     * const tables = await prisma.tables.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tablesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, tablesFindFirstArgs<ExtArgs>>
    ): Prisma__tablesClient<$Result.GetResult<Prisma.$tablesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tables that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tablesFindFirstOrThrowArgs} args - Arguments to find a Tables
     * @example
     * // Get one Tables
     * const tables = await prisma.tables.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tablesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tablesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tablesClient<$Result.GetResult<Prisma.$tablesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tablesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tables
     * const tables = await prisma.tables.findMany()
     * 
     * // Get first 10 Tables
     * const tables = await prisma.tables.findMany({ take: 10 })
     * 
     * // Only select the `table_id`
     * const tablesWithTable_idOnly = await prisma.tables.findMany({ select: { table_id: true } })
     * 
    **/
    findMany<T extends tablesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tablesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tablesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tables.
     * @param {tablesCreateArgs} args - Arguments to create a Tables.
     * @example
     * // Create one Tables
     * const Tables = await prisma.tables.create({
     *   data: {
     *     // ... data to create a Tables
     *   }
     * })
     * 
    **/
    create<T extends tablesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tablesCreateArgs<ExtArgs>>
    ): Prisma__tablesClient<$Result.GetResult<Prisma.$tablesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tables.
     *     @param {tablesCreateManyArgs} args - Arguments to create many Tables.
     *     @example
     *     // Create many Tables
     *     const tables = await prisma.tables.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tablesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tablesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tables.
     * @param {tablesDeleteArgs} args - Arguments to delete one Tables.
     * @example
     * // Delete one Tables
     * const Tables = await prisma.tables.delete({
     *   where: {
     *     // ... filter to delete one Tables
     *   }
     * })
     * 
    **/
    delete<T extends tablesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tablesDeleteArgs<ExtArgs>>
    ): Prisma__tablesClient<$Result.GetResult<Prisma.$tablesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tables.
     * @param {tablesUpdateArgs} args - Arguments to update one Tables.
     * @example
     * // Update one Tables
     * const tables = await prisma.tables.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tablesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tablesUpdateArgs<ExtArgs>>
    ): Prisma__tablesClient<$Result.GetResult<Prisma.$tablesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tables.
     * @param {tablesDeleteManyArgs} args - Arguments to filter Tables to delete.
     * @example
     * // Delete a few Tables
     * const { count } = await prisma.tables.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tablesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tablesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tablesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tables
     * const tables = await prisma.tables.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tablesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tablesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tables.
     * @param {tablesUpsertArgs} args - Arguments to update or create a Tables.
     * @example
     * // Update or create a Tables
     * const tables = await prisma.tables.upsert({
     *   create: {
     *     // ... data to create a Tables
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tables we want to update
     *   }
     * })
    **/
    upsert<T extends tablesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tablesUpsertArgs<ExtArgs>>
    ): Prisma__tablesClient<$Result.GetResult<Prisma.$tablesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tablesCountArgs} args - Arguments to filter Tables to count.
     * @example
     * // Count the number of Tables
     * const count = await prisma.tables.count({
     *   where: {
     *     // ... the filter for the Tables we want to count
     *   }
     * })
    **/
    count<T extends tablesCountArgs>(
      args?: Subset<T, tablesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TablesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TablesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TablesAggregateArgs>(args: Subset<T, TablesAggregateArgs>): Prisma.PrismaPromise<GetTablesAggregateType<T>>

    /**
     * Group by Tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tablesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tablesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tablesGroupByArgs['orderBy'] }
        : { orderBy?: tablesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tablesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTablesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tables model
   */
  readonly fields: tablesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tables.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tablesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tables_pictures<T extends tables$tables_picturesArgs<ExtArgs> = {}>(args?: Subset<T, tables$tables_picturesArgs<ExtArgs>>): Prisma__tables_picturesClient<$Result.GetResult<Prisma.$tables_picturesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    tables_members<T extends tables$tables_membersArgs<ExtArgs> = {}>(args?: Subset<T, tables$tables_membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tables_membersPayload<ExtArgs>, T, 'findMany'> | Null>;

    tables_messages_logs<T extends tables$tables_messages_logsArgs<ExtArgs> = {}>(args?: Subset<T, tables$tables_messages_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tables_messages_logsPayload<ExtArgs>, T, 'findMany'> | Null>;

    tables_tabletops<T extends tables$tables_tabletopsArgs<ExtArgs> = {}>(args?: Subset<T, tables$tables_tabletopsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tables_tabletopsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the tables model
   */ 
  interface tablesFieldRefs {
    readonly table_id: FieldRef<"tables", 'String'>
    readonly table_name: FieldRef<"tables", 'String'>
    readonly table_creation_date: FieldRef<"tables", 'DateTime'>
    readonly last_message: FieldRef<"tables", 'String'>
    readonly last_message_date: FieldRef<"tables", 'DateTime'>
    readonly tables_pictures_id: FieldRef<"tables", 'String'>
  }
    

  // Custom InputTypes

  /**
   * tables findUnique
   */
  export type tablesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables
     */
    select?: tablesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tablesInclude<ExtArgs> | null
    /**
     * Filter, which tables to fetch.
     */
    where: tablesWhereUniqueInput
  }


  /**
   * tables findUniqueOrThrow
   */
  export type tablesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables
     */
    select?: tablesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tablesInclude<ExtArgs> | null
    /**
     * Filter, which tables to fetch.
     */
    where: tablesWhereUniqueInput
  }


  /**
   * tables findFirst
   */
  export type tablesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables
     */
    select?: tablesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tablesInclude<ExtArgs> | null
    /**
     * Filter, which tables to fetch.
     */
    where?: tablesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tables to fetch.
     */
    orderBy?: tablesOrderByWithRelationInput | tablesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tables.
     */
    cursor?: tablesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tables.
     */
    distinct?: TablesScalarFieldEnum | TablesScalarFieldEnum[]
  }


  /**
   * tables findFirstOrThrow
   */
  export type tablesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables
     */
    select?: tablesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tablesInclude<ExtArgs> | null
    /**
     * Filter, which tables to fetch.
     */
    where?: tablesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tables to fetch.
     */
    orderBy?: tablesOrderByWithRelationInput | tablesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tables.
     */
    cursor?: tablesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tables.
     */
    distinct?: TablesScalarFieldEnum | TablesScalarFieldEnum[]
  }


  /**
   * tables findMany
   */
  export type tablesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables
     */
    select?: tablesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tablesInclude<ExtArgs> | null
    /**
     * Filter, which tables to fetch.
     */
    where?: tablesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tables to fetch.
     */
    orderBy?: tablesOrderByWithRelationInput | tablesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tables.
     */
    cursor?: tablesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tables.
     */
    skip?: number
    distinct?: TablesScalarFieldEnum | TablesScalarFieldEnum[]
  }


  /**
   * tables create
   */
  export type tablesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables
     */
    select?: tablesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tablesInclude<ExtArgs> | null
    /**
     * The data needed to create a tables.
     */
    data: XOR<tablesCreateInput, tablesUncheckedCreateInput>
  }


  /**
   * tables createMany
   */
  export type tablesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tables.
     */
    data: tablesCreateManyInput | tablesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tables update
   */
  export type tablesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables
     */
    select?: tablesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tablesInclude<ExtArgs> | null
    /**
     * The data needed to update a tables.
     */
    data: XOR<tablesUpdateInput, tablesUncheckedUpdateInput>
    /**
     * Choose, which tables to update.
     */
    where: tablesWhereUniqueInput
  }


  /**
   * tables updateMany
   */
  export type tablesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tables.
     */
    data: XOR<tablesUpdateManyMutationInput, tablesUncheckedUpdateManyInput>
    /**
     * Filter which tables to update
     */
    where?: tablesWhereInput
  }


  /**
   * tables upsert
   */
  export type tablesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables
     */
    select?: tablesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tablesInclude<ExtArgs> | null
    /**
     * The filter to search for the tables to update in case it exists.
     */
    where: tablesWhereUniqueInput
    /**
     * In case the tables found by the `where` argument doesn't exist, create a new tables with this data.
     */
    create: XOR<tablesCreateInput, tablesUncheckedCreateInput>
    /**
     * In case the tables was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tablesUpdateInput, tablesUncheckedUpdateInput>
  }


  /**
   * tables delete
   */
  export type tablesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables
     */
    select?: tablesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tablesInclude<ExtArgs> | null
    /**
     * Filter which tables to delete.
     */
    where: tablesWhereUniqueInput
  }


  /**
   * tables deleteMany
   */
  export type tablesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tables to delete
     */
    where?: tablesWhereInput
  }


  /**
   * tables.tables_pictures
   */
  export type tables$tables_picturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_pictures
     */
    select?: tables_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_picturesInclude<ExtArgs> | null
    where?: tables_picturesWhereInput
  }


  /**
   * tables.tables_members
   */
  export type tables$tables_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_members
     */
    select?: tables_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_membersInclude<ExtArgs> | null
    where?: tables_membersWhereInput
    orderBy?: tables_membersOrderByWithRelationInput | tables_membersOrderByWithRelationInput[]
    cursor?: tables_membersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tables_membersScalarFieldEnum | Tables_membersScalarFieldEnum[]
  }


  /**
   * tables.tables_messages_logs
   */
  export type tables$tables_messages_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_messages_logs
     */
    select?: tables_messages_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_messages_logsInclude<ExtArgs> | null
    where?: tables_messages_logsWhereInput
    orderBy?: tables_messages_logsOrderByWithRelationInput | tables_messages_logsOrderByWithRelationInput[]
    cursor?: tables_messages_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tables_messages_logsScalarFieldEnum | Tables_messages_logsScalarFieldEnum[]
  }


  /**
   * tables.tables_tabletops
   */
  export type tables$tables_tabletopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_tabletops
     */
    select?: tables_tabletopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_tabletopsInclude<ExtArgs> | null
    where?: tables_tabletopsWhereInput
    orderBy?: tables_tabletopsOrderByWithRelationInput | tables_tabletopsOrderByWithRelationInput[]
    cursor?: tables_tabletopsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tables_tabletopsScalarFieldEnum | Tables_tabletopsScalarFieldEnum[]
  }


  /**
   * tables without action
   */
  export type tablesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables
     */
    select?: tablesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tablesInclude<ExtArgs> | null
  }



  /**
   * Model tables_members
   */

  export type AggregateTables_members = {
    _count: Tables_membersCountAggregateOutputType | null
    _avg: Tables_membersAvgAggregateOutputType | null
    _sum: Tables_membersSumAggregateOutputType | null
    _min: Tables_membersMinAggregateOutputType | null
    _max: Tables_membersMaxAggregateOutputType | null
  }

  export type Tables_membersAvgAggregateOutputType = {
    table_position: number | null
    live: number | null
  }

  export type Tables_membersSumAggregateOutputType = {
    table_position: number | null
    live: number | null
  }

  export type Tables_membersMinAggregateOutputType = {
    tables_members_id: string | null
    table_id: string | null
    member_id: string | null
    table_position: number | null
    live: number | null
  }

  export type Tables_membersMaxAggregateOutputType = {
    tables_members_id: string | null
    table_id: string | null
    member_id: string | null
    table_position: number | null
    live: number | null
  }

  export type Tables_membersCountAggregateOutputType = {
    tables_members_id: number
    table_id: number
    member_id: number
    table_position: number
    live: number
    _all: number
  }


  export type Tables_membersAvgAggregateInputType = {
    table_position?: true
    live?: true
  }

  export type Tables_membersSumAggregateInputType = {
    table_position?: true
    live?: true
  }

  export type Tables_membersMinAggregateInputType = {
    tables_members_id?: true
    table_id?: true
    member_id?: true
    table_position?: true
    live?: true
  }

  export type Tables_membersMaxAggregateInputType = {
    tables_members_id?: true
    table_id?: true
    member_id?: true
    table_position?: true
    live?: true
  }

  export type Tables_membersCountAggregateInputType = {
    tables_members_id?: true
    table_id?: true
    member_id?: true
    table_position?: true
    live?: true
    _all?: true
  }

  export type Tables_membersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tables_members to aggregate.
     */
    where?: tables_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tables_members to fetch.
     */
    orderBy?: tables_membersOrderByWithRelationInput | tables_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tables_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tables_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tables_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tables_members
    **/
    _count?: true | Tables_membersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tables_membersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tables_membersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tables_membersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tables_membersMaxAggregateInputType
  }

  export type GetTables_membersAggregateType<T extends Tables_membersAggregateArgs> = {
        [P in keyof T & keyof AggregateTables_members]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTables_members[P]>
      : GetScalarType<T[P], AggregateTables_members[P]>
  }




  export type tables_membersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tables_membersWhereInput
    orderBy?: tables_membersOrderByWithAggregationInput | tables_membersOrderByWithAggregationInput[]
    by: Tables_membersScalarFieldEnum[] | Tables_membersScalarFieldEnum
    having?: tables_membersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tables_membersCountAggregateInputType | true
    _avg?: Tables_membersAvgAggregateInputType
    _sum?: Tables_membersSumAggregateInputType
    _min?: Tables_membersMinAggregateInputType
    _max?: Tables_membersMaxAggregateInputType
  }

  export type Tables_membersGroupByOutputType = {
    tables_members_id: string
    table_id: string
    member_id: string
    table_position: number
    live: number
    _count: Tables_membersCountAggregateOutputType | null
    _avg: Tables_membersAvgAggregateOutputType | null
    _sum: Tables_membersSumAggregateOutputType | null
    _min: Tables_membersMinAggregateOutputType | null
    _max: Tables_membersMaxAggregateOutputType | null
  }

  type GetTables_membersGroupByPayload<T extends tables_membersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tables_membersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tables_membersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tables_membersGroupByOutputType[P]>
            : GetScalarType<T[P], Tables_membersGroupByOutputType[P]>
        }
      >
    >


  export type tables_membersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tables_members_id?: boolean
    table_id?: boolean
    member_id?: boolean
    table_position?: boolean
    live?: boolean
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
    tables?: boolean | tablesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tables_members"]>

  export type tables_membersSelectScalar = {
    tables_members_id?: boolean
    table_id?: boolean
    member_id?: boolean
    table_position?: boolean
    live?: boolean
  }

  export type tables_membersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
    tables?: boolean | tablesDefaultArgs<ExtArgs>
  }


  export type $tables_membersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tables_members"
    objects: {
      entities: Prisma.$entitiesPayload<ExtArgs>
      tables: Prisma.$tablesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      tables_members_id: string
      table_id: string
      member_id: string
      table_position: number
      live: number
    }, ExtArgs["result"]["tables_members"]>
    composites: {}
  }


  type tables_membersGetPayload<S extends boolean | null | undefined | tables_membersDefaultArgs> = $Result.GetResult<Prisma.$tables_membersPayload, S>

  type tables_membersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tables_membersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tables_membersCountAggregateInputType | true
    }

  export interface tables_membersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tables_members'], meta: { name: 'tables_members' } }
    /**
     * Find zero or one Tables_members that matches the filter.
     * @param {tables_membersFindUniqueArgs} args - Arguments to find a Tables_members
     * @example
     * // Get one Tables_members
     * const tables_members = await prisma.tables_members.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tables_membersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, tables_membersFindUniqueArgs<ExtArgs>>
    ): Prisma__tables_membersClient<$Result.GetResult<Prisma.$tables_membersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tables_members that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tables_membersFindUniqueOrThrowArgs} args - Arguments to find a Tables_members
     * @example
     * // Get one Tables_members
     * const tables_members = await prisma.tables_members.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tables_membersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_membersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tables_membersClient<$Result.GetResult<Prisma.$tables_membersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tables_members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_membersFindFirstArgs} args - Arguments to find a Tables_members
     * @example
     * // Get one Tables_members
     * const tables_members = await prisma.tables_members.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tables_membersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_membersFindFirstArgs<ExtArgs>>
    ): Prisma__tables_membersClient<$Result.GetResult<Prisma.$tables_membersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tables_members that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_membersFindFirstOrThrowArgs} args - Arguments to find a Tables_members
     * @example
     * // Get one Tables_members
     * const tables_members = await prisma.tables_members.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tables_membersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_membersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tables_membersClient<$Result.GetResult<Prisma.$tables_membersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tables_members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_membersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tables_members
     * const tables_members = await prisma.tables_members.findMany()
     * 
     * // Get first 10 Tables_members
     * const tables_members = await prisma.tables_members.findMany({ take: 10 })
     * 
     * // Only select the `tables_members_id`
     * const tables_membersWithTables_members_idOnly = await prisma.tables_members.findMany({ select: { tables_members_id: true } })
     * 
    **/
    findMany<T extends tables_membersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_membersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tables_membersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tables_members.
     * @param {tables_membersCreateArgs} args - Arguments to create a Tables_members.
     * @example
     * // Create one Tables_members
     * const Tables_members = await prisma.tables_members.create({
     *   data: {
     *     // ... data to create a Tables_members
     *   }
     * })
     * 
    **/
    create<T extends tables_membersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tables_membersCreateArgs<ExtArgs>>
    ): Prisma__tables_membersClient<$Result.GetResult<Prisma.$tables_membersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tables_members.
     *     @param {tables_membersCreateManyArgs} args - Arguments to create many Tables_members.
     *     @example
     *     // Create many Tables_members
     *     const tables_members = await prisma.tables_members.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tables_membersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_membersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tables_members.
     * @param {tables_membersDeleteArgs} args - Arguments to delete one Tables_members.
     * @example
     * // Delete one Tables_members
     * const Tables_members = await prisma.tables_members.delete({
     *   where: {
     *     // ... filter to delete one Tables_members
     *   }
     * })
     * 
    **/
    delete<T extends tables_membersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tables_membersDeleteArgs<ExtArgs>>
    ): Prisma__tables_membersClient<$Result.GetResult<Prisma.$tables_membersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tables_members.
     * @param {tables_membersUpdateArgs} args - Arguments to update one Tables_members.
     * @example
     * // Update one Tables_members
     * const tables_members = await prisma.tables_members.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tables_membersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tables_membersUpdateArgs<ExtArgs>>
    ): Prisma__tables_membersClient<$Result.GetResult<Prisma.$tables_membersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tables_members.
     * @param {tables_membersDeleteManyArgs} args - Arguments to filter Tables_members to delete.
     * @example
     * // Delete a few Tables_members
     * const { count } = await prisma.tables_members.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tables_membersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_membersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tables_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_membersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tables_members
     * const tables_members = await prisma.tables_members.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tables_membersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tables_membersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tables_members.
     * @param {tables_membersUpsertArgs} args - Arguments to update or create a Tables_members.
     * @example
     * // Update or create a Tables_members
     * const tables_members = await prisma.tables_members.upsert({
     *   create: {
     *     // ... data to create a Tables_members
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tables_members we want to update
     *   }
     * })
    **/
    upsert<T extends tables_membersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tables_membersUpsertArgs<ExtArgs>>
    ): Prisma__tables_membersClient<$Result.GetResult<Prisma.$tables_membersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tables_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_membersCountArgs} args - Arguments to filter Tables_members to count.
     * @example
     * // Count the number of Tables_members
     * const count = await prisma.tables_members.count({
     *   where: {
     *     // ... the filter for the Tables_members we want to count
     *   }
     * })
    **/
    count<T extends tables_membersCountArgs>(
      args?: Subset<T, tables_membersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tables_membersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tables_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tables_membersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tables_membersAggregateArgs>(args: Subset<T, Tables_membersAggregateArgs>): Prisma.PrismaPromise<GetTables_membersAggregateType<T>>

    /**
     * Group by Tables_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_membersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tables_membersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tables_membersGroupByArgs['orderBy'] }
        : { orderBy?: tables_membersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tables_membersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTables_membersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tables_members model
   */
  readonly fields: tables_membersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tables_members.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tables_membersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    entities<T extends entitiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, entitiesDefaultArgs<ExtArgs>>): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    tables<T extends tablesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tablesDefaultArgs<ExtArgs>>): Prisma__tablesClient<$Result.GetResult<Prisma.$tablesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the tables_members model
   */ 
  interface tables_membersFieldRefs {
    readonly tables_members_id: FieldRef<"tables_members", 'String'>
    readonly table_id: FieldRef<"tables_members", 'String'>
    readonly member_id: FieldRef<"tables_members", 'String'>
    readonly table_position: FieldRef<"tables_members", 'Int'>
    readonly live: FieldRef<"tables_members", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * tables_members findUnique
   */
  export type tables_membersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_members
     */
    select?: tables_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_membersInclude<ExtArgs> | null
    /**
     * Filter, which tables_members to fetch.
     */
    where: tables_membersWhereUniqueInput
  }


  /**
   * tables_members findUniqueOrThrow
   */
  export type tables_membersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_members
     */
    select?: tables_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_membersInclude<ExtArgs> | null
    /**
     * Filter, which tables_members to fetch.
     */
    where: tables_membersWhereUniqueInput
  }


  /**
   * tables_members findFirst
   */
  export type tables_membersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_members
     */
    select?: tables_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_membersInclude<ExtArgs> | null
    /**
     * Filter, which tables_members to fetch.
     */
    where?: tables_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tables_members to fetch.
     */
    orderBy?: tables_membersOrderByWithRelationInput | tables_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tables_members.
     */
    cursor?: tables_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tables_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tables_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tables_members.
     */
    distinct?: Tables_membersScalarFieldEnum | Tables_membersScalarFieldEnum[]
  }


  /**
   * tables_members findFirstOrThrow
   */
  export type tables_membersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_members
     */
    select?: tables_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_membersInclude<ExtArgs> | null
    /**
     * Filter, which tables_members to fetch.
     */
    where?: tables_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tables_members to fetch.
     */
    orderBy?: tables_membersOrderByWithRelationInput | tables_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tables_members.
     */
    cursor?: tables_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tables_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tables_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tables_members.
     */
    distinct?: Tables_membersScalarFieldEnum | Tables_membersScalarFieldEnum[]
  }


  /**
   * tables_members findMany
   */
  export type tables_membersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_members
     */
    select?: tables_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_membersInclude<ExtArgs> | null
    /**
     * Filter, which tables_members to fetch.
     */
    where?: tables_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tables_members to fetch.
     */
    orderBy?: tables_membersOrderByWithRelationInput | tables_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tables_members.
     */
    cursor?: tables_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tables_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tables_members.
     */
    skip?: number
    distinct?: Tables_membersScalarFieldEnum | Tables_membersScalarFieldEnum[]
  }


  /**
   * tables_members create
   */
  export type tables_membersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_members
     */
    select?: tables_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_membersInclude<ExtArgs> | null
    /**
     * The data needed to create a tables_members.
     */
    data: XOR<tables_membersCreateInput, tables_membersUncheckedCreateInput>
  }


  /**
   * tables_members createMany
   */
  export type tables_membersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tables_members.
     */
    data: tables_membersCreateManyInput | tables_membersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tables_members update
   */
  export type tables_membersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_members
     */
    select?: tables_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_membersInclude<ExtArgs> | null
    /**
     * The data needed to update a tables_members.
     */
    data: XOR<tables_membersUpdateInput, tables_membersUncheckedUpdateInput>
    /**
     * Choose, which tables_members to update.
     */
    where: tables_membersWhereUniqueInput
  }


  /**
   * tables_members updateMany
   */
  export type tables_membersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tables_members.
     */
    data: XOR<tables_membersUpdateManyMutationInput, tables_membersUncheckedUpdateManyInput>
    /**
     * Filter which tables_members to update
     */
    where?: tables_membersWhereInput
  }


  /**
   * tables_members upsert
   */
  export type tables_membersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_members
     */
    select?: tables_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_membersInclude<ExtArgs> | null
    /**
     * The filter to search for the tables_members to update in case it exists.
     */
    where: tables_membersWhereUniqueInput
    /**
     * In case the tables_members found by the `where` argument doesn't exist, create a new tables_members with this data.
     */
    create: XOR<tables_membersCreateInput, tables_membersUncheckedCreateInput>
    /**
     * In case the tables_members was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tables_membersUpdateInput, tables_membersUncheckedUpdateInput>
  }


  /**
   * tables_members delete
   */
  export type tables_membersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_members
     */
    select?: tables_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_membersInclude<ExtArgs> | null
    /**
     * Filter which tables_members to delete.
     */
    where: tables_membersWhereUniqueInput
  }


  /**
   * tables_members deleteMany
   */
  export type tables_membersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tables_members to delete
     */
    where?: tables_membersWhereInput
  }


  /**
   * tables_members without action
   */
  export type tables_membersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_members
     */
    select?: tables_membersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_membersInclude<ExtArgs> | null
  }



  /**
   * Model tables_messages_logs
   */

  export type AggregateTables_messages_logs = {
    _count: Tables_messages_logsCountAggregateOutputType | null
    _min: Tables_messages_logsMinAggregateOutputType | null
    _max: Tables_messages_logsMaxAggregateOutputType | null
  }

  export type Tables_messages_logsMinAggregateOutputType = {
    tables_messages_logs_id: string | null
    table_id: string | null
    entity_id: string | null
    message: string | null
    message_date: Date | null
  }

  export type Tables_messages_logsMaxAggregateOutputType = {
    tables_messages_logs_id: string | null
    table_id: string | null
    entity_id: string | null
    message: string | null
    message_date: Date | null
  }

  export type Tables_messages_logsCountAggregateOutputType = {
    tables_messages_logs_id: number
    table_id: number
    entity_id: number
    message: number
    message_date: number
    _all: number
  }


  export type Tables_messages_logsMinAggregateInputType = {
    tables_messages_logs_id?: true
    table_id?: true
    entity_id?: true
    message?: true
    message_date?: true
  }

  export type Tables_messages_logsMaxAggregateInputType = {
    tables_messages_logs_id?: true
    table_id?: true
    entity_id?: true
    message?: true
    message_date?: true
  }

  export type Tables_messages_logsCountAggregateInputType = {
    tables_messages_logs_id?: true
    table_id?: true
    entity_id?: true
    message?: true
    message_date?: true
    _all?: true
  }

  export type Tables_messages_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tables_messages_logs to aggregate.
     */
    where?: tables_messages_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tables_messages_logs to fetch.
     */
    orderBy?: tables_messages_logsOrderByWithRelationInput | tables_messages_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tables_messages_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tables_messages_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tables_messages_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tables_messages_logs
    **/
    _count?: true | Tables_messages_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tables_messages_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tables_messages_logsMaxAggregateInputType
  }

  export type GetTables_messages_logsAggregateType<T extends Tables_messages_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateTables_messages_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTables_messages_logs[P]>
      : GetScalarType<T[P], AggregateTables_messages_logs[P]>
  }




  export type tables_messages_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tables_messages_logsWhereInput
    orderBy?: tables_messages_logsOrderByWithAggregationInput | tables_messages_logsOrderByWithAggregationInput[]
    by: Tables_messages_logsScalarFieldEnum[] | Tables_messages_logsScalarFieldEnum
    having?: tables_messages_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tables_messages_logsCountAggregateInputType | true
    _min?: Tables_messages_logsMinAggregateInputType
    _max?: Tables_messages_logsMaxAggregateInputType
  }

  export type Tables_messages_logsGroupByOutputType = {
    tables_messages_logs_id: string
    table_id: string
    entity_id: string
    message: string
    message_date: Date
    _count: Tables_messages_logsCountAggregateOutputType | null
    _min: Tables_messages_logsMinAggregateOutputType | null
    _max: Tables_messages_logsMaxAggregateOutputType | null
  }

  type GetTables_messages_logsGroupByPayload<T extends tables_messages_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tables_messages_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tables_messages_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tables_messages_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Tables_messages_logsGroupByOutputType[P]>
        }
      >
    >


  export type tables_messages_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tables_messages_logs_id?: boolean
    table_id?: boolean
    entity_id?: boolean
    message?: boolean
    message_date?: boolean
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
    tables?: boolean | tablesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tables_messages_logs"]>

  export type tables_messages_logsSelectScalar = {
    tables_messages_logs_id?: boolean
    table_id?: boolean
    entity_id?: boolean
    message?: boolean
    message_date?: boolean
  }

  export type tables_messages_logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
    tables?: boolean | tablesDefaultArgs<ExtArgs>
  }


  export type $tables_messages_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tables_messages_logs"
    objects: {
      entities: Prisma.$entitiesPayload<ExtArgs>
      tables: Prisma.$tablesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      tables_messages_logs_id: string
      table_id: string
      entity_id: string
      message: string
      message_date: Date
    }, ExtArgs["result"]["tables_messages_logs"]>
    composites: {}
  }


  type tables_messages_logsGetPayload<S extends boolean | null | undefined | tables_messages_logsDefaultArgs> = $Result.GetResult<Prisma.$tables_messages_logsPayload, S>

  type tables_messages_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tables_messages_logsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tables_messages_logsCountAggregateInputType | true
    }

  export interface tables_messages_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tables_messages_logs'], meta: { name: 'tables_messages_logs' } }
    /**
     * Find zero or one Tables_messages_logs that matches the filter.
     * @param {tables_messages_logsFindUniqueArgs} args - Arguments to find a Tables_messages_logs
     * @example
     * // Get one Tables_messages_logs
     * const tables_messages_logs = await prisma.tables_messages_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tables_messages_logsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, tables_messages_logsFindUniqueArgs<ExtArgs>>
    ): Prisma__tables_messages_logsClient<$Result.GetResult<Prisma.$tables_messages_logsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tables_messages_logs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tables_messages_logsFindUniqueOrThrowArgs} args - Arguments to find a Tables_messages_logs
     * @example
     * // Get one Tables_messages_logs
     * const tables_messages_logs = await prisma.tables_messages_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tables_messages_logsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_messages_logsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tables_messages_logsClient<$Result.GetResult<Prisma.$tables_messages_logsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tables_messages_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_messages_logsFindFirstArgs} args - Arguments to find a Tables_messages_logs
     * @example
     * // Get one Tables_messages_logs
     * const tables_messages_logs = await prisma.tables_messages_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tables_messages_logsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_messages_logsFindFirstArgs<ExtArgs>>
    ): Prisma__tables_messages_logsClient<$Result.GetResult<Prisma.$tables_messages_logsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tables_messages_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_messages_logsFindFirstOrThrowArgs} args - Arguments to find a Tables_messages_logs
     * @example
     * // Get one Tables_messages_logs
     * const tables_messages_logs = await prisma.tables_messages_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tables_messages_logsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_messages_logsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tables_messages_logsClient<$Result.GetResult<Prisma.$tables_messages_logsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tables_messages_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_messages_logsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tables_messages_logs
     * const tables_messages_logs = await prisma.tables_messages_logs.findMany()
     * 
     * // Get first 10 Tables_messages_logs
     * const tables_messages_logs = await prisma.tables_messages_logs.findMany({ take: 10 })
     * 
     * // Only select the `tables_messages_logs_id`
     * const tables_messages_logsWithTables_messages_logs_idOnly = await prisma.tables_messages_logs.findMany({ select: { tables_messages_logs_id: true } })
     * 
    **/
    findMany<T extends tables_messages_logsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_messages_logsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tables_messages_logsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tables_messages_logs.
     * @param {tables_messages_logsCreateArgs} args - Arguments to create a Tables_messages_logs.
     * @example
     * // Create one Tables_messages_logs
     * const Tables_messages_logs = await prisma.tables_messages_logs.create({
     *   data: {
     *     // ... data to create a Tables_messages_logs
     *   }
     * })
     * 
    **/
    create<T extends tables_messages_logsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tables_messages_logsCreateArgs<ExtArgs>>
    ): Prisma__tables_messages_logsClient<$Result.GetResult<Prisma.$tables_messages_logsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tables_messages_logs.
     *     @param {tables_messages_logsCreateManyArgs} args - Arguments to create many Tables_messages_logs.
     *     @example
     *     // Create many Tables_messages_logs
     *     const tables_messages_logs = await prisma.tables_messages_logs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tables_messages_logsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_messages_logsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tables_messages_logs.
     * @param {tables_messages_logsDeleteArgs} args - Arguments to delete one Tables_messages_logs.
     * @example
     * // Delete one Tables_messages_logs
     * const Tables_messages_logs = await prisma.tables_messages_logs.delete({
     *   where: {
     *     // ... filter to delete one Tables_messages_logs
     *   }
     * })
     * 
    **/
    delete<T extends tables_messages_logsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tables_messages_logsDeleteArgs<ExtArgs>>
    ): Prisma__tables_messages_logsClient<$Result.GetResult<Prisma.$tables_messages_logsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tables_messages_logs.
     * @param {tables_messages_logsUpdateArgs} args - Arguments to update one Tables_messages_logs.
     * @example
     * // Update one Tables_messages_logs
     * const tables_messages_logs = await prisma.tables_messages_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tables_messages_logsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tables_messages_logsUpdateArgs<ExtArgs>>
    ): Prisma__tables_messages_logsClient<$Result.GetResult<Prisma.$tables_messages_logsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tables_messages_logs.
     * @param {tables_messages_logsDeleteManyArgs} args - Arguments to filter Tables_messages_logs to delete.
     * @example
     * // Delete a few Tables_messages_logs
     * const { count } = await prisma.tables_messages_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tables_messages_logsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_messages_logsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tables_messages_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_messages_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tables_messages_logs
     * const tables_messages_logs = await prisma.tables_messages_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tables_messages_logsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tables_messages_logsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tables_messages_logs.
     * @param {tables_messages_logsUpsertArgs} args - Arguments to update or create a Tables_messages_logs.
     * @example
     * // Update or create a Tables_messages_logs
     * const tables_messages_logs = await prisma.tables_messages_logs.upsert({
     *   create: {
     *     // ... data to create a Tables_messages_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tables_messages_logs we want to update
     *   }
     * })
    **/
    upsert<T extends tables_messages_logsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tables_messages_logsUpsertArgs<ExtArgs>>
    ): Prisma__tables_messages_logsClient<$Result.GetResult<Prisma.$tables_messages_logsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tables_messages_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_messages_logsCountArgs} args - Arguments to filter Tables_messages_logs to count.
     * @example
     * // Count the number of Tables_messages_logs
     * const count = await prisma.tables_messages_logs.count({
     *   where: {
     *     // ... the filter for the Tables_messages_logs we want to count
     *   }
     * })
    **/
    count<T extends tables_messages_logsCountArgs>(
      args?: Subset<T, tables_messages_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tables_messages_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tables_messages_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tables_messages_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tables_messages_logsAggregateArgs>(args: Subset<T, Tables_messages_logsAggregateArgs>): Prisma.PrismaPromise<GetTables_messages_logsAggregateType<T>>

    /**
     * Group by Tables_messages_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_messages_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tables_messages_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tables_messages_logsGroupByArgs['orderBy'] }
        : { orderBy?: tables_messages_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tables_messages_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTables_messages_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tables_messages_logs model
   */
  readonly fields: tables_messages_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tables_messages_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tables_messages_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    entities<T extends entitiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, entitiesDefaultArgs<ExtArgs>>): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    tables<T extends tablesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tablesDefaultArgs<ExtArgs>>): Prisma__tablesClient<$Result.GetResult<Prisma.$tablesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the tables_messages_logs model
   */ 
  interface tables_messages_logsFieldRefs {
    readonly tables_messages_logs_id: FieldRef<"tables_messages_logs", 'String'>
    readonly table_id: FieldRef<"tables_messages_logs", 'String'>
    readonly entity_id: FieldRef<"tables_messages_logs", 'String'>
    readonly message: FieldRef<"tables_messages_logs", 'String'>
    readonly message_date: FieldRef<"tables_messages_logs", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * tables_messages_logs findUnique
   */
  export type tables_messages_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_messages_logs
     */
    select?: tables_messages_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_messages_logsInclude<ExtArgs> | null
    /**
     * Filter, which tables_messages_logs to fetch.
     */
    where: tables_messages_logsWhereUniqueInput
  }


  /**
   * tables_messages_logs findUniqueOrThrow
   */
  export type tables_messages_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_messages_logs
     */
    select?: tables_messages_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_messages_logsInclude<ExtArgs> | null
    /**
     * Filter, which tables_messages_logs to fetch.
     */
    where: tables_messages_logsWhereUniqueInput
  }


  /**
   * tables_messages_logs findFirst
   */
  export type tables_messages_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_messages_logs
     */
    select?: tables_messages_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_messages_logsInclude<ExtArgs> | null
    /**
     * Filter, which tables_messages_logs to fetch.
     */
    where?: tables_messages_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tables_messages_logs to fetch.
     */
    orderBy?: tables_messages_logsOrderByWithRelationInput | tables_messages_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tables_messages_logs.
     */
    cursor?: tables_messages_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tables_messages_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tables_messages_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tables_messages_logs.
     */
    distinct?: Tables_messages_logsScalarFieldEnum | Tables_messages_logsScalarFieldEnum[]
  }


  /**
   * tables_messages_logs findFirstOrThrow
   */
  export type tables_messages_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_messages_logs
     */
    select?: tables_messages_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_messages_logsInclude<ExtArgs> | null
    /**
     * Filter, which tables_messages_logs to fetch.
     */
    where?: tables_messages_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tables_messages_logs to fetch.
     */
    orderBy?: tables_messages_logsOrderByWithRelationInput | tables_messages_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tables_messages_logs.
     */
    cursor?: tables_messages_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tables_messages_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tables_messages_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tables_messages_logs.
     */
    distinct?: Tables_messages_logsScalarFieldEnum | Tables_messages_logsScalarFieldEnum[]
  }


  /**
   * tables_messages_logs findMany
   */
  export type tables_messages_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_messages_logs
     */
    select?: tables_messages_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_messages_logsInclude<ExtArgs> | null
    /**
     * Filter, which tables_messages_logs to fetch.
     */
    where?: tables_messages_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tables_messages_logs to fetch.
     */
    orderBy?: tables_messages_logsOrderByWithRelationInput | tables_messages_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tables_messages_logs.
     */
    cursor?: tables_messages_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tables_messages_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tables_messages_logs.
     */
    skip?: number
    distinct?: Tables_messages_logsScalarFieldEnum | Tables_messages_logsScalarFieldEnum[]
  }


  /**
   * tables_messages_logs create
   */
  export type tables_messages_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_messages_logs
     */
    select?: tables_messages_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_messages_logsInclude<ExtArgs> | null
    /**
     * The data needed to create a tables_messages_logs.
     */
    data: XOR<tables_messages_logsCreateInput, tables_messages_logsUncheckedCreateInput>
  }


  /**
   * tables_messages_logs createMany
   */
  export type tables_messages_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tables_messages_logs.
     */
    data: tables_messages_logsCreateManyInput | tables_messages_logsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tables_messages_logs update
   */
  export type tables_messages_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_messages_logs
     */
    select?: tables_messages_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_messages_logsInclude<ExtArgs> | null
    /**
     * The data needed to update a tables_messages_logs.
     */
    data: XOR<tables_messages_logsUpdateInput, tables_messages_logsUncheckedUpdateInput>
    /**
     * Choose, which tables_messages_logs to update.
     */
    where: tables_messages_logsWhereUniqueInput
  }


  /**
   * tables_messages_logs updateMany
   */
  export type tables_messages_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tables_messages_logs.
     */
    data: XOR<tables_messages_logsUpdateManyMutationInput, tables_messages_logsUncheckedUpdateManyInput>
    /**
     * Filter which tables_messages_logs to update
     */
    where?: tables_messages_logsWhereInput
  }


  /**
   * tables_messages_logs upsert
   */
  export type tables_messages_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_messages_logs
     */
    select?: tables_messages_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_messages_logsInclude<ExtArgs> | null
    /**
     * The filter to search for the tables_messages_logs to update in case it exists.
     */
    where: tables_messages_logsWhereUniqueInput
    /**
     * In case the tables_messages_logs found by the `where` argument doesn't exist, create a new tables_messages_logs with this data.
     */
    create: XOR<tables_messages_logsCreateInput, tables_messages_logsUncheckedCreateInput>
    /**
     * In case the tables_messages_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tables_messages_logsUpdateInput, tables_messages_logsUncheckedUpdateInput>
  }


  /**
   * tables_messages_logs delete
   */
  export type tables_messages_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_messages_logs
     */
    select?: tables_messages_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_messages_logsInclude<ExtArgs> | null
    /**
     * Filter which tables_messages_logs to delete.
     */
    where: tables_messages_logsWhereUniqueInput
  }


  /**
   * tables_messages_logs deleteMany
   */
  export type tables_messages_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tables_messages_logs to delete
     */
    where?: tables_messages_logsWhereInput
  }


  /**
   * tables_messages_logs without action
   */
  export type tables_messages_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_messages_logs
     */
    select?: tables_messages_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_messages_logsInclude<ExtArgs> | null
  }



  /**
   * Model tables_pictures
   */

  export type AggregateTables_pictures = {
    _count: Tables_picturesCountAggregateOutputType | null
    _min: Tables_picturesMinAggregateOutputType | null
    _max: Tables_picturesMaxAggregateOutputType | null
  }

  export type Tables_picturesMinAggregateOutputType = {
    tables_pictures_id: string | null
    table_picture_data: Buffer | null
    table_picture_filename: string | null
  }

  export type Tables_picturesMaxAggregateOutputType = {
    tables_pictures_id: string | null
    table_picture_data: Buffer | null
    table_picture_filename: string | null
  }

  export type Tables_picturesCountAggregateOutputType = {
    tables_pictures_id: number
    table_picture_data: number
    table_picture_filename: number
    _all: number
  }


  export type Tables_picturesMinAggregateInputType = {
    tables_pictures_id?: true
    table_picture_data?: true
    table_picture_filename?: true
  }

  export type Tables_picturesMaxAggregateInputType = {
    tables_pictures_id?: true
    table_picture_data?: true
    table_picture_filename?: true
  }

  export type Tables_picturesCountAggregateInputType = {
    tables_pictures_id?: true
    table_picture_data?: true
    table_picture_filename?: true
    _all?: true
  }

  export type Tables_picturesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tables_pictures to aggregate.
     */
    where?: tables_picturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tables_pictures to fetch.
     */
    orderBy?: tables_picturesOrderByWithRelationInput | tables_picturesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tables_picturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tables_pictures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tables_pictures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tables_pictures
    **/
    _count?: true | Tables_picturesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tables_picturesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tables_picturesMaxAggregateInputType
  }

  export type GetTables_picturesAggregateType<T extends Tables_picturesAggregateArgs> = {
        [P in keyof T & keyof AggregateTables_pictures]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTables_pictures[P]>
      : GetScalarType<T[P], AggregateTables_pictures[P]>
  }




  export type tables_picturesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tables_picturesWhereInput
    orderBy?: tables_picturesOrderByWithAggregationInput | tables_picturesOrderByWithAggregationInput[]
    by: Tables_picturesScalarFieldEnum[] | Tables_picturesScalarFieldEnum
    having?: tables_picturesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tables_picturesCountAggregateInputType | true
    _min?: Tables_picturesMinAggregateInputType
    _max?: Tables_picturesMaxAggregateInputType
  }

  export type Tables_picturesGroupByOutputType = {
    tables_pictures_id: string
    table_picture_data: Buffer
    table_picture_filename: string
    _count: Tables_picturesCountAggregateOutputType | null
    _min: Tables_picturesMinAggregateOutputType | null
    _max: Tables_picturesMaxAggregateOutputType | null
  }

  type GetTables_picturesGroupByPayload<T extends tables_picturesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tables_picturesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tables_picturesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tables_picturesGroupByOutputType[P]>
            : GetScalarType<T[P], Tables_picturesGroupByOutputType[P]>
        }
      >
    >


  export type tables_picturesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tables_pictures_id?: boolean
    table_picture_data?: boolean
    table_picture_filename?: boolean
    tables?: boolean | tables_pictures$tablesArgs<ExtArgs>
    _count?: boolean | Tables_picturesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tables_pictures"]>

  export type tables_picturesSelectScalar = {
    tables_pictures_id?: boolean
    table_picture_data?: boolean
    table_picture_filename?: boolean
  }

  export type tables_picturesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tables?: boolean | tables_pictures$tablesArgs<ExtArgs>
    _count?: boolean | Tables_picturesCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $tables_picturesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tables_pictures"
    objects: {
      tables: Prisma.$tablesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      tables_pictures_id: string
      table_picture_data: Buffer
      table_picture_filename: string
    }, ExtArgs["result"]["tables_pictures"]>
    composites: {}
  }


  type tables_picturesGetPayload<S extends boolean | null | undefined | tables_picturesDefaultArgs> = $Result.GetResult<Prisma.$tables_picturesPayload, S>

  type tables_picturesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tables_picturesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tables_picturesCountAggregateInputType | true
    }

  export interface tables_picturesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tables_pictures'], meta: { name: 'tables_pictures' } }
    /**
     * Find zero or one Tables_pictures that matches the filter.
     * @param {tables_picturesFindUniqueArgs} args - Arguments to find a Tables_pictures
     * @example
     * // Get one Tables_pictures
     * const tables_pictures = await prisma.tables_pictures.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tables_picturesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, tables_picturesFindUniqueArgs<ExtArgs>>
    ): Prisma__tables_picturesClient<$Result.GetResult<Prisma.$tables_picturesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tables_pictures that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tables_picturesFindUniqueOrThrowArgs} args - Arguments to find a Tables_pictures
     * @example
     * // Get one Tables_pictures
     * const tables_pictures = await prisma.tables_pictures.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tables_picturesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_picturesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tables_picturesClient<$Result.GetResult<Prisma.$tables_picturesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tables_pictures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_picturesFindFirstArgs} args - Arguments to find a Tables_pictures
     * @example
     * // Get one Tables_pictures
     * const tables_pictures = await prisma.tables_pictures.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tables_picturesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_picturesFindFirstArgs<ExtArgs>>
    ): Prisma__tables_picturesClient<$Result.GetResult<Prisma.$tables_picturesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tables_pictures that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_picturesFindFirstOrThrowArgs} args - Arguments to find a Tables_pictures
     * @example
     * // Get one Tables_pictures
     * const tables_pictures = await prisma.tables_pictures.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tables_picturesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_picturesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tables_picturesClient<$Result.GetResult<Prisma.$tables_picturesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tables_pictures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_picturesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tables_pictures
     * const tables_pictures = await prisma.tables_pictures.findMany()
     * 
     * // Get first 10 Tables_pictures
     * const tables_pictures = await prisma.tables_pictures.findMany({ take: 10 })
     * 
     * // Only select the `tables_pictures_id`
     * const tables_picturesWithTables_pictures_idOnly = await prisma.tables_pictures.findMany({ select: { tables_pictures_id: true } })
     * 
    **/
    findMany<T extends tables_picturesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_picturesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tables_picturesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tables_pictures.
     * @param {tables_picturesCreateArgs} args - Arguments to create a Tables_pictures.
     * @example
     * // Create one Tables_pictures
     * const Tables_pictures = await prisma.tables_pictures.create({
     *   data: {
     *     // ... data to create a Tables_pictures
     *   }
     * })
     * 
    **/
    create<T extends tables_picturesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tables_picturesCreateArgs<ExtArgs>>
    ): Prisma__tables_picturesClient<$Result.GetResult<Prisma.$tables_picturesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tables_pictures.
     *     @param {tables_picturesCreateManyArgs} args - Arguments to create many Tables_pictures.
     *     @example
     *     // Create many Tables_pictures
     *     const tables_pictures = await prisma.tables_pictures.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tables_picturesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_picturesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tables_pictures.
     * @param {tables_picturesDeleteArgs} args - Arguments to delete one Tables_pictures.
     * @example
     * // Delete one Tables_pictures
     * const Tables_pictures = await prisma.tables_pictures.delete({
     *   where: {
     *     // ... filter to delete one Tables_pictures
     *   }
     * })
     * 
    **/
    delete<T extends tables_picturesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tables_picturesDeleteArgs<ExtArgs>>
    ): Prisma__tables_picturesClient<$Result.GetResult<Prisma.$tables_picturesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tables_pictures.
     * @param {tables_picturesUpdateArgs} args - Arguments to update one Tables_pictures.
     * @example
     * // Update one Tables_pictures
     * const tables_pictures = await prisma.tables_pictures.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tables_picturesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tables_picturesUpdateArgs<ExtArgs>>
    ): Prisma__tables_picturesClient<$Result.GetResult<Prisma.$tables_picturesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tables_pictures.
     * @param {tables_picturesDeleteManyArgs} args - Arguments to filter Tables_pictures to delete.
     * @example
     * // Delete a few Tables_pictures
     * const { count } = await prisma.tables_pictures.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tables_picturesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_picturesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tables_pictures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_picturesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tables_pictures
     * const tables_pictures = await prisma.tables_pictures.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tables_picturesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tables_picturesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tables_pictures.
     * @param {tables_picturesUpsertArgs} args - Arguments to update or create a Tables_pictures.
     * @example
     * // Update or create a Tables_pictures
     * const tables_pictures = await prisma.tables_pictures.upsert({
     *   create: {
     *     // ... data to create a Tables_pictures
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tables_pictures we want to update
     *   }
     * })
    **/
    upsert<T extends tables_picturesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tables_picturesUpsertArgs<ExtArgs>>
    ): Prisma__tables_picturesClient<$Result.GetResult<Prisma.$tables_picturesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tables_pictures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_picturesCountArgs} args - Arguments to filter Tables_pictures to count.
     * @example
     * // Count the number of Tables_pictures
     * const count = await prisma.tables_pictures.count({
     *   where: {
     *     // ... the filter for the Tables_pictures we want to count
     *   }
     * })
    **/
    count<T extends tables_picturesCountArgs>(
      args?: Subset<T, tables_picturesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tables_picturesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tables_pictures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tables_picturesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tables_picturesAggregateArgs>(args: Subset<T, Tables_picturesAggregateArgs>): Prisma.PrismaPromise<GetTables_picturesAggregateType<T>>

    /**
     * Group by Tables_pictures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_picturesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tables_picturesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tables_picturesGroupByArgs['orderBy'] }
        : { orderBy?: tables_picturesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tables_picturesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTables_picturesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tables_pictures model
   */
  readonly fields: tables_picturesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tables_pictures.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tables_picturesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tables<T extends tables_pictures$tablesArgs<ExtArgs> = {}>(args?: Subset<T, tables_pictures$tablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tablesPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the tables_pictures model
   */ 
  interface tables_picturesFieldRefs {
    readonly tables_pictures_id: FieldRef<"tables_pictures", 'String'>
    readonly table_picture_data: FieldRef<"tables_pictures", 'Bytes'>
    readonly table_picture_filename: FieldRef<"tables_pictures", 'String'>
  }
    

  // Custom InputTypes

  /**
   * tables_pictures findUnique
   */
  export type tables_picturesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_pictures
     */
    select?: tables_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_picturesInclude<ExtArgs> | null
    /**
     * Filter, which tables_pictures to fetch.
     */
    where: tables_picturesWhereUniqueInput
  }


  /**
   * tables_pictures findUniqueOrThrow
   */
  export type tables_picturesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_pictures
     */
    select?: tables_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_picturesInclude<ExtArgs> | null
    /**
     * Filter, which tables_pictures to fetch.
     */
    where: tables_picturesWhereUniqueInput
  }


  /**
   * tables_pictures findFirst
   */
  export type tables_picturesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_pictures
     */
    select?: tables_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_picturesInclude<ExtArgs> | null
    /**
     * Filter, which tables_pictures to fetch.
     */
    where?: tables_picturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tables_pictures to fetch.
     */
    orderBy?: tables_picturesOrderByWithRelationInput | tables_picturesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tables_pictures.
     */
    cursor?: tables_picturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tables_pictures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tables_pictures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tables_pictures.
     */
    distinct?: Tables_picturesScalarFieldEnum | Tables_picturesScalarFieldEnum[]
  }


  /**
   * tables_pictures findFirstOrThrow
   */
  export type tables_picturesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_pictures
     */
    select?: tables_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_picturesInclude<ExtArgs> | null
    /**
     * Filter, which tables_pictures to fetch.
     */
    where?: tables_picturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tables_pictures to fetch.
     */
    orderBy?: tables_picturesOrderByWithRelationInput | tables_picturesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tables_pictures.
     */
    cursor?: tables_picturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tables_pictures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tables_pictures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tables_pictures.
     */
    distinct?: Tables_picturesScalarFieldEnum | Tables_picturesScalarFieldEnum[]
  }


  /**
   * tables_pictures findMany
   */
  export type tables_picturesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_pictures
     */
    select?: tables_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_picturesInclude<ExtArgs> | null
    /**
     * Filter, which tables_pictures to fetch.
     */
    where?: tables_picturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tables_pictures to fetch.
     */
    orderBy?: tables_picturesOrderByWithRelationInput | tables_picturesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tables_pictures.
     */
    cursor?: tables_picturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tables_pictures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tables_pictures.
     */
    skip?: number
    distinct?: Tables_picturesScalarFieldEnum | Tables_picturesScalarFieldEnum[]
  }


  /**
   * tables_pictures create
   */
  export type tables_picturesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_pictures
     */
    select?: tables_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_picturesInclude<ExtArgs> | null
    /**
     * The data needed to create a tables_pictures.
     */
    data: XOR<tables_picturesCreateInput, tables_picturesUncheckedCreateInput>
  }


  /**
   * tables_pictures createMany
   */
  export type tables_picturesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tables_pictures.
     */
    data: tables_picturesCreateManyInput | tables_picturesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tables_pictures update
   */
  export type tables_picturesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_pictures
     */
    select?: tables_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_picturesInclude<ExtArgs> | null
    /**
     * The data needed to update a tables_pictures.
     */
    data: XOR<tables_picturesUpdateInput, tables_picturesUncheckedUpdateInput>
    /**
     * Choose, which tables_pictures to update.
     */
    where: tables_picturesWhereUniqueInput
  }


  /**
   * tables_pictures updateMany
   */
  export type tables_picturesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tables_pictures.
     */
    data: XOR<tables_picturesUpdateManyMutationInput, tables_picturesUncheckedUpdateManyInput>
    /**
     * Filter which tables_pictures to update
     */
    where?: tables_picturesWhereInput
  }


  /**
   * tables_pictures upsert
   */
  export type tables_picturesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_pictures
     */
    select?: tables_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_picturesInclude<ExtArgs> | null
    /**
     * The filter to search for the tables_pictures to update in case it exists.
     */
    where: tables_picturesWhereUniqueInput
    /**
     * In case the tables_pictures found by the `where` argument doesn't exist, create a new tables_pictures with this data.
     */
    create: XOR<tables_picturesCreateInput, tables_picturesUncheckedCreateInput>
    /**
     * In case the tables_pictures was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tables_picturesUpdateInput, tables_picturesUncheckedUpdateInput>
  }


  /**
   * tables_pictures delete
   */
  export type tables_picturesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_pictures
     */
    select?: tables_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_picturesInclude<ExtArgs> | null
    /**
     * Filter which tables_pictures to delete.
     */
    where: tables_picturesWhereUniqueInput
  }


  /**
   * tables_pictures deleteMany
   */
  export type tables_picturesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tables_pictures to delete
     */
    where?: tables_picturesWhereInput
  }


  /**
   * tables_pictures.tables
   */
  export type tables_pictures$tablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables
     */
    select?: tablesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tablesInclude<ExtArgs> | null
    where?: tablesWhereInput
    orderBy?: tablesOrderByWithRelationInput | tablesOrderByWithRelationInput[]
    cursor?: tablesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TablesScalarFieldEnum | TablesScalarFieldEnum[]
  }


  /**
   * tables_pictures without action
   */
  export type tables_picturesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_pictures
     */
    select?: tables_picturesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_picturesInclude<ExtArgs> | null
  }



  /**
   * Model tables_tabletops
   */

  export type AggregateTables_tabletops = {
    _count: Tables_tabletopsCountAggregateOutputType | null
    _avg: Tables_tabletopsAvgAggregateOutputType | null
    _sum: Tables_tabletopsSumAggregateOutputType | null
    _min: Tables_tabletopsMinAggregateOutputType | null
    _max: Tables_tabletopsMaxAggregateOutputType | null
  }

  export type Tables_tabletopsAvgAggregateOutputType = {
    type: number | null
    content_x_position: number | null
    content_y_position: number | null
    content_rotation: number | null
  }

  export type Tables_tabletopsSumAggregateOutputType = {
    type: number | null
    content_x_position: number | null
    content_y_position: number | null
    content_rotation: number | null
  }

  export type Tables_tabletopsMinAggregateOutputType = {
    tables_tabletops_id: string | null
    table_id: string | null
    creator_id: string | null
    tables_tabletops_data_id: string | null
    type: number | null
    content_date_posted: Date | null
    content_x_position: number | null
    content_y_position: number | null
    content_rotation: number | null
    content_filename: string | null
  }

  export type Tables_tabletopsMaxAggregateOutputType = {
    tables_tabletops_id: string | null
    table_id: string | null
    creator_id: string | null
    tables_tabletops_data_id: string | null
    type: number | null
    content_date_posted: Date | null
    content_x_position: number | null
    content_y_position: number | null
    content_rotation: number | null
    content_filename: string | null
  }

  export type Tables_tabletopsCountAggregateOutputType = {
    tables_tabletops_id: number
    table_id: number
    creator_id: number
    tables_tabletops_data_id: number
    type: number
    content_date_posted: number
    content_x_position: number
    content_y_position: number
    content_rotation: number
    content_filename: number
    _all: number
  }


  export type Tables_tabletopsAvgAggregateInputType = {
    type?: true
    content_x_position?: true
    content_y_position?: true
    content_rotation?: true
  }

  export type Tables_tabletopsSumAggregateInputType = {
    type?: true
    content_x_position?: true
    content_y_position?: true
    content_rotation?: true
  }

  export type Tables_tabletopsMinAggregateInputType = {
    tables_tabletops_id?: true
    table_id?: true
    creator_id?: true
    tables_tabletops_data_id?: true
    type?: true
    content_date_posted?: true
    content_x_position?: true
    content_y_position?: true
    content_rotation?: true
    content_filename?: true
  }

  export type Tables_tabletopsMaxAggregateInputType = {
    tables_tabletops_id?: true
    table_id?: true
    creator_id?: true
    tables_tabletops_data_id?: true
    type?: true
    content_date_posted?: true
    content_x_position?: true
    content_y_position?: true
    content_rotation?: true
    content_filename?: true
  }

  export type Tables_tabletopsCountAggregateInputType = {
    tables_tabletops_id?: true
    table_id?: true
    creator_id?: true
    tables_tabletops_data_id?: true
    type?: true
    content_date_posted?: true
    content_x_position?: true
    content_y_position?: true
    content_rotation?: true
    content_filename?: true
    _all?: true
  }

  export type Tables_tabletopsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tables_tabletops to aggregate.
     */
    where?: tables_tabletopsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tables_tabletops to fetch.
     */
    orderBy?: tables_tabletopsOrderByWithRelationInput | tables_tabletopsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tables_tabletopsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tables_tabletops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tables_tabletops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tables_tabletops
    **/
    _count?: true | Tables_tabletopsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tables_tabletopsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tables_tabletopsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tables_tabletopsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tables_tabletopsMaxAggregateInputType
  }

  export type GetTables_tabletopsAggregateType<T extends Tables_tabletopsAggregateArgs> = {
        [P in keyof T & keyof AggregateTables_tabletops]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTables_tabletops[P]>
      : GetScalarType<T[P], AggregateTables_tabletops[P]>
  }




  export type tables_tabletopsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tables_tabletopsWhereInput
    orderBy?: tables_tabletopsOrderByWithAggregationInput | tables_tabletopsOrderByWithAggregationInput[]
    by: Tables_tabletopsScalarFieldEnum[] | Tables_tabletopsScalarFieldEnum
    having?: tables_tabletopsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tables_tabletopsCountAggregateInputType | true
    _avg?: Tables_tabletopsAvgAggregateInputType
    _sum?: Tables_tabletopsSumAggregateInputType
    _min?: Tables_tabletopsMinAggregateInputType
    _max?: Tables_tabletopsMaxAggregateInputType
  }

  export type Tables_tabletopsGroupByOutputType = {
    tables_tabletops_id: string
    table_id: string
    creator_id: string
    tables_tabletops_data_id: string | null
    type: number
    content_date_posted: Date
    content_x_position: number
    content_y_position: number
    content_rotation: number
    content_filename: string | null
    _count: Tables_tabletopsCountAggregateOutputType | null
    _avg: Tables_tabletopsAvgAggregateOutputType | null
    _sum: Tables_tabletopsSumAggregateOutputType | null
    _min: Tables_tabletopsMinAggregateOutputType | null
    _max: Tables_tabletopsMaxAggregateOutputType | null
  }

  type GetTables_tabletopsGroupByPayload<T extends tables_tabletopsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tables_tabletopsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tables_tabletopsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tables_tabletopsGroupByOutputType[P]>
            : GetScalarType<T[P], Tables_tabletopsGroupByOutputType[P]>
        }
      >
    >


  export type tables_tabletopsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tables_tabletops_id?: boolean
    table_id?: boolean
    creator_id?: boolean
    tables_tabletops_data_id?: boolean
    type?: boolean
    content_date_posted?: boolean
    content_x_position?: boolean
    content_y_position?: boolean
    content_rotation?: boolean
    content_filename?: boolean
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
    tables?: boolean | tablesDefaultArgs<ExtArgs>
    tables_tabletops_data?: boolean | tables_tabletops$tables_tabletops_dataArgs<ExtArgs>
  }, ExtArgs["result"]["tables_tabletops"]>

  export type tables_tabletopsSelectScalar = {
    tables_tabletops_id?: boolean
    table_id?: boolean
    creator_id?: boolean
    tables_tabletops_data_id?: boolean
    type?: boolean
    content_date_posted?: boolean
    content_x_position?: boolean
    content_y_position?: boolean
    content_rotation?: boolean
    content_filename?: boolean
  }

  export type tables_tabletopsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
    tables?: boolean | tablesDefaultArgs<ExtArgs>
    tables_tabletops_data?: boolean | tables_tabletops$tables_tabletops_dataArgs<ExtArgs>
  }


  export type $tables_tabletopsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tables_tabletops"
    objects: {
      entities: Prisma.$entitiesPayload<ExtArgs>
      tables: Prisma.$tablesPayload<ExtArgs>
      tables_tabletops_data: Prisma.$tables_tabletops_dataPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      tables_tabletops_id: string
      table_id: string
      creator_id: string
      tables_tabletops_data_id: string | null
      type: number
      content_date_posted: Date
      content_x_position: number
      content_y_position: number
      content_rotation: number
      content_filename: string | null
    }, ExtArgs["result"]["tables_tabletops"]>
    composites: {}
  }


  type tables_tabletopsGetPayload<S extends boolean | null | undefined | tables_tabletopsDefaultArgs> = $Result.GetResult<Prisma.$tables_tabletopsPayload, S>

  type tables_tabletopsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tables_tabletopsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tables_tabletopsCountAggregateInputType | true
    }

  export interface tables_tabletopsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tables_tabletops'], meta: { name: 'tables_tabletops' } }
    /**
     * Find zero or one Tables_tabletops that matches the filter.
     * @param {tables_tabletopsFindUniqueArgs} args - Arguments to find a Tables_tabletops
     * @example
     * // Get one Tables_tabletops
     * const tables_tabletops = await prisma.tables_tabletops.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tables_tabletopsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, tables_tabletopsFindUniqueArgs<ExtArgs>>
    ): Prisma__tables_tabletopsClient<$Result.GetResult<Prisma.$tables_tabletopsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tables_tabletops that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tables_tabletopsFindUniqueOrThrowArgs} args - Arguments to find a Tables_tabletops
     * @example
     * // Get one Tables_tabletops
     * const tables_tabletops = await prisma.tables_tabletops.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tables_tabletopsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_tabletopsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tables_tabletopsClient<$Result.GetResult<Prisma.$tables_tabletopsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tables_tabletops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_tabletopsFindFirstArgs} args - Arguments to find a Tables_tabletops
     * @example
     * // Get one Tables_tabletops
     * const tables_tabletops = await prisma.tables_tabletops.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tables_tabletopsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_tabletopsFindFirstArgs<ExtArgs>>
    ): Prisma__tables_tabletopsClient<$Result.GetResult<Prisma.$tables_tabletopsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tables_tabletops that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_tabletopsFindFirstOrThrowArgs} args - Arguments to find a Tables_tabletops
     * @example
     * // Get one Tables_tabletops
     * const tables_tabletops = await prisma.tables_tabletops.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tables_tabletopsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_tabletopsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tables_tabletopsClient<$Result.GetResult<Prisma.$tables_tabletopsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tables_tabletops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_tabletopsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tables_tabletops
     * const tables_tabletops = await prisma.tables_tabletops.findMany()
     * 
     * // Get first 10 Tables_tabletops
     * const tables_tabletops = await prisma.tables_tabletops.findMany({ take: 10 })
     * 
     * // Only select the `tables_tabletops_id`
     * const tables_tabletopsWithTables_tabletops_idOnly = await prisma.tables_tabletops.findMany({ select: { tables_tabletops_id: true } })
     * 
    **/
    findMany<T extends tables_tabletopsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_tabletopsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tables_tabletopsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tables_tabletops.
     * @param {tables_tabletopsCreateArgs} args - Arguments to create a Tables_tabletops.
     * @example
     * // Create one Tables_tabletops
     * const Tables_tabletops = await prisma.tables_tabletops.create({
     *   data: {
     *     // ... data to create a Tables_tabletops
     *   }
     * })
     * 
    **/
    create<T extends tables_tabletopsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tables_tabletopsCreateArgs<ExtArgs>>
    ): Prisma__tables_tabletopsClient<$Result.GetResult<Prisma.$tables_tabletopsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tables_tabletops.
     *     @param {tables_tabletopsCreateManyArgs} args - Arguments to create many Tables_tabletops.
     *     @example
     *     // Create many Tables_tabletops
     *     const tables_tabletops = await prisma.tables_tabletops.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tables_tabletopsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_tabletopsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tables_tabletops.
     * @param {tables_tabletopsDeleteArgs} args - Arguments to delete one Tables_tabletops.
     * @example
     * // Delete one Tables_tabletops
     * const Tables_tabletops = await prisma.tables_tabletops.delete({
     *   where: {
     *     // ... filter to delete one Tables_tabletops
     *   }
     * })
     * 
    **/
    delete<T extends tables_tabletopsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tables_tabletopsDeleteArgs<ExtArgs>>
    ): Prisma__tables_tabletopsClient<$Result.GetResult<Prisma.$tables_tabletopsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tables_tabletops.
     * @param {tables_tabletopsUpdateArgs} args - Arguments to update one Tables_tabletops.
     * @example
     * // Update one Tables_tabletops
     * const tables_tabletops = await prisma.tables_tabletops.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tables_tabletopsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tables_tabletopsUpdateArgs<ExtArgs>>
    ): Prisma__tables_tabletopsClient<$Result.GetResult<Prisma.$tables_tabletopsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tables_tabletops.
     * @param {tables_tabletopsDeleteManyArgs} args - Arguments to filter Tables_tabletops to delete.
     * @example
     * // Delete a few Tables_tabletops
     * const { count } = await prisma.tables_tabletops.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tables_tabletopsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_tabletopsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tables_tabletops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_tabletopsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tables_tabletops
     * const tables_tabletops = await prisma.tables_tabletops.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tables_tabletopsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tables_tabletopsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tables_tabletops.
     * @param {tables_tabletopsUpsertArgs} args - Arguments to update or create a Tables_tabletops.
     * @example
     * // Update or create a Tables_tabletops
     * const tables_tabletops = await prisma.tables_tabletops.upsert({
     *   create: {
     *     // ... data to create a Tables_tabletops
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tables_tabletops we want to update
     *   }
     * })
    **/
    upsert<T extends tables_tabletopsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tables_tabletopsUpsertArgs<ExtArgs>>
    ): Prisma__tables_tabletopsClient<$Result.GetResult<Prisma.$tables_tabletopsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tables_tabletops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_tabletopsCountArgs} args - Arguments to filter Tables_tabletops to count.
     * @example
     * // Count the number of Tables_tabletops
     * const count = await prisma.tables_tabletops.count({
     *   where: {
     *     // ... the filter for the Tables_tabletops we want to count
     *   }
     * })
    **/
    count<T extends tables_tabletopsCountArgs>(
      args?: Subset<T, tables_tabletopsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tables_tabletopsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tables_tabletops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tables_tabletopsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tables_tabletopsAggregateArgs>(args: Subset<T, Tables_tabletopsAggregateArgs>): Prisma.PrismaPromise<GetTables_tabletopsAggregateType<T>>

    /**
     * Group by Tables_tabletops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_tabletopsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tables_tabletopsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tables_tabletopsGroupByArgs['orderBy'] }
        : { orderBy?: tables_tabletopsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tables_tabletopsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTables_tabletopsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tables_tabletops model
   */
  readonly fields: tables_tabletopsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tables_tabletops.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tables_tabletopsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    entities<T extends entitiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, entitiesDefaultArgs<ExtArgs>>): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    tables<T extends tablesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tablesDefaultArgs<ExtArgs>>): Prisma__tablesClient<$Result.GetResult<Prisma.$tablesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    tables_tabletops_data<T extends tables_tabletops$tables_tabletops_dataArgs<ExtArgs> = {}>(args?: Subset<T, tables_tabletops$tables_tabletops_dataArgs<ExtArgs>>): Prisma__tables_tabletops_dataClient<$Result.GetResult<Prisma.$tables_tabletops_dataPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the tables_tabletops model
   */ 
  interface tables_tabletopsFieldRefs {
    readonly tables_tabletops_id: FieldRef<"tables_tabletops", 'String'>
    readonly table_id: FieldRef<"tables_tabletops", 'String'>
    readonly creator_id: FieldRef<"tables_tabletops", 'String'>
    readonly tables_tabletops_data_id: FieldRef<"tables_tabletops", 'String'>
    readonly type: FieldRef<"tables_tabletops", 'Int'>
    readonly content_date_posted: FieldRef<"tables_tabletops", 'DateTime'>
    readonly content_x_position: FieldRef<"tables_tabletops", 'Int'>
    readonly content_y_position: FieldRef<"tables_tabletops", 'Int'>
    readonly content_rotation: FieldRef<"tables_tabletops", 'Int'>
    readonly content_filename: FieldRef<"tables_tabletops", 'String'>
  }
    

  // Custom InputTypes

  /**
   * tables_tabletops findUnique
   */
  export type tables_tabletopsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_tabletops
     */
    select?: tables_tabletopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_tabletopsInclude<ExtArgs> | null
    /**
     * Filter, which tables_tabletops to fetch.
     */
    where: tables_tabletopsWhereUniqueInput
  }


  /**
   * tables_tabletops findUniqueOrThrow
   */
  export type tables_tabletopsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_tabletops
     */
    select?: tables_tabletopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_tabletopsInclude<ExtArgs> | null
    /**
     * Filter, which tables_tabletops to fetch.
     */
    where: tables_tabletopsWhereUniqueInput
  }


  /**
   * tables_tabletops findFirst
   */
  export type tables_tabletopsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_tabletops
     */
    select?: tables_tabletopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_tabletopsInclude<ExtArgs> | null
    /**
     * Filter, which tables_tabletops to fetch.
     */
    where?: tables_tabletopsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tables_tabletops to fetch.
     */
    orderBy?: tables_tabletopsOrderByWithRelationInput | tables_tabletopsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tables_tabletops.
     */
    cursor?: tables_tabletopsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tables_tabletops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tables_tabletops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tables_tabletops.
     */
    distinct?: Tables_tabletopsScalarFieldEnum | Tables_tabletopsScalarFieldEnum[]
  }


  /**
   * tables_tabletops findFirstOrThrow
   */
  export type tables_tabletopsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_tabletops
     */
    select?: tables_tabletopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_tabletopsInclude<ExtArgs> | null
    /**
     * Filter, which tables_tabletops to fetch.
     */
    where?: tables_tabletopsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tables_tabletops to fetch.
     */
    orderBy?: tables_tabletopsOrderByWithRelationInput | tables_tabletopsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tables_tabletops.
     */
    cursor?: tables_tabletopsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tables_tabletops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tables_tabletops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tables_tabletops.
     */
    distinct?: Tables_tabletopsScalarFieldEnum | Tables_tabletopsScalarFieldEnum[]
  }


  /**
   * tables_tabletops findMany
   */
  export type tables_tabletopsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_tabletops
     */
    select?: tables_tabletopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_tabletopsInclude<ExtArgs> | null
    /**
     * Filter, which tables_tabletops to fetch.
     */
    where?: tables_tabletopsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tables_tabletops to fetch.
     */
    orderBy?: tables_tabletopsOrderByWithRelationInput | tables_tabletopsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tables_tabletops.
     */
    cursor?: tables_tabletopsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tables_tabletops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tables_tabletops.
     */
    skip?: number
    distinct?: Tables_tabletopsScalarFieldEnum | Tables_tabletopsScalarFieldEnum[]
  }


  /**
   * tables_tabletops create
   */
  export type tables_tabletopsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_tabletops
     */
    select?: tables_tabletopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_tabletopsInclude<ExtArgs> | null
    /**
     * The data needed to create a tables_tabletops.
     */
    data: XOR<tables_tabletopsCreateInput, tables_tabletopsUncheckedCreateInput>
  }


  /**
   * tables_tabletops createMany
   */
  export type tables_tabletopsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tables_tabletops.
     */
    data: tables_tabletopsCreateManyInput | tables_tabletopsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tables_tabletops update
   */
  export type tables_tabletopsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_tabletops
     */
    select?: tables_tabletopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_tabletopsInclude<ExtArgs> | null
    /**
     * The data needed to update a tables_tabletops.
     */
    data: XOR<tables_tabletopsUpdateInput, tables_tabletopsUncheckedUpdateInput>
    /**
     * Choose, which tables_tabletops to update.
     */
    where: tables_tabletopsWhereUniqueInput
  }


  /**
   * tables_tabletops updateMany
   */
  export type tables_tabletopsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tables_tabletops.
     */
    data: XOR<tables_tabletopsUpdateManyMutationInput, tables_tabletopsUncheckedUpdateManyInput>
    /**
     * Filter which tables_tabletops to update
     */
    where?: tables_tabletopsWhereInput
  }


  /**
   * tables_tabletops upsert
   */
  export type tables_tabletopsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_tabletops
     */
    select?: tables_tabletopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_tabletopsInclude<ExtArgs> | null
    /**
     * The filter to search for the tables_tabletops to update in case it exists.
     */
    where: tables_tabletopsWhereUniqueInput
    /**
     * In case the tables_tabletops found by the `where` argument doesn't exist, create a new tables_tabletops with this data.
     */
    create: XOR<tables_tabletopsCreateInput, tables_tabletopsUncheckedCreateInput>
    /**
     * In case the tables_tabletops was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tables_tabletopsUpdateInput, tables_tabletopsUncheckedUpdateInput>
  }


  /**
   * tables_tabletops delete
   */
  export type tables_tabletopsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_tabletops
     */
    select?: tables_tabletopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_tabletopsInclude<ExtArgs> | null
    /**
     * Filter which tables_tabletops to delete.
     */
    where: tables_tabletopsWhereUniqueInput
  }


  /**
   * tables_tabletops deleteMany
   */
  export type tables_tabletopsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tables_tabletops to delete
     */
    where?: tables_tabletopsWhereInput
  }


  /**
   * tables_tabletops.tables_tabletops_data
   */
  export type tables_tabletops$tables_tabletops_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_tabletops_data
     */
    select?: tables_tabletops_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_tabletops_dataInclude<ExtArgs> | null
    where?: tables_tabletops_dataWhereInput
  }


  /**
   * tables_tabletops without action
   */
  export type tables_tabletopsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_tabletops
     */
    select?: tables_tabletopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_tabletopsInclude<ExtArgs> | null
  }



  /**
   * Model tables_tabletops_data
   */

  export type AggregateTables_tabletops_data = {
    _count: Tables_tabletops_dataCountAggregateOutputType | null
    _min: Tables_tabletops_dataMinAggregateOutputType | null
    _max: Tables_tabletops_dataMaxAggregateOutputType | null
  }

  export type Tables_tabletops_dataMinAggregateOutputType = {
    tables_tabletops_data_id: string | null
    tables_tabletops_data: Buffer | null
  }

  export type Tables_tabletops_dataMaxAggregateOutputType = {
    tables_tabletops_data_id: string | null
    tables_tabletops_data: Buffer | null
  }

  export type Tables_tabletops_dataCountAggregateOutputType = {
    tables_tabletops_data_id: number
    tables_tabletops_data: number
    _all: number
  }


  export type Tables_tabletops_dataMinAggregateInputType = {
    tables_tabletops_data_id?: true
    tables_tabletops_data?: true
  }

  export type Tables_tabletops_dataMaxAggregateInputType = {
    tables_tabletops_data_id?: true
    tables_tabletops_data?: true
  }

  export type Tables_tabletops_dataCountAggregateInputType = {
    tables_tabletops_data_id?: true
    tables_tabletops_data?: true
    _all?: true
  }

  export type Tables_tabletops_dataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tables_tabletops_data to aggregate.
     */
    where?: tables_tabletops_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tables_tabletops_data to fetch.
     */
    orderBy?: tables_tabletops_dataOrderByWithRelationInput | tables_tabletops_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tables_tabletops_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tables_tabletops_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tables_tabletops_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tables_tabletops_data
    **/
    _count?: true | Tables_tabletops_dataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tables_tabletops_dataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tables_tabletops_dataMaxAggregateInputType
  }

  export type GetTables_tabletops_dataAggregateType<T extends Tables_tabletops_dataAggregateArgs> = {
        [P in keyof T & keyof AggregateTables_tabletops_data]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTables_tabletops_data[P]>
      : GetScalarType<T[P], AggregateTables_tabletops_data[P]>
  }




  export type tables_tabletops_dataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tables_tabletops_dataWhereInput
    orderBy?: tables_tabletops_dataOrderByWithAggregationInput | tables_tabletops_dataOrderByWithAggregationInput[]
    by: Tables_tabletops_dataScalarFieldEnum[] | Tables_tabletops_dataScalarFieldEnum
    having?: tables_tabletops_dataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tables_tabletops_dataCountAggregateInputType | true
    _min?: Tables_tabletops_dataMinAggregateInputType
    _max?: Tables_tabletops_dataMaxAggregateInputType
  }

  export type Tables_tabletops_dataGroupByOutputType = {
    tables_tabletops_data_id: string
    tables_tabletops_data: Buffer
    _count: Tables_tabletops_dataCountAggregateOutputType | null
    _min: Tables_tabletops_dataMinAggregateOutputType | null
    _max: Tables_tabletops_dataMaxAggregateOutputType | null
  }

  type GetTables_tabletops_dataGroupByPayload<T extends tables_tabletops_dataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tables_tabletops_dataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tables_tabletops_dataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tables_tabletops_dataGroupByOutputType[P]>
            : GetScalarType<T[P], Tables_tabletops_dataGroupByOutputType[P]>
        }
      >
    >


  export type tables_tabletops_dataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tables_tabletops_data_id?: boolean
    tables_tabletops_data?: boolean
    tables_tabletops?: boolean | tables_tabletops_data$tables_tabletopsArgs<ExtArgs>
    _count?: boolean | Tables_tabletops_dataCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tables_tabletops_data"]>

  export type tables_tabletops_dataSelectScalar = {
    tables_tabletops_data_id?: boolean
    tables_tabletops_data?: boolean
  }

  export type tables_tabletops_dataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tables_tabletops?: boolean | tables_tabletops_data$tables_tabletopsArgs<ExtArgs>
    _count?: boolean | Tables_tabletops_dataCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $tables_tabletops_dataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tables_tabletops_data"
    objects: {
      tables_tabletops: Prisma.$tables_tabletopsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      tables_tabletops_data_id: string
      tables_tabletops_data: Buffer
    }, ExtArgs["result"]["tables_tabletops_data"]>
    composites: {}
  }


  type tables_tabletops_dataGetPayload<S extends boolean | null | undefined | tables_tabletops_dataDefaultArgs> = $Result.GetResult<Prisma.$tables_tabletops_dataPayload, S>

  type tables_tabletops_dataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tables_tabletops_dataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tables_tabletops_dataCountAggregateInputType | true
    }

  export interface tables_tabletops_dataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tables_tabletops_data'], meta: { name: 'tables_tabletops_data' } }
    /**
     * Find zero or one Tables_tabletops_data that matches the filter.
     * @param {tables_tabletops_dataFindUniqueArgs} args - Arguments to find a Tables_tabletops_data
     * @example
     * // Get one Tables_tabletops_data
     * const tables_tabletops_data = await prisma.tables_tabletops_data.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tables_tabletops_dataFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, tables_tabletops_dataFindUniqueArgs<ExtArgs>>
    ): Prisma__tables_tabletops_dataClient<$Result.GetResult<Prisma.$tables_tabletops_dataPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tables_tabletops_data that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tables_tabletops_dataFindUniqueOrThrowArgs} args - Arguments to find a Tables_tabletops_data
     * @example
     * // Get one Tables_tabletops_data
     * const tables_tabletops_data = await prisma.tables_tabletops_data.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tables_tabletops_dataFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_tabletops_dataFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tables_tabletops_dataClient<$Result.GetResult<Prisma.$tables_tabletops_dataPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tables_tabletops_data that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_tabletops_dataFindFirstArgs} args - Arguments to find a Tables_tabletops_data
     * @example
     * // Get one Tables_tabletops_data
     * const tables_tabletops_data = await prisma.tables_tabletops_data.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tables_tabletops_dataFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_tabletops_dataFindFirstArgs<ExtArgs>>
    ): Prisma__tables_tabletops_dataClient<$Result.GetResult<Prisma.$tables_tabletops_dataPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tables_tabletops_data that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_tabletops_dataFindFirstOrThrowArgs} args - Arguments to find a Tables_tabletops_data
     * @example
     * // Get one Tables_tabletops_data
     * const tables_tabletops_data = await prisma.tables_tabletops_data.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tables_tabletops_dataFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_tabletops_dataFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tables_tabletops_dataClient<$Result.GetResult<Prisma.$tables_tabletops_dataPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tables_tabletops_data that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_tabletops_dataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tables_tabletops_data
     * const tables_tabletops_data = await prisma.tables_tabletops_data.findMany()
     * 
     * // Get first 10 Tables_tabletops_data
     * const tables_tabletops_data = await prisma.tables_tabletops_data.findMany({ take: 10 })
     * 
     * // Only select the `tables_tabletops_data_id`
     * const tables_tabletops_dataWithTables_tabletops_data_idOnly = await prisma.tables_tabletops_data.findMany({ select: { tables_tabletops_data_id: true } })
     * 
    **/
    findMany<T extends tables_tabletops_dataFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_tabletops_dataFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tables_tabletops_dataPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tables_tabletops_data.
     * @param {tables_tabletops_dataCreateArgs} args - Arguments to create a Tables_tabletops_data.
     * @example
     * // Create one Tables_tabletops_data
     * const Tables_tabletops_data = await prisma.tables_tabletops_data.create({
     *   data: {
     *     // ... data to create a Tables_tabletops_data
     *   }
     * })
     * 
    **/
    create<T extends tables_tabletops_dataCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tables_tabletops_dataCreateArgs<ExtArgs>>
    ): Prisma__tables_tabletops_dataClient<$Result.GetResult<Prisma.$tables_tabletops_dataPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tables_tabletops_data.
     *     @param {tables_tabletops_dataCreateManyArgs} args - Arguments to create many Tables_tabletops_data.
     *     @example
     *     // Create many Tables_tabletops_data
     *     const tables_tabletops_data = await prisma.tables_tabletops_data.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tables_tabletops_dataCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_tabletops_dataCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tables_tabletops_data.
     * @param {tables_tabletops_dataDeleteArgs} args - Arguments to delete one Tables_tabletops_data.
     * @example
     * // Delete one Tables_tabletops_data
     * const Tables_tabletops_data = await prisma.tables_tabletops_data.delete({
     *   where: {
     *     // ... filter to delete one Tables_tabletops_data
     *   }
     * })
     * 
    **/
    delete<T extends tables_tabletops_dataDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tables_tabletops_dataDeleteArgs<ExtArgs>>
    ): Prisma__tables_tabletops_dataClient<$Result.GetResult<Prisma.$tables_tabletops_dataPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tables_tabletops_data.
     * @param {tables_tabletops_dataUpdateArgs} args - Arguments to update one Tables_tabletops_data.
     * @example
     * // Update one Tables_tabletops_data
     * const tables_tabletops_data = await prisma.tables_tabletops_data.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tables_tabletops_dataUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tables_tabletops_dataUpdateArgs<ExtArgs>>
    ): Prisma__tables_tabletops_dataClient<$Result.GetResult<Prisma.$tables_tabletops_dataPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tables_tabletops_data.
     * @param {tables_tabletops_dataDeleteManyArgs} args - Arguments to filter Tables_tabletops_data to delete.
     * @example
     * // Delete a few Tables_tabletops_data
     * const { count } = await prisma.tables_tabletops_data.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tables_tabletops_dataDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tables_tabletops_dataDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tables_tabletops_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_tabletops_dataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tables_tabletops_data
     * const tables_tabletops_data = await prisma.tables_tabletops_data.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tables_tabletops_dataUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tables_tabletops_dataUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tables_tabletops_data.
     * @param {tables_tabletops_dataUpsertArgs} args - Arguments to update or create a Tables_tabletops_data.
     * @example
     * // Update or create a Tables_tabletops_data
     * const tables_tabletops_data = await prisma.tables_tabletops_data.upsert({
     *   create: {
     *     // ... data to create a Tables_tabletops_data
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tables_tabletops_data we want to update
     *   }
     * })
    **/
    upsert<T extends tables_tabletops_dataUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tables_tabletops_dataUpsertArgs<ExtArgs>>
    ): Prisma__tables_tabletops_dataClient<$Result.GetResult<Prisma.$tables_tabletops_dataPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tables_tabletops_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_tabletops_dataCountArgs} args - Arguments to filter Tables_tabletops_data to count.
     * @example
     * // Count the number of Tables_tabletops_data
     * const count = await prisma.tables_tabletops_data.count({
     *   where: {
     *     // ... the filter for the Tables_tabletops_data we want to count
     *   }
     * })
    **/
    count<T extends tables_tabletops_dataCountArgs>(
      args?: Subset<T, tables_tabletops_dataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tables_tabletops_dataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tables_tabletops_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tables_tabletops_dataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tables_tabletops_dataAggregateArgs>(args: Subset<T, Tables_tabletops_dataAggregateArgs>): Prisma.PrismaPromise<GetTables_tabletops_dataAggregateType<T>>

    /**
     * Group by Tables_tabletops_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tables_tabletops_dataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tables_tabletops_dataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tables_tabletops_dataGroupByArgs['orderBy'] }
        : { orderBy?: tables_tabletops_dataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tables_tabletops_dataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTables_tabletops_dataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tables_tabletops_data model
   */
  readonly fields: tables_tabletops_dataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tables_tabletops_data.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tables_tabletops_dataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tables_tabletops<T extends tables_tabletops_data$tables_tabletopsArgs<ExtArgs> = {}>(args?: Subset<T, tables_tabletops_data$tables_tabletopsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tables_tabletopsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the tables_tabletops_data model
   */ 
  interface tables_tabletops_dataFieldRefs {
    readonly tables_tabletops_data_id: FieldRef<"tables_tabletops_data", 'String'>
    readonly tables_tabletops_data: FieldRef<"tables_tabletops_data", 'Bytes'>
  }
    

  // Custom InputTypes

  /**
   * tables_tabletops_data findUnique
   */
  export type tables_tabletops_dataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_tabletops_data
     */
    select?: tables_tabletops_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_tabletops_dataInclude<ExtArgs> | null
    /**
     * Filter, which tables_tabletops_data to fetch.
     */
    where: tables_tabletops_dataWhereUniqueInput
  }


  /**
   * tables_tabletops_data findUniqueOrThrow
   */
  export type tables_tabletops_dataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_tabletops_data
     */
    select?: tables_tabletops_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_tabletops_dataInclude<ExtArgs> | null
    /**
     * Filter, which tables_tabletops_data to fetch.
     */
    where: tables_tabletops_dataWhereUniqueInput
  }


  /**
   * tables_tabletops_data findFirst
   */
  export type tables_tabletops_dataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_tabletops_data
     */
    select?: tables_tabletops_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_tabletops_dataInclude<ExtArgs> | null
    /**
     * Filter, which tables_tabletops_data to fetch.
     */
    where?: tables_tabletops_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tables_tabletops_data to fetch.
     */
    orderBy?: tables_tabletops_dataOrderByWithRelationInput | tables_tabletops_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tables_tabletops_data.
     */
    cursor?: tables_tabletops_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tables_tabletops_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tables_tabletops_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tables_tabletops_data.
     */
    distinct?: Tables_tabletops_dataScalarFieldEnum | Tables_tabletops_dataScalarFieldEnum[]
  }


  /**
   * tables_tabletops_data findFirstOrThrow
   */
  export type tables_tabletops_dataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_tabletops_data
     */
    select?: tables_tabletops_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_tabletops_dataInclude<ExtArgs> | null
    /**
     * Filter, which tables_tabletops_data to fetch.
     */
    where?: tables_tabletops_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tables_tabletops_data to fetch.
     */
    orderBy?: tables_tabletops_dataOrderByWithRelationInput | tables_tabletops_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tables_tabletops_data.
     */
    cursor?: tables_tabletops_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tables_tabletops_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tables_tabletops_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tables_tabletops_data.
     */
    distinct?: Tables_tabletops_dataScalarFieldEnum | Tables_tabletops_dataScalarFieldEnum[]
  }


  /**
   * tables_tabletops_data findMany
   */
  export type tables_tabletops_dataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_tabletops_data
     */
    select?: tables_tabletops_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_tabletops_dataInclude<ExtArgs> | null
    /**
     * Filter, which tables_tabletops_data to fetch.
     */
    where?: tables_tabletops_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tables_tabletops_data to fetch.
     */
    orderBy?: tables_tabletops_dataOrderByWithRelationInput | tables_tabletops_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tables_tabletops_data.
     */
    cursor?: tables_tabletops_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tables_tabletops_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tables_tabletops_data.
     */
    skip?: number
    distinct?: Tables_tabletops_dataScalarFieldEnum | Tables_tabletops_dataScalarFieldEnum[]
  }


  /**
   * tables_tabletops_data create
   */
  export type tables_tabletops_dataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_tabletops_data
     */
    select?: tables_tabletops_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_tabletops_dataInclude<ExtArgs> | null
    /**
     * The data needed to create a tables_tabletops_data.
     */
    data: XOR<tables_tabletops_dataCreateInput, tables_tabletops_dataUncheckedCreateInput>
  }


  /**
   * tables_tabletops_data createMany
   */
  export type tables_tabletops_dataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tables_tabletops_data.
     */
    data: tables_tabletops_dataCreateManyInput | tables_tabletops_dataCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tables_tabletops_data update
   */
  export type tables_tabletops_dataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_tabletops_data
     */
    select?: tables_tabletops_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_tabletops_dataInclude<ExtArgs> | null
    /**
     * The data needed to update a tables_tabletops_data.
     */
    data: XOR<tables_tabletops_dataUpdateInput, tables_tabletops_dataUncheckedUpdateInput>
    /**
     * Choose, which tables_tabletops_data to update.
     */
    where: tables_tabletops_dataWhereUniqueInput
  }


  /**
   * tables_tabletops_data updateMany
   */
  export type tables_tabletops_dataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tables_tabletops_data.
     */
    data: XOR<tables_tabletops_dataUpdateManyMutationInput, tables_tabletops_dataUncheckedUpdateManyInput>
    /**
     * Filter which tables_tabletops_data to update
     */
    where?: tables_tabletops_dataWhereInput
  }


  /**
   * tables_tabletops_data upsert
   */
  export type tables_tabletops_dataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_tabletops_data
     */
    select?: tables_tabletops_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_tabletops_dataInclude<ExtArgs> | null
    /**
     * The filter to search for the tables_tabletops_data to update in case it exists.
     */
    where: tables_tabletops_dataWhereUniqueInput
    /**
     * In case the tables_tabletops_data found by the `where` argument doesn't exist, create a new tables_tabletops_data with this data.
     */
    create: XOR<tables_tabletops_dataCreateInput, tables_tabletops_dataUncheckedCreateInput>
    /**
     * In case the tables_tabletops_data was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tables_tabletops_dataUpdateInput, tables_tabletops_dataUncheckedUpdateInput>
  }


  /**
   * tables_tabletops_data delete
   */
  export type tables_tabletops_dataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_tabletops_data
     */
    select?: tables_tabletops_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_tabletops_dataInclude<ExtArgs> | null
    /**
     * Filter which tables_tabletops_data to delete.
     */
    where: tables_tabletops_dataWhereUniqueInput
  }


  /**
   * tables_tabletops_data deleteMany
   */
  export type tables_tabletops_dataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tables_tabletops_data to delete
     */
    where?: tables_tabletops_dataWhereInput
  }


  /**
   * tables_tabletops_data.tables_tabletops
   */
  export type tables_tabletops_data$tables_tabletopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_tabletops
     */
    select?: tables_tabletopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_tabletopsInclude<ExtArgs> | null
    where?: tables_tabletopsWhereInput
    orderBy?: tables_tabletopsOrderByWithRelationInput | tables_tabletopsOrderByWithRelationInput[]
    cursor?: tables_tabletopsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tables_tabletopsScalarFieldEnum | Tables_tabletopsScalarFieldEnum[]
  }


  /**
   * tables_tabletops_data without action
   */
  export type tables_tabletops_dataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tables_tabletops_data
     */
    select?: tables_tabletops_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tables_tabletops_dataInclude<ExtArgs> | null
  }



  /**
   * Model user_credentials
   */

  export type AggregateUser_credentials = {
    _count: User_credentialsCountAggregateOutputType | null
    _min: User_credentialsMinAggregateOutputType | null
    _max: User_credentialsMaxAggregateOutputType | null
  }

  export type User_credentialsMinAggregateOutputType = {
    user_id: string | null
    username: string | null
    user_password: string | null
    user_first_name: string | null
    user_last_name: string | null
    user_email: string | null
    user_phone_number: string | null
  }

  export type User_credentialsMaxAggregateOutputType = {
    user_id: string | null
    username: string | null
    user_password: string | null
    user_first_name: string | null
    user_last_name: string | null
    user_email: string | null
    user_phone_number: string | null
  }

  export type User_credentialsCountAggregateOutputType = {
    user_id: number
    username: number
    user_password: number
    user_first_name: number
    user_last_name: number
    user_email: number
    user_phone_number: number
    _all: number
  }


  export type User_credentialsMinAggregateInputType = {
    user_id?: true
    username?: true
    user_password?: true
    user_first_name?: true
    user_last_name?: true
    user_email?: true
    user_phone_number?: true
  }

  export type User_credentialsMaxAggregateInputType = {
    user_id?: true
    username?: true
    user_password?: true
    user_first_name?: true
    user_last_name?: true
    user_email?: true
    user_phone_number?: true
  }

  export type User_credentialsCountAggregateInputType = {
    user_id?: true
    username?: true
    user_password?: true
    user_first_name?: true
    user_last_name?: true
    user_email?: true
    user_phone_number?: true
    _all?: true
  }

  export type User_credentialsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_credentials to aggregate.
     */
    where?: user_credentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_credentials to fetch.
     */
    orderBy?: user_credentialsOrderByWithRelationInput | user_credentialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_credentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_credentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_credentials
    **/
    _count?: true | User_credentialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_credentialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_credentialsMaxAggregateInputType
  }

  export type GetUser_credentialsAggregateType<T extends User_credentialsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_credentials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_credentials[P]>
      : GetScalarType<T[P], AggregateUser_credentials[P]>
  }




  export type user_credentialsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_credentialsWhereInput
    orderBy?: user_credentialsOrderByWithAggregationInput | user_credentialsOrderByWithAggregationInput[]
    by: User_credentialsScalarFieldEnum[] | User_credentialsScalarFieldEnum
    having?: user_credentialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_credentialsCountAggregateInputType | true
    _min?: User_credentialsMinAggregateInputType
    _max?: User_credentialsMaxAggregateInputType
  }

  export type User_credentialsGroupByOutputType = {
    user_id: string
    username: string
    user_password: string
    user_first_name: string | null
    user_last_name: string | null
    user_email: string | null
    user_phone_number: string | null
    _count: User_credentialsCountAggregateOutputType | null
    _min: User_credentialsMinAggregateOutputType | null
    _max: User_credentialsMaxAggregateOutputType | null
  }

  type GetUser_credentialsGroupByPayload<T extends user_credentialsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_credentialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_credentialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_credentialsGroupByOutputType[P]>
            : GetScalarType<T[P], User_credentialsGroupByOutputType[P]>
        }
      >
    >


  export type user_credentialsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    username?: boolean
    user_password?: boolean
    user_first_name?: boolean
    user_last_name?: boolean
    user_email?: boolean
    user_phone_number?: boolean
    individuals?: boolean | user_credentials$individualsArgs<ExtArgs>
  }, ExtArgs["result"]["user_credentials"]>

  export type user_credentialsSelectScalar = {
    user_id?: boolean
    username?: boolean
    user_password?: boolean
    user_first_name?: boolean
    user_last_name?: boolean
    user_email?: boolean
    user_phone_number?: boolean
  }

  export type user_credentialsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    individuals?: boolean | user_credentials$individualsArgs<ExtArgs>
  }


  export type $user_credentialsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_credentials"
    objects: {
      individuals: Prisma.$individualsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: string
      username: string
      user_password: string
      user_first_name: string | null
      user_last_name: string | null
      user_email: string | null
      user_phone_number: string | null
    }, ExtArgs["result"]["user_credentials"]>
    composites: {}
  }


  type user_credentialsGetPayload<S extends boolean | null | undefined | user_credentialsDefaultArgs> = $Result.GetResult<Prisma.$user_credentialsPayload, S>

  type user_credentialsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<user_credentialsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_credentialsCountAggregateInputType | true
    }

  export interface user_credentialsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_credentials'], meta: { name: 'user_credentials' } }
    /**
     * Find zero or one User_credentials that matches the filter.
     * @param {user_credentialsFindUniqueArgs} args - Arguments to find a User_credentials
     * @example
     * // Get one User_credentials
     * const user_credentials = await prisma.user_credentials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_credentialsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, user_credentialsFindUniqueArgs<ExtArgs>>
    ): Prisma__user_credentialsClient<$Result.GetResult<Prisma.$user_credentialsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User_credentials that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {user_credentialsFindUniqueOrThrowArgs} args - Arguments to find a User_credentials
     * @example
     * // Get one User_credentials
     * const user_credentials = await prisma.user_credentials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends user_credentialsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_credentialsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__user_credentialsClient<$Result.GetResult<Prisma.$user_credentialsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User_credentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_credentialsFindFirstArgs} args - Arguments to find a User_credentials
     * @example
     * // Get one User_credentials
     * const user_credentials = await prisma.user_credentials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_credentialsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, user_credentialsFindFirstArgs<ExtArgs>>
    ): Prisma__user_credentialsClient<$Result.GetResult<Prisma.$user_credentialsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User_credentials that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_credentialsFindFirstOrThrowArgs} args - Arguments to find a User_credentials
     * @example
     * // Get one User_credentials
     * const user_credentials = await prisma.user_credentials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends user_credentialsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_credentialsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__user_credentialsClient<$Result.GetResult<Prisma.$user_credentialsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more User_credentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_credentialsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_credentials
     * const user_credentials = await prisma.user_credentials.findMany()
     * 
     * // Get first 10 User_credentials
     * const user_credentials = await prisma.user_credentials.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const user_credentialsWithUser_idOnly = await prisma.user_credentials.findMany({ select: { user_id: true } })
     * 
    **/
    findMany<T extends user_credentialsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_credentialsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_credentialsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User_credentials.
     * @param {user_credentialsCreateArgs} args - Arguments to create a User_credentials.
     * @example
     * // Create one User_credentials
     * const User_credentials = await prisma.user_credentials.create({
     *   data: {
     *     // ... data to create a User_credentials
     *   }
     * })
     * 
    **/
    create<T extends user_credentialsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, user_credentialsCreateArgs<ExtArgs>>
    ): Prisma__user_credentialsClient<$Result.GetResult<Prisma.$user_credentialsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many User_credentials.
     *     @param {user_credentialsCreateManyArgs} args - Arguments to create many User_credentials.
     *     @example
     *     // Create many User_credentials
     *     const user_credentials = await prisma.user_credentials.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends user_credentialsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_credentialsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_credentials.
     * @param {user_credentialsDeleteArgs} args - Arguments to delete one User_credentials.
     * @example
     * // Delete one User_credentials
     * const User_credentials = await prisma.user_credentials.delete({
     *   where: {
     *     // ... filter to delete one User_credentials
     *   }
     * })
     * 
    **/
    delete<T extends user_credentialsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, user_credentialsDeleteArgs<ExtArgs>>
    ): Prisma__user_credentialsClient<$Result.GetResult<Prisma.$user_credentialsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User_credentials.
     * @param {user_credentialsUpdateArgs} args - Arguments to update one User_credentials.
     * @example
     * // Update one User_credentials
     * const user_credentials = await prisma.user_credentials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_credentialsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, user_credentialsUpdateArgs<ExtArgs>>
    ): Prisma__user_credentialsClient<$Result.GetResult<Prisma.$user_credentialsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more User_credentials.
     * @param {user_credentialsDeleteManyArgs} args - Arguments to filter User_credentials to delete.
     * @example
     * // Delete a few User_credentials
     * const { count } = await prisma.user_credentials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_credentialsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_credentialsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_credentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_credentialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_credentials
     * const user_credentials = await prisma.user_credentials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_credentialsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, user_credentialsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_credentials.
     * @param {user_credentialsUpsertArgs} args - Arguments to update or create a User_credentials.
     * @example
     * // Update or create a User_credentials
     * const user_credentials = await prisma.user_credentials.upsert({
     *   create: {
     *     // ... data to create a User_credentials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_credentials we want to update
     *   }
     * })
    **/
    upsert<T extends user_credentialsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, user_credentialsUpsertArgs<ExtArgs>>
    ): Prisma__user_credentialsClient<$Result.GetResult<Prisma.$user_credentialsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of User_credentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_credentialsCountArgs} args - Arguments to filter User_credentials to count.
     * @example
     * // Count the number of User_credentials
     * const count = await prisma.user_credentials.count({
     *   where: {
     *     // ... the filter for the User_credentials we want to count
     *   }
     * })
    **/
    count<T extends user_credentialsCountArgs>(
      args?: Subset<T, user_credentialsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_credentialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_credentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_credentialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_credentialsAggregateArgs>(args: Subset<T, User_credentialsAggregateArgs>): Prisma.PrismaPromise<GetUser_credentialsAggregateType<T>>

    /**
     * Group by User_credentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_credentialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_credentialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_credentialsGroupByArgs['orderBy'] }
        : { orderBy?: user_credentialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_credentialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_credentialsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_credentials model
   */
  readonly fields: user_credentialsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_credentials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_credentialsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    individuals<T extends user_credentials$individualsArgs<ExtArgs> = {}>(args?: Subset<T, user_credentials$individualsArgs<ExtArgs>>): Prisma__individualsClient<$Result.GetResult<Prisma.$individualsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the user_credentials model
   */ 
  interface user_credentialsFieldRefs {
    readonly user_id: FieldRef<"user_credentials", 'String'>
    readonly username: FieldRef<"user_credentials", 'String'>
    readonly user_password: FieldRef<"user_credentials", 'String'>
    readonly user_first_name: FieldRef<"user_credentials", 'String'>
    readonly user_last_name: FieldRef<"user_credentials", 'String'>
    readonly user_email: FieldRef<"user_credentials", 'String'>
    readonly user_phone_number: FieldRef<"user_credentials", 'String'>
  }
    

  // Custom InputTypes

  /**
   * user_credentials findUnique
   */
  export type user_credentialsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credentials
     */
    select?: user_credentialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_credentialsInclude<ExtArgs> | null
    /**
     * Filter, which user_credentials to fetch.
     */
    where: user_credentialsWhereUniqueInput
  }


  /**
   * user_credentials findUniqueOrThrow
   */
  export type user_credentialsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credentials
     */
    select?: user_credentialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_credentialsInclude<ExtArgs> | null
    /**
     * Filter, which user_credentials to fetch.
     */
    where: user_credentialsWhereUniqueInput
  }


  /**
   * user_credentials findFirst
   */
  export type user_credentialsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credentials
     */
    select?: user_credentialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_credentialsInclude<ExtArgs> | null
    /**
     * Filter, which user_credentials to fetch.
     */
    where?: user_credentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_credentials to fetch.
     */
    orderBy?: user_credentialsOrderByWithRelationInput | user_credentialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_credentials.
     */
    cursor?: user_credentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_credentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_credentials.
     */
    distinct?: User_credentialsScalarFieldEnum | User_credentialsScalarFieldEnum[]
  }


  /**
   * user_credentials findFirstOrThrow
   */
  export type user_credentialsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credentials
     */
    select?: user_credentialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_credentialsInclude<ExtArgs> | null
    /**
     * Filter, which user_credentials to fetch.
     */
    where?: user_credentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_credentials to fetch.
     */
    orderBy?: user_credentialsOrderByWithRelationInput | user_credentialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_credentials.
     */
    cursor?: user_credentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_credentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_credentials.
     */
    distinct?: User_credentialsScalarFieldEnum | User_credentialsScalarFieldEnum[]
  }


  /**
   * user_credentials findMany
   */
  export type user_credentialsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credentials
     */
    select?: user_credentialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_credentialsInclude<ExtArgs> | null
    /**
     * Filter, which user_credentials to fetch.
     */
    where?: user_credentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_credentials to fetch.
     */
    orderBy?: user_credentialsOrderByWithRelationInput | user_credentialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_credentials.
     */
    cursor?: user_credentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_credentials.
     */
    skip?: number
    distinct?: User_credentialsScalarFieldEnum | User_credentialsScalarFieldEnum[]
  }


  /**
   * user_credentials create
   */
  export type user_credentialsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credentials
     */
    select?: user_credentialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_credentialsInclude<ExtArgs> | null
    /**
     * The data needed to create a user_credentials.
     */
    data: XOR<user_credentialsCreateInput, user_credentialsUncheckedCreateInput>
  }


  /**
   * user_credentials createMany
   */
  export type user_credentialsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_credentials.
     */
    data: user_credentialsCreateManyInput | user_credentialsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * user_credentials update
   */
  export type user_credentialsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credentials
     */
    select?: user_credentialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_credentialsInclude<ExtArgs> | null
    /**
     * The data needed to update a user_credentials.
     */
    data: XOR<user_credentialsUpdateInput, user_credentialsUncheckedUpdateInput>
    /**
     * Choose, which user_credentials to update.
     */
    where: user_credentialsWhereUniqueInput
  }


  /**
   * user_credentials updateMany
   */
  export type user_credentialsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_credentials.
     */
    data: XOR<user_credentialsUpdateManyMutationInput, user_credentialsUncheckedUpdateManyInput>
    /**
     * Filter which user_credentials to update
     */
    where?: user_credentialsWhereInput
  }


  /**
   * user_credentials upsert
   */
  export type user_credentialsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credentials
     */
    select?: user_credentialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_credentialsInclude<ExtArgs> | null
    /**
     * The filter to search for the user_credentials to update in case it exists.
     */
    where: user_credentialsWhereUniqueInput
    /**
     * In case the user_credentials found by the `where` argument doesn't exist, create a new user_credentials with this data.
     */
    create: XOR<user_credentialsCreateInput, user_credentialsUncheckedCreateInput>
    /**
     * In case the user_credentials was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_credentialsUpdateInput, user_credentialsUncheckedUpdateInput>
  }


  /**
   * user_credentials delete
   */
  export type user_credentialsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credentials
     */
    select?: user_credentialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_credentialsInclude<ExtArgs> | null
    /**
     * Filter which user_credentials to delete.
     */
    where: user_credentialsWhereUniqueInput
  }


  /**
   * user_credentials deleteMany
   */
  export type user_credentialsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_credentials to delete
     */
    where?: user_credentialsWhereInput
  }


  /**
   * user_credentials.individuals
   */
  export type user_credentials$individualsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the individuals
     */
    select?: individualsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: individualsInclude<ExtArgs> | null
    where?: individualsWhereInput
  }


  /**
   * user_credentials without action
   */
  export type user_credentialsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credentials
     */
    select?: user_credentialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_credentialsInclude<ExtArgs> | null
  }



  /**
   * Model videos
   */

  export type AggregateVideos = {
    _count: VideosCountAggregateOutputType | null
    _avg: VideosAvgAggregateOutputType | null
    _sum: VideosSumAggregateOutputType | null
    _min: VideosMinAggregateOutputType | null
    _max: VideosMaxAggregateOutputType | null
  }

  export type VideosAvgAggregateOutputType = {
    video_likes: number | null
    video_dislikes: number | null
    video_views: number | null
  }

  export type VideosSumAggregateOutputType = {
    video_likes: number | null
    video_dislikes: number | null
    video_views: number | null
  }

  export type VideosMinAggregateOutputType = {
    video_id: string | null
    video_creator_id: string | null
    video_title: string | null
    video_description: string | null
    video_filename: string | null
    video_data_id: string | null
    video_thumbnail_id: string | null
    video_likes: number | null
    video_dislikes: number | null
    video_views: number | null
    video_date_posted: Date | null
  }

  export type VideosMaxAggregateOutputType = {
    video_id: string | null
    video_creator_id: string | null
    video_title: string | null
    video_description: string | null
    video_filename: string | null
    video_data_id: string | null
    video_thumbnail_id: string | null
    video_likes: number | null
    video_dislikes: number | null
    video_views: number | null
    video_date_posted: Date | null
  }

  export type VideosCountAggregateOutputType = {
    video_id: number
    video_creator_id: number
    video_title: number
    video_description: number
    video_filename: number
    video_data_id: number
    video_thumbnail_id: number
    video_likes: number
    video_dislikes: number
    video_views: number
    video_date_posted: number
    _all: number
  }


  export type VideosAvgAggregateInputType = {
    video_likes?: true
    video_dislikes?: true
    video_views?: true
  }

  export type VideosSumAggregateInputType = {
    video_likes?: true
    video_dislikes?: true
    video_views?: true
  }

  export type VideosMinAggregateInputType = {
    video_id?: true
    video_creator_id?: true
    video_title?: true
    video_description?: true
    video_filename?: true
    video_data_id?: true
    video_thumbnail_id?: true
    video_likes?: true
    video_dislikes?: true
    video_views?: true
    video_date_posted?: true
  }

  export type VideosMaxAggregateInputType = {
    video_id?: true
    video_creator_id?: true
    video_title?: true
    video_description?: true
    video_filename?: true
    video_data_id?: true
    video_thumbnail_id?: true
    video_likes?: true
    video_dislikes?: true
    video_views?: true
    video_date_posted?: true
  }

  export type VideosCountAggregateInputType = {
    video_id?: true
    video_creator_id?: true
    video_title?: true
    video_description?: true
    video_filename?: true
    video_data_id?: true
    video_thumbnail_id?: true
    video_likes?: true
    video_dislikes?: true
    video_views?: true
    video_date_posted?: true
    _all?: true
  }

  export type VideosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which videos to aggregate.
     */
    where?: videosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos to fetch.
     */
    orderBy?: videosOrderByWithRelationInput | videosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: videosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned videos
    **/
    _count?: true | VideosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideosMaxAggregateInputType
  }

  export type GetVideosAggregateType<T extends VideosAggregateArgs> = {
        [P in keyof T & keyof AggregateVideos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideos[P]>
      : GetScalarType<T[P], AggregateVideos[P]>
  }




  export type videosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: videosWhereInput
    orderBy?: videosOrderByWithAggregationInput | videosOrderByWithAggregationInput[]
    by: VideosScalarFieldEnum[] | VideosScalarFieldEnum
    having?: videosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideosCountAggregateInputType | true
    _avg?: VideosAvgAggregateInputType
    _sum?: VideosSumAggregateInputType
    _min?: VideosMinAggregateInputType
    _max?: VideosMaxAggregateInputType
  }

  export type VideosGroupByOutputType = {
    video_id: string
    video_creator_id: string
    video_title: string
    video_description: string
    video_filename: string
    video_data_id: string
    video_thumbnail_id: string | null
    video_likes: number
    video_dislikes: number
    video_views: number
    video_date_posted: Date | null
    _count: VideosCountAggregateOutputType | null
    _avg: VideosAvgAggregateOutputType | null
    _sum: VideosSumAggregateOutputType | null
    _min: VideosMinAggregateOutputType | null
    _max: VideosMaxAggregateOutputType | null
  }

  type GetVideosGroupByPayload<T extends videosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideosGroupByOutputType[P]>
            : GetScalarType<T[P], VideosGroupByOutputType[P]>
        }
      >
    >


  export type videosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    video_id?: boolean
    video_creator_id?: boolean
    video_title?: boolean
    video_description?: boolean
    video_filename?: boolean
    video_data_id?: boolean
    video_thumbnail_id?: boolean
    video_likes?: boolean
    video_dislikes?: boolean
    video_views?: boolean
    video_date_posted?: boolean
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
    videos_data?: boolean | videos_dataDefaultArgs<ExtArgs>
    videos_thumbnails?: boolean | videos$videos_thumbnailsArgs<ExtArgs>
  }, ExtArgs["result"]["videos"]>

  export type videosSelectScalar = {
    video_id?: boolean
    video_creator_id?: boolean
    video_title?: boolean
    video_description?: boolean
    video_filename?: boolean
    video_data_id?: boolean
    video_thumbnail_id?: boolean
    video_likes?: boolean
    video_dislikes?: boolean
    video_views?: boolean
    video_date_posted?: boolean
  }

  export type videosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
    videos_data?: boolean | videos_dataDefaultArgs<ExtArgs>
    videos_thumbnails?: boolean | videos$videos_thumbnailsArgs<ExtArgs>
  }


  export type $videosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "videos"
    objects: {
      entities: Prisma.$entitiesPayload<ExtArgs>
      videos_data: Prisma.$videos_dataPayload<ExtArgs>
      videos_thumbnails: Prisma.$videos_thumbnailsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      video_id: string
      video_creator_id: string
      video_title: string
      video_description: string
      video_filename: string
      video_data_id: string
      video_thumbnail_id: string | null
      video_likes: number
      video_dislikes: number
      video_views: number
      video_date_posted: Date | null
    }, ExtArgs["result"]["videos"]>
    composites: {}
  }


  type videosGetPayload<S extends boolean | null | undefined | videosDefaultArgs> = $Result.GetResult<Prisma.$videosPayload, S>

  type videosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<videosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VideosCountAggregateInputType | true
    }

  export interface videosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['videos'], meta: { name: 'videos' } }
    /**
     * Find zero or one Videos that matches the filter.
     * @param {videosFindUniqueArgs} args - Arguments to find a Videos
     * @example
     * // Get one Videos
     * const videos = await prisma.videos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends videosFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, videosFindUniqueArgs<ExtArgs>>
    ): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Videos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {videosFindUniqueOrThrowArgs} args - Arguments to find a Videos
     * @example
     * // Get one Videos
     * const videos = await prisma.videos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends videosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, videosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videosFindFirstArgs} args - Arguments to find a Videos
     * @example
     * // Get one Videos
     * const videos = await prisma.videos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends videosFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, videosFindFirstArgs<ExtArgs>>
    ): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Videos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videosFindFirstOrThrowArgs} args - Arguments to find a Videos
     * @example
     * // Get one Videos
     * const videos = await prisma.videos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends videosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, videosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videos
     * const videos = await prisma.videos.findMany()
     * 
     * // Get first 10 Videos
     * const videos = await prisma.videos.findMany({ take: 10 })
     * 
     * // Only select the `video_id`
     * const videosWithVideo_idOnly = await prisma.videos.findMany({ select: { video_id: true } })
     * 
    **/
    findMany<T extends videosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, videosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Videos.
     * @param {videosCreateArgs} args - Arguments to create a Videos.
     * @example
     * // Create one Videos
     * const Videos = await prisma.videos.create({
     *   data: {
     *     // ... data to create a Videos
     *   }
     * })
     * 
    **/
    create<T extends videosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, videosCreateArgs<ExtArgs>>
    ): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Videos.
     *     @param {videosCreateManyArgs} args - Arguments to create many Videos.
     *     @example
     *     // Create many Videos
     *     const videos = await prisma.videos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends videosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, videosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Videos.
     * @param {videosDeleteArgs} args - Arguments to delete one Videos.
     * @example
     * // Delete one Videos
     * const Videos = await prisma.videos.delete({
     *   where: {
     *     // ... filter to delete one Videos
     *   }
     * })
     * 
    **/
    delete<T extends videosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, videosDeleteArgs<ExtArgs>>
    ): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Videos.
     * @param {videosUpdateArgs} args - Arguments to update one Videos.
     * @example
     * // Update one Videos
     * const videos = await prisma.videos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends videosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, videosUpdateArgs<ExtArgs>>
    ): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Videos.
     * @param {videosDeleteManyArgs} args - Arguments to filter Videos to delete.
     * @example
     * // Delete a few Videos
     * const { count } = await prisma.videos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends videosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, videosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videos
     * const videos = await prisma.videos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends videosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, videosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Videos.
     * @param {videosUpsertArgs} args - Arguments to update or create a Videos.
     * @example
     * // Update or create a Videos
     * const videos = await prisma.videos.upsert({
     *   create: {
     *     // ... data to create a Videos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Videos we want to update
     *   }
     * })
    **/
    upsert<T extends videosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, videosUpsertArgs<ExtArgs>>
    ): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videosCountArgs} args - Arguments to filter Videos to count.
     * @example
     * // Count the number of Videos
     * const count = await prisma.videos.count({
     *   where: {
     *     // ... the filter for the Videos we want to count
     *   }
     * })
    **/
    count<T extends videosCountArgs>(
      args?: Subset<T, videosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideosAggregateArgs>(args: Subset<T, VideosAggregateArgs>): Prisma.PrismaPromise<GetVideosAggregateType<T>>

    /**
     * Group by Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends videosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: videosGroupByArgs['orderBy'] }
        : { orderBy?: videosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, videosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the videos model
   */
  readonly fields: videosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for videos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__videosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    entities<T extends entitiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, entitiesDefaultArgs<ExtArgs>>): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    videos_data<T extends videos_dataDefaultArgs<ExtArgs> = {}>(args?: Subset<T, videos_dataDefaultArgs<ExtArgs>>): Prisma__videos_dataClient<$Result.GetResult<Prisma.$videos_dataPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    videos_thumbnails<T extends videos$videos_thumbnailsArgs<ExtArgs> = {}>(args?: Subset<T, videos$videos_thumbnailsArgs<ExtArgs>>): Prisma__videos_thumbnailsClient<$Result.GetResult<Prisma.$videos_thumbnailsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the videos model
   */ 
  interface videosFieldRefs {
    readonly video_id: FieldRef<"videos", 'String'>
    readonly video_creator_id: FieldRef<"videos", 'String'>
    readonly video_title: FieldRef<"videos", 'String'>
    readonly video_description: FieldRef<"videos", 'String'>
    readonly video_filename: FieldRef<"videos", 'String'>
    readonly video_data_id: FieldRef<"videos", 'String'>
    readonly video_thumbnail_id: FieldRef<"videos", 'String'>
    readonly video_likes: FieldRef<"videos", 'Int'>
    readonly video_dislikes: FieldRef<"videos", 'Int'>
    readonly video_views: FieldRef<"videos", 'Int'>
    readonly video_date_posted: FieldRef<"videos", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * videos findUnique
   */
  export type videosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videosInclude<ExtArgs> | null
    /**
     * Filter, which videos to fetch.
     */
    where: videosWhereUniqueInput
  }


  /**
   * videos findUniqueOrThrow
   */
  export type videosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videosInclude<ExtArgs> | null
    /**
     * Filter, which videos to fetch.
     */
    where: videosWhereUniqueInput
  }


  /**
   * videos findFirst
   */
  export type videosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videosInclude<ExtArgs> | null
    /**
     * Filter, which videos to fetch.
     */
    where?: videosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos to fetch.
     */
    orderBy?: videosOrderByWithRelationInput | videosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for videos.
     */
    cursor?: videosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of videos.
     */
    distinct?: VideosScalarFieldEnum | VideosScalarFieldEnum[]
  }


  /**
   * videos findFirstOrThrow
   */
  export type videosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videosInclude<ExtArgs> | null
    /**
     * Filter, which videos to fetch.
     */
    where?: videosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos to fetch.
     */
    orderBy?: videosOrderByWithRelationInput | videosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for videos.
     */
    cursor?: videosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of videos.
     */
    distinct?: VideosScalarFieldEnum | VideosScalarFieldEnum[]
  }


  /**
   * videos findMany
   */
  export type videosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videosInclude<ExtArgs> | null
    /**
     * Filter, which videos to fetch.
     */
    where?: videosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos to fetch.
     */
    orderBy?: videosOrderByWithRelationInput | videosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing videos.
     */
    cursor?: videosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos.
     */
    skip?: number
    distinct?: VideosScalarFieldEnum | VideosScalarFieldEnum[]
  }


  /**
   * videos create
   */
  export type videosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videosInclude<ExtArgs> | null
    /**
     * The data needed to create a videos.
     */
    data: XOR<videosCreateInput, videosUncheckedCreateInput>
  }


  /**
   * videos createMany
   */
  export type videosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many videos.
     */
    data: videosCreateManyInput | videosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * videos update
   */
  export type videosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videosInclude<ExtArgs> | null
    /**
     * The data needed to update a videos.
     */
    data: XOR<videosUpdateInput, videosUncheckedUpdateInput>
    /**
     * Choose, which videos to update.
     */
    where: videosWhereUniqueInput
  }


  /**
   * videos updateMany
   */
  export type videosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update videos.
     */
    data: XOR<videosUpdateManyMutationInput, videosUncheckedUpdateManyInput>
    /**
     * Filter which videos to update
     */
    where?: videosWhereInput
  }


  /**
   * videos upsert
   */
  export type videosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videosInclude<ExtArgs> | null
    /**
     * The filter to search for the videos to update in case it exists.
     */
    where: videosWhereUniqueInput
    /**
     * In case the videos found by the `where` argument doesn't exist, create a new videos with this data.
     */
    create: XOR<videosCreateInput, videosUncheckedCreateInput>
    /**
     * In case the videos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<videosUpdateInput, videosUncheckedUpdateInput>
  }


  /**
   * videos delete
   */
  export type videosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videosInclude<ExtArgs> | null
    /**
     * Filter which videos to delete.
     */
    where: videosWhereUniqueInput
  }


  /**
   * videos deleteMany
   */
  export type videosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which videos to delete
     */
    where?: videosWhereInput
  }


  /**
   * videos.videos_thumbnails
   */
  export type videos$videos_thumbnailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_thumbnails
     */
    select?: videos_thumbnailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videos_thumbnailsInclude<ExtArgs> | null
    where?: videos_thumbnailsWhereInput
  }


  /**
   * videos without action
   */
  export type videosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videosInclude<ExtArgs> | null
  }



  /**
   * Model videos_data
   */

  export type AggregateVideos_data = {
    _count: Videos_dataCountAggregateOutputType | null
    _min: Videos_dataMinAggregateOutputType | null
    _max: Videos_dataMaxAggregateOutputType | null
  }

  export type Videos_dataMinAggregateOutputType = {
    video_data_id: string | null
    video_data: Buffer | null
  }

  export type Videos_dataMaxAggregateOutputType = {
    video_data_id: string | null
    video_data: Buffer | null
  }

  export type Videos_dataCountAggregateOutputType = {
    video_data_id: number
    video_data: number
    _all: number
  }


  export type Videos_dataMinAggregateInputType = {
    video_data_id?: true
    video_data?: true
  }

  export type Videos_dataMaxAggregateInputType = {
    video_data_id?: true
    video_data?: true
  }

  export type Videos_dataCountAggregateInputType = {
    video_data_id?: true
    video_data?: true
    _all?: true
  }

  export type Videos_dataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which videos_data to aggregate.
     */
    where?: videos_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos_data to fetch.
     */
    orderBy?: videos_dataOrderByWithRelationInput | videos_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: videos_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned videos_data
    **/
    _count?: true | Videos_dataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Videos_dataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Videos_dataMaxAggregateInputType
  }

  export type GetVideos_dataAggregateType<T extends Videos_dataAggregateArgs> = {
        [P in keyof T & keyof AggregateVideos_data]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideos_data[P]>
      : GetScalarType<T[P], AggregateVideos_data[P]>
  }




  export type videos_dataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: videos_dataWhereInput
    orderBy?: videos_dataOrderByWithAggregationInput | videos_dataOrderByWithAggregationInput[]
    by: Videos_dataScalarFieldEnum[] | Videos_dataScalarFieldEnum
    having?: videos_dataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Videos_dataCountAggregateInputType | true
    _min?: Videos_dataMinAggregateInputType
    _max?: Videos_dataMaxAggregateInputType
  }

  export type Videos_dataGroupByOutputType = {
    video_data_id: string
    video_data: Buffer
    _count: Videos_dataCountAggregateOutputType | null
    _min: Videos_dataMinAggregateOutputType | null
    _max: Videos_dataMaxAggregateOutputType | null
  }

  type GetVideos_dataGroupByPayload<T extends videos_dataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Videos_dataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Videos_dataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Videos_dataGroupByOutputType[P]>
            : GetScalarType<T[P], Videos_dataGroupByOutputType[P]>
        }
      >
    >


  export type videos_dataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    video_data_id?: boolean
    video_data?: boolean
    videos?: boolean | videos_data$videosArgs<ExtArgs>
    _count?: boolean | Videos_dataCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videos_data"]>

  export type videos_dataSelectScalar = {
    video_data_id?: boolean
    video_data?: boolean
  }

  export type videos_dataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videos?: boolean | videos_data$videosArgs<ExtArgs>
    _count?: boolean | Videos_dataCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $videos_dataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "videos_data"
    objects: {
      videos: Prisma.$videosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      video_data_id: string
      video_data: Buffer
    }, ExtArgs["result"]["videos_data"]>
    composites: {}
  }


  type videos_dataGetPayload<S extends boolean | null | undefined | videos_dataDefaultArgs> = $Result.GetResult<Prisma.$videos_dataPayload, S>

  type videos_dataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<videos_dataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Videos_dataCountAggregateInputType | true
    }

  export interface videos_dataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['videos_data'], meta: { name: 'videos_data' } }
    /**
     * Find zero or one Videos_data that matches the filter.
     * @param {videos_dataFindUniqueArgs} args - Arguments to find a Videos_data
     * @example
     * // Get one Videos_data
     * const videos_data = await prisma.videos_data.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends videos_dataFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, videos_dataFindUniqueArgs<ExtArgs>>
    ): Prisma__videos_dataClient<$Result.GetResult<Prisma.$videos_dataPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Videos_data that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {videos_dataFindUniqueOrThrowArgs} args - Arguments to find a Videos_data
     * @example
     * // Get one Videos_data
     * const videos_data = await prisma.videos_data.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends videos_dataFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, videos_dataFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__videos_dataClient<$Result.GetResult<Prisma.$videos_dataPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Videos_data that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_dataFindFirstArgs} args - Arguments to find a Videos_data
     * @example
     * // Get one Videos_data
     * const videos_data = await prisma.videos_data.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends videos_dataFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, videos_dataFindFirstArgs<ExtArgs>>
    ): Prisma__videos_dataClient<$Result.GetResult<Prisma.$videos_dataPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Videos_data that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_dataFindFirstOrThrowArgs} args - Arguments to find a Videos_data
     * @example
     * // Get one Videos_data
     * const videos_data = await prisma.videos_data.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends videos_dataFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, videos_dataFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__videos_dataClient<$Result.GetResult<Prisma.$videos_dataPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Videos_data that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_dataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videos_data
     * const videos_data = await prisma.videos_data.findMany()
     * 
     * // Get first 10 Videos_data
     * const videos_data = await prisma.videos_data.findMany({ take: 10 })
     * 
     * // Only select the `video_data_id`
     * const videos_dataWithVideo_data_idOnly = await prisma.videos_data.findMany({ select: { video_data_id: true } })
     * 
    **/
    findMany<T extends videos_dataFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, videos_dataFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$videos_dataPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Videos_data.
     * @param {videos_dataCreateArgs} args - Arguments to create a Videos_data.
     * @example
     * // Create one Videos_data
     * const Videos_data = await prisma.videos_data.create({
     *   data: {
     *     // ... data to create a Videos_data
     *   }
     * })
     * 
    **/
    create<T extends videos_dataCreateArgs<ExtArgs>>(
      args: SelectSubset<T, videos_dataCreateArgs<ExtArgs>>
    ): Prisma__videos_dataClient<$Result.GetResult<Prisma.$videos_dataPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Videos_data.
     *     @param {videos_dataCreateManyArgs} args - Arguments to create many Videos_data.
     *     @example
     *     // Create many Videos_data
     *     const videos_data = await prisma.videos_data.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends videos_dataCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, videos_dataCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Videos_data.
     * @param {videos_dataDeleteArgs} args - Arguments to delete one Videos_data.
     * @example
     * // Delete one Videos_data
     * const Videos_data = await prisma.videos_data.delete({
     *   where: {
     *     // ... filter to delete one Videos_data
     *   }
     * })
     * 
    **/
    delete<T extends videos_dataDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, videos_dataDeleteArgs<ExtArgs>>
    ): Prisma__videos_dataClient<$Result.GetResult<Prisma.$videos_dataPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Videos_data.
     * @param {videos_dataUpdateArgs} args - Arguments to update one Videos_data.
     * @example
     * // Update one Videos_data
     * const videos_data = await prisma.videos_data.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends videos_dataUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, videos_dataUpdateArgs<ExtArgs>>
    ): Prisma__videos_dataClient<$Result.GetResult<Prisma.$videos_dataPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Videos_data.
     * @param {videos_dataDeleteManyArgs} args - Arguments to filter Videos_data to delete.
     * @example
     * // Delete a few Videos_data
     * const { count } = await prisma.videos_data.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends videos_dataDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, videos_dataDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_dataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videos_data
     * const videos_data = await prisma.videos_data.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends videos_dataUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, videos_dataUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Videos_data.
     * @param {videos_dataUpsertArgs} args - Arguments to update or create a Videos_data.
     * @example
     * // Update or create a Videos_data
     * const videos_data = await prisma.videos_data.upsert({
     *   create: {
     *     // ... data to create a Videos_data
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Videos_data we want to update
     *   }
     * })
    **/
    upsert<T extends videos_dataUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, videos_dataUpsertArgs<ExtArgs>>
    ): Prisma__videos_dataClient<$Result.GetResult<Prisma.$videos_dataPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Videos_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_dataCountArgs} args - Arguments to filter Videos_data to count.
     * @example
     * // Count the number of Videos_data
     * const count = await prisma.videos_data.count({
     *   where: {
     *     // ... the filter for the Videos_data we want to count
     *   }
     * })
    **/
    count<T extends videos_dataCountArgs>(
      args?: Subset<T, videos_dataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Videos_dataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Videos_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Videos_dataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Videos_dataAggregateArgs>(args: Subset<T, Videos_dataAggregateArgs>): Prisma.PrismaPromise<GetVideos_dataAggregateType<T>>

    /**
     * Group by Videos_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_dataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends videos_dataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: videos_dataGroupByArgs['orderBy'] }
        : { orderBy?: videos_dataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, videos_dataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideos_dataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the videos_data model
   */
  readonly fields: videos_dataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for videos_data.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__videos_dataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    videos<T extends videos_data$videosArgs<ExtArgs> = {}>(args?: Subset<T, videos_data$videosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the videos_data model
   */ 
  interface videos_dataFieldRefs {
    readonly video_data_id: FieldRef<"videos_data", 'String'>
    readonly video_data: FieldRef<"videos_data", 'Bytes'>
  }
    

  // Custom InputTypes

  /**
   * videos_data findUnique
   */
  export type videos_dataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_data
     */
    select?: videos_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videos_dataInclude<ExtArgs> | null
    /**
     * Filter, which videos_data to fetch.
     */
    where: videos_dataWhereUniqueInput
  }


  /**
   * videos_data findUniqueOrThrow
   */
  export type videos_dataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_data
     */
    select?: videos_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videos_dataInclude<ExtArgs> | null
    /**
     * Filter, which videos_data to fetch.
     */
    where: videos_dataWhereUniqueInput
  }


  /**
   * videos_data findFirst
   */
  export type videos_dataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_data
     */
    select?: videos_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videos_dataInclude<ExtArgs> | null
    /**
     * Filter, which videos_data to fetch.
     */
    where?: videos_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos_data to fetch.
     */
    orderBy?: videos_dataOrderByWithRelationInput | videos_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for videos_data.
     */
    cursor?: videos_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of videos_data.
     */
    distinct?: Videos_dataScalarFieldEnum | Videos_dataScalarFieldEnum[]
  }


  /**
   * videos_data findFirstOrThrow
   */
  export type videos_dataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_data
     */
    select?: videos_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videos_dataInclude<ExtArgs> | null
    /**
     * Filter, which videos_data to fetch.
     */
    where?: videos_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos_data to fetch.
     */
    orderBy?: videos_dataOrderByWithRelationInput | videos_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for videos_data.
     */
    cursor?: videos_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of videos_data.
     */
    distinct?: Videos_dataScalarFieldEnum | Videos_dataScalarFieldEnum[]
  }


  /**
   * videos_data findMany
   */
  export type videos_dataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_data
     */
    select?: videos_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videos_dataInclude<ExtArgs> | null
    /**
     * Filter, which videos_data to fetch.
     */
    where?: videos_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos_data to fetch.
     */
    orderBy?: videos_dataOrderByWithRelationInput | videos_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing videos_data.
     */
    cursor?: videos_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos_data.
     */
    skip?: number
    distinct?: Videos_dataScalarFieldEnum | Videos_dataScalarFieldEnum[]
  }


  /**
   * videos_data create
   */
  export type videos_dataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_data
     */
    select?: videos_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videos_dataInclude<ExtArgs> | null
    /**
     * The data needed to create a videos_data.
     */
    data: XOR<videos_dataCreateInput, videos_dataUncheckedCreateInput>
  }


  /**
   * videos_data createMany
   */
  export type videos_dataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many videos_data.
     */
    data: videos_dataCreateManyInput | videos_dataCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * videos_data update
   */
  export type videos_dataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_data
     */
    select?: videos_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videos_dataInclude<ExtArgs> | null
    /**
     * The data needed to update a videos_data.
     */
    data: XOR<videos_dataUpdateInput, videos_dataUncheckedUpdateInput>
    /**
     * Choose, which videos_data to update.
     */
    where: videos_dataWhereUniqueInput
  }


  /**
   * videos_data updateMany
   */
  export type videos_dataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update videos_data.
     */
    data: XOR<videos_dataUpdateManyMutationInput, videos_dataUncheckedUpdateManyInput>
    /**
     * Filter which videos_data to update
     */
    where?: videos_dataWhereInput
  }


  /**
   * videos_data upsert
   */
  export type videos_dataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_data
     */
    select?: videos_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videos_dataInclude<ExtArgs> | null
    /**
     * The filter to search for the videos_data to update in case it exists.
     */
    where: videos_dataWhereUniqueInput
    /**
     * In case the videos_data found by the `where` argument doesn't exist, create a new videos_data with this data.
     */
    create: XOR<videos_dataCreateInput, videos_dataUncheckedCreateInput>
    /**
     * In case the videos_data was found with the provided `where` argument, update it with this data.
     */
    update: XOR<videos_dataUpdateInput, videos_dataUncheckedUpdateInput>
  }


  /**
   * videos_data delete
   */
  export type videos_dataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_data
     */
    select?: videos_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videos_dataInclude<ExtArgs> | null
    /**
     * Filter which videos_data to delete.
     */
    where: videos_dataWhereUniqueInput
  }


  /**
   * videos_data deleteMany
   */
  export type videos_dataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which videos_data to delete
     */
    where?: videos_dataWhereInput
  }


  /**
   * videos_data.videos
   */
  export type videos_data$videosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videosInclude<ExtArgs> | null
    where?: videosWhereInput
    orderBy?: videosOrderByWithRelationInput | videosOrderByWithRelationInput[]
    cursor?: videosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideosScalarFieldEnum | VideosScalarFieldEnum[]
  }


  /**
   * videos_data without action
   */
  export type videos_dataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_data
     */
    select?: videos_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videos_dataInclude<ExtArgs> | null
  }



  /**
   * Model videos_thumbnails
   */

  export type AggregateVideos_thumbnails = {
    _count: Videos_thumbnailsCountAggregateOutputType | null
    _min: Videos_thumbnailsMinAggregateOutputType | null
    _max: Videos_thumbnailsMaxAggregateOutputType | null
  }

  export type Videos_thumbnailsMinAggregateOutputType = {
    video_thumbnail_id: string | null
    video_thumbnail_data: Buffer | null
    video_thumbnail_filename: string | null
    video_thumbnail_description: string | null
  }

  export type Videos_thumbnailsMaxAggregateOutputType = {
    video_thumbnail_id: string | null
    video_thumbnail_data: Buffer | null
    video_thumbnail_filename: string | null
    video_thumbnail_description: string | null
  }

  export type Videos_thumbnailsCountAggregateOutputType = {
    video_thumbnail_id: number
    video_thumbnail_data: number
    video_thumbnail_filename: number
    video_thumbnail_description: number
    _all: number
  }


  export type Videos_thumbnailsMinAggregateInputType = {
    video_thumbnail_id?: true
    video_thumbnail_data?: true
    video_thumbnail_filename?: true
    video_thumbnail_description?: true
  }

  export type Videos_thumbnailsMaxAggregateInputType = {
    video_thumbnail_id?: true
    video_thumbnail_data?: true
    video_thumbnail_filename?: true
    video_thumbnail_description?: true
  }

  export type Videos_thumbnailsCountAggregateInputType = {
    video_thumbnail_id?: true
    video_thumbnail_data?: true
    video_thumbnail_filename?: true
    video_thumbnail_description?: true
    _all?: true
  }

  export type Videos_thumbnailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which videos_thumbnails to aggregate.
     */
    where?: videos_thumbnailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos_thumbnails to fetch.
     */
    orderBy?: videos_thumbnailsOrderByWithRelationInput | videos_thumbnailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: videos_thumbnailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos_thumbnails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos_thumbnails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned videos_thumbnails
    **/
    _count?: true | Videos_thumbnailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Videos_thumbnailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Videos_thumbnailsMaxAggregateInputType
  }

  export type GetVideos_thumbnailsAggregateType<T extends Videos_thumbnailsAggregateArgs> = {
        [P in keyof T & keyof AggregateVideos_thumbnails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideos_thumbnails[P]>
      : GetScalarType<T[P], AggregateVideos_thumbnails[P]>
  }




  export type videos_thumbnailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: videos_thumbnailsWhereInput
    orderBy?: videos_thumbnailsOrderByWithAggregationInput | videos_thumbnailsOrderByWithAggregationInput[]
    by: Videos_thumbnailsScalarFieldEnum[] | Videos_thumbnailsScalarFieldEnum
    having?: videos_thumbnailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Videos_thumbnailsCountAggregateInputType | true
    _min?: Videos_thumbnailsMinAggregateInputType
    _max?: Videos_thumbnailsMaxAggregateInputType
  }

  export type Videos_thumbnailsGroupByOutputType = {
    video_thumbnail_id: string
    video_thumbnail_data: Buffer
    video_thumbnail_filename: string
    video_thumbnail_description: string | null
    _count: Videos_thumbnailsCountAggregateOutputType | null
    _min: Videos_thumbnailsMinAggregateOutputType | null
    _max: Videos_thumbnailsMaxAggregateOutputType | null
  }

  type GetVideos_thumbnailsGroupByPayload<T extends videos_thumbnailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Videos_thumbnailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Videos_thumbnailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Videos_thumbnailsGroupByOutputType[P]>
            : GetScalarType<T[P], Videos_thumbnailsGroupByOutputType[P]>
        }
      >
    >


  export type videos_thumbnailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    video_thumbnail_id?: boolean
    video_thumbnail_data?: boolean
    video_thumbnail_filename?: boolean
    video_thumbnail_description?: boolean
    videos?: boolean | videos_thumbnails$videosArgs<ExtArgs>
    _count?: boolean | Videos_thumbnailsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videos_thumbnails"]>

  export type videos_thumbnailsSelectScalar = {
    video_thumbnail_id?: boolean
    video_thumbnail_data?: boolean
    video_thumbnail_filename?: boolean
    video_thumbnail_description?: boolean
  }

  export type videos_thumbnailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videos?: boolean | videos_thumbnails$videosArgs<ExtArgs>
    _count?: boolean | Videos_thumbnailsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $videos_thumbnailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "videos_thumbnails"
    objects: {
      videos: Prisma.$videosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      video_thumbnail_id: string
      video_thumbnail_data: Buffer
      video_thumbnail_filename: string
      video_thumbnail_description: string | null
    }, ExtArgs["result"]["videos_thumbnails"]>
    composites: {}
  }


  type videos_thumbnailsGetPayload<S extends boolean | null | undefined | videos_thumbnailsDefaultArgs> = $Result.GetResult<Prisma.$videos_thumbnailsPayload, S>

  type videos_thumbnailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<videos_thumbnailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Videos_thumbnailsCountAggregateInputType | true
    }

  export interface videos_thumbnailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['videos_thumbnails'], meta: { name: 'videos_thumbnails' } }
    /**
     * Find zero or one Videos_thumbnails that matches the filter.
     * @param {videos_thumbnailsFindUniqueArgs} args - Arguments to find a Videos_thumbnails
     * @example
     * // Get one Videos_thumbnails
     * const videos_thumbnails = await prisma.videos_thumbnails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends videos_thumbnailsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, videos_thumbnailsFindUniqueArgs<ExtArgs>>
    ): Prisma__videos_thumbnailsClient<$Result.GetResult<Prisma.$videos_thumbnailsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Videos_thumbnails that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {videos_thumbnailsFindUniqueOrThrowArgs} args - Arguments to find a Videos_thumbnails
     * @example
     * // Get one Videos_thumbnails
     * const videos_thumbnails = await prisma.videos_thumbnails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends videos_thumbnailsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, videos_thumbnailsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__videos_thumbnailsClient<$Result.GetResult<Prisma.$videos_thumbnailsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Videos_thumbnails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_thumbnailsFindFirstArgs} args - Arguments to find a Videos_thumbnails
     * @example
     * // Get one Videos_thumbnails
     * const videos_thumbnails = await prisma.videos_thumbnails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends videos_thumbnailsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, videos_thumbnailsFindFirstArgs<ExtArgs>>
    ): Prisma__videos_thumbnailsClient<$Result.GetResult<Prisma.$videos_thumbnailsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Videos_thumbnails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_thumbnailsFindFirstOrThrowArgs} args - Arguments to find a Videos_thumbnails
     * @example
     * // Get one Videos_thumbnails
     * const videos_thumbnails = await prisma.videos_thumbnails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends videos_thumbnailsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, videos_thumbnailsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__videos_thumbnailsClient<$Result.GetResult<Prisma.$videos_thumbnailsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Videos_thumbnails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_thumbnailsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videos_thumbnails
     * const videos_thumbnails = await prisma.videos_thumbnails.findMany()
     * 
     * // Get first 10 Videos_thumbnails
     * const videos_thumbnails = await prisma.videos_thumbnails.findMany({ take: 10 })
     * 
     * // Only select the `video_thumbnail_id`
     * const videos_thumbnailsWithVideo_thumbnail_idOnly = await prisma.videos_thumbnails.findMany({ select: { video_thumbnail_id: true } })
     * 
    **/
    findMany<T extends videos_thumbnailsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, videos_thumbnailsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$videos_thumbnailsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Videos_thumbnails.
     * @param {videos_thumbnailsCreateArgs} args - Arguments to create a Videos_thumbnails.
     * @example
     * // Create one Videos_thumbnails
     * const Videos_thumbnails = await prisma.videos_thumbnails.create({
     *   data: {
     *     // ... data to create a Videos_thumbnails
     *   }
     * })
     * 
    **/
    create<T extends videos_thumbnailsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, videos_thumbnailsCreateArgs<ExtArgs>>
    ): Prisma__videos_thumbnailsClient<$Result.GetResult<Prisma.$videos_thumbnailsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Videos_thumbnails.
     *     @param {videos_thumbnailsCreateManyArgs} args - Arguments to create many Videos_thumbnails.
     *     @example
     *     // Create many Videos_thumbnails
     *     const videos_thumbnails = await prisma.videos_thumbnails.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends videos_thumbnailsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, videos_thumbnailsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Videos_thumbnails.
     * @param {videos_thumbnailsDeleteArgs} args - Arguments to delete one Videos_thumbnails.
     * @example
     * // Delete one Videos_thumbnails
     * const Videos_thumbnails = await prisma.videos_thumbnails.delete({
     *   where: {
     *     // ... filter to delete one Videos_thumbnails
     *   }
     * })
     * 
    **/
    delete<T extends videos_thumbnailsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, videos_thumbnailsDeleteArgs<ExtArgs>>
    ): Prisma__videos_thumbnailsClient<$Result.GetResult<Prisma.$videos_thumbnailsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Videos_thumbnails.
     * @param {videos_thumbnailsUpdateArgs} args - Arguments to update one Videos_thumbnails.
     * @example
     * // Update one Videos_thumbnails
     * const videos_thumbnails = await prisma.videos_thumbnails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends videos_thumbnailsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, videos_thumbnailsUpdateArgs<ExtArgs>>
    ): Prisma__videos_thumbnailsClient<$Result.GetResult<Prisma.$videos_thumbnailsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Videos_thumbnails.
     * @param {videos_thumbnailsDeleteManyArgs} args - Arguments to filter Videos_thumbnails to delete.
     * @example
     * // Delete a few Videos_thumbnails
     * const { count } = await prisma.videos_thumbnails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends videos_thumbnailsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, videos_thumbnailsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos_thumbnails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_thumbnailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videos_thumbnails
     * const videos_thumbnails = await prisma.videos_thumbnails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends videos_thumbnailsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, videos_thumbnailsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Videos_thumbnails.
     * @param {videos_thumbnailsUpsertArgs} args - Arguments to update or create a Videos_thumbnails.
     * @example
     * // Update or create a Videos_thumbnails
     * const videos_thumbnails = await prisma.videos_thumbnails.upsert({
     *   create: {
     *     // ... data to create a Videos_thumbnails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Videos_thumbnails we want to update
     *   }
     * })
    **/
    upsert<T extends videos_thumbnailsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, videos_thumbnailsUpsertArgs<ExtArgs>>
    ): Prisma__videos_thumbnailsClient<$Result.GetResult<Prisma.$videos_thumbnailsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Videos_thumbnails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_thumbnailsCountArgs} args - Arguments to filter Videos_thumbnails to count.
     * @example
     * // Count the number of Videos_thumbnails
     * const count = await prisma.videos_thumbnails.count({
     *   where: {
     *     // ... the filter for the Videos_thumbnails we want to count
     *   }
     * })
    **/
    count<T extends videos_thumbnailsCountArgs>(
      args?: Subset<T, videos_thumbnailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Videos_thumbnailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Videos_thumbnails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Videos_thumbnailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Videos_thumbnailsAggregateArgs>(args: Subset<T, Videos_thumbnailsAggregateArgs>): Prisma.PrismaPromise<GetVideos_thumbnailsAggregateType<T>>

    /**
     * Group by Videos_thumbnails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videos_thumbnailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends videos_thumbnailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: videos_thumbnailsGroupByArgs['orderBy'] }
        : { orderBy?: videos_thumbnailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, videos_thumbnailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideos_thumbnailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the videos_thumbnails model
   */
  readonly fields: videos_thumbnailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for videos_thumbnails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__videos_thumbnailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    videos<T extends videos_thumbnails$videosArgs<ExtArgs> = {}>(args?: Subset<T, videos_thumbnails$videosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the videos_thumbnails model
   */ 
  interface videos_thumbnailsFieldRefs {
    readonly video_thumbnail_id: FieldRef<"videos_thumbnails", 'String'>
    readonly video_thumbnail_data: FieldRef<"videos_thumbnails", 'Bytes'>
    readonly video_thumbnail_filename: FieldRef<"videos_thumbnails", 'String'>
    readonly video_thumbnail_description: FieldRef<"videos_thumbnails", 'String'>
  }
    

  // Custom InputTypes

  /**
   * videos_thumbnails findUnique
   */
  export type videos_thumbnailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_thumbnails
     */
    select?: videos_thumbnailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videos_thumbnailsInclude<ExtArgs> | null
    /**
     * Filter, which videos_thumbnails to fetch.
     */
    where: videos_thumbnailsWhereUniqueInput
  }


  /**
   * videos_thumbnails findUniqueOrThrow
   */
  export type videos_thumbnailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_thumbnails
     */
    select?: videos_thumbnailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videos_thumbnailsInclude<ExtArgs> | null
    /**
     * Filter, which videos_thumbnails to fetch.
     */
    where: videos_thumbnailsWhereUniqueInput
  }


  /**
   * videos_thumbnails findFirst
   */
  export type videos_thumbnailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_thumbnails
     */
    select?: videos_thumbnailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videos_thumbnailsInclude<ExtArgs> | null
    /**
     * Filter, which videos_thumbnails to fetch.
     */
    where?: videos_thumbnailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos_thumbnails to fetch.
     */
    orderBy?: videos_thumbnailsOrderByWithRelationInput | videos_thumbnailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for videos_thumbnails.
     */
    cursor?: videos_thumbnailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos_thumbnails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos_thumbnails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of videos_thumbnails.
     */
    distinct?: Videos_thumbnailsScalarFieldEnum | Videos_thumbnailsScalarFieldEnum[]
  }


  /**
   * videos_thumbnails findFirstOrThrow
   */
  export type videos_thumbnailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_thumbnails
     */
    select?: videos_thumbnailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videos_thumbnailsInclude<ExtArgs> | null
    /**
     * Filter, which videos_thumbnails to fetch.
     */
    where?: videos_thumbnailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos_thumbnails to fetch.
     */
    orderBy?: videos_thumbnailsOrderByWithRelationInput | videos_thumbnailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for videos_thumbnails.
     */
    cursor?: videos_thumbnailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos_thumbnails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos_thumbnails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of videos_thumbnails.
     */
    distinct?: Videos_thumbnailsScalarFieldEnum | Videos_thumbnailsScalarFieldEnum[]
  }


  /**
   * videos_thumbnails findMany
   */
  export type videos_thumbnailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_thumbnails
     */
    select?: videos_thumbnailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videos_thumbnailsInclude<ExtArgs> | null
    /**
     * Filter, which videos_thumbnails to fetch.
     */
    where?: videos_thumbnailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos_thumbnails to fetch.
     */
    orderBy?: videos_thumbnailsOrderByWithRelationInput | videos_thumbnailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing videos_thumbnails.
     */
    cursor?: videos_thumbnailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos_thumbnails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos_thumbnails.
     */
    skip?: number
    distinct?: Videos_thumbnailsScalarFieldEnum | Videos_thumbnailsScalarFieldEnum[]
  }


  /**
   * videos_thumbnails create
   */
  export type videos_thumbnailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_thumbnails
     */
    select?: videos_thumbnailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videos_thumbnailsInclude<ExtArgs> | null
    /**
     * The data needed to create a videos_thumbnails.
     */
    data: XOR<videos_thumbnailsCreateInput, videos_thumbnailsUncheckedCreateInput>
  }


  /**
   * videos_thumbnails createMany
   */
  export type videos_thumbnailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many videos_thumbnails.
     */
    data: videos_thumbnailsCreateManyInput | videos_thumbnailsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * videos_thumbnails update
   */
  export type videos_thumbnailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_thumbnails
     */
    select?: videos_thumbnailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videos_thumbnailsInclude<ExtArgs> | null
    /**
     * The data needed to update a videos_thumbnails.
     */
    data: XOR<videos_thumbnailsUpdateInput, videos_thumbnailsUncheckedUpdateInput>
    /**
     * Choose, which videos_thumbnails to update.
     */
    where: videos_thumbnailsWhereUniqueInput
  }


  /**
   * videos_thumbnails updateMany
   */
  export type videos_thumbnailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update videos_thumbnails.
     */
    data: XOR<videos_thumbnailsUpdateManyMutationInput, videos_thumbnailsUncheckedUpdateManyInput>
    /**
     * Filter which videos_thumbnails to update
     */
    where?: videos_thumbnailsWhereInput
  }


  /**
   * videos_thumbnails upsert
   */
  export type videos_thumbnailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_thumbnails
     */
    select?: videos_thumbnailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videos_thumbnailsInclude<ExtArgs> | null
    /**
     * The filter to search for the videos_thumbnails to update in case it exists.
     */
    where: videos_thumbnailsWhereUniqueInput
    /**
     * In case the videos_thumbnails found by the `where` argument doesn't exist, create a new videos_thumbnails with this data.
     */
    create: XOR<videos_thumbnailsCreateInput, videos_thumbnailsUncheckedCreateInput>
    /**
     * In case the videos_thumbnails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<videos_thumbnailsUpdateInput, videos_thumbnailsUncheckedUpdateInput>
  }


  /**
   * videos_thumbnails delete
   */
  export type videos_thumbnailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_thumbnails
     */
    select?: videos_thumbnailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videos_thumbnailsInclude<ExtArgs> | null
    /**
     * Filter which videos_thumbnails to delete.
     */
    where: videos_thumbnailsWhereUniqueInput
  }


  /**
   * videos_thumbnails deleteMany
   */
  export type videos_thumbnailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which videos_thumbnails to delete
     */
    where?: videos_thumbnailsWhereInput
  }


  /**
   * videos_thumbnails.videos
   */
  export type videos_thumbnails$videosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videosInclude<ExtArgs> | null
    where?: videosWhereInput
    orderBy?: videosOrderByWithRelationInput | videosOrderByWithRelationInput[]
    cursor?: videosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideosScalarFieldEnum | VideosScalarFieldEnum[]
  }


  /**
   * videos_thumbnails without action
   */
  export type videos_thumbnailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos_thumbnails
     */
    select?: videos_thumbnailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: videos_thumbnailsInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Affiliates_relationsScalarFieldEnum: {
    affiliate_relation_id: 'affiliate_relation_id',
    affiliate_id_root: 'affiliate_id_root',
    affiliate_id_target: 'affiliate_id_target',
    affiliate_relation_date: 'affiliate_relation_date'
  };

  export type Affiliates_relationsScalarFieldEnum = (typeof Affiliates_relationsScalarFieldEnum)[keyof typeof Affiliates_relationsScalarFieldEnum]


  export const CollectionsScalarFieldEnum: {
    collection_id: 'collection_id',
    collection_name: 'collection_name',
    entity_id: 'entity_id'
  };

  export type CollectionsScalarFieldEnum = (typeof CollectionsScalarFieldEnum)[keyof typeof CollectionsScalarFieldEnum]


  export const Collections_contentScalarFieldEnum: {
    collections_content_id: 'collections_content_id',
    collection_id: 'collection_id',
    content_id: 'content_id',
    date_added: 'date_added',
    pinned: 'pinned',
    date_pinned: 'date_pinned'
  };

  export type Collections_contentScalarFieldEnum = (typeof Collections_contentScalarFieldEnum)[keyof typeof Collections_contentScalarFieldEnum]


  export const ContactsScalarFieldEnum: {
    contact_id: 'contact_id',
    conversation_id: 'conversation_id',
    contact_id_root: 'contact_id_root',
    contact_id_target: 'contact_id_target',
    contact_creation_date: 'contact_creation_date',
    last_message: 'last_message',
    last_contact_date: 'last_contact_date',
    contacts_pictures_id: 'contacts_pictures_id'
  };

  export type ContactsScalarFieldEnum = (typeof ContactsScalarFieldEnum)[keyof typeof ContactsScalarFieldEnum]


  export const Contacts_picturesScalarFieldEnum: {
    contacts_pictures_id: 'contacts_pictures_id',
    contact_picture_data: 'contact_picture_data',
    contact_picture_filename: 'contact_picture_filename'
  };

  export type Contacts_picturesScalarFieldEnum = (typeof Contacts_picturesScalarFieldEnum)[keyof typeof Contacts_picturesScalarFieldEnum]


  export const ContentScalarFieldEnum: {
    content_id: 'content_id',
    content_type: 'content_type'
  };

  export type ContentScalarFieldEnum = (typeof ContentScalarFieldEnum)[keyof typeof ContentScalarFieldEnum]


  export const ConversationsScalarFieldEnum: {
    conversation_id: 'conversation_id',
    conversation_name: 'conversation_name',
    conversation_creation_date: 'conversation_creation_date',
    last_message: 'last_message',
    last_message_date: 'last_message_date',
    conversations_pictures_id: 'conversations_pictures_id'
  };

  export type ConversationsScalarFieldEnum = (typeof ConversationsScalarFieldEnum)[keyof typeof ConversationsScalarFieldEnum]


  export const Conversations_membersScalarFieldEnum: {
    conversations_members_id: 'conversations_members_id',
    conversation_id: 'conversation_id',
    member_id: 'member_id'
  };

  export type Conversations_membersScalarFieldEnum = (typeof Conversations_membersScalarFieldEnum)[keyof typeof Conversations_membersScalarFieldEnum]


  export const Conversations_messages_logsScalarFieldEnum: {
    conversations_messages_logs_id: 'conversations_messages_logs_id',
    conversation_id: 'conversation_id',
    entity_id: 'entity_id',
    message: 'message',
    message_date: 'message_date'
  };

  export type Conversations_messages_logsScalarFieldEnum = (typeof Conversations_messages_logsScalarFieldEnum)[keyof typeof Conversations_messages_logsScalarFieldEnum]


  export const Conversations_picturesScalarFieldEnum: {
    conversations_pictures_id: 'conversations_pictures_id',
    conversation_picture_data: 'conversation_picture_data',
    conversation_picture_filename: 'conversation_picture_filename'
  };

  export type Conversations_picturesScalarFieldEnum = (typeof Conversations_picturesScalarFieldEnum)[keyof typeof Conversations_picturesScalarFieldEnum]


  export const EntitiesScalarFieldEnum: {
    entity_id: 'entity_id',
    entity_username: 'entity_username',
    entity_type: 'entity_type'
  };

  export type EntitiesScalarFieldEnum = (typeof EntitiesScalarFieldEnum)[keyof typeof EntitiesScalarFieldEnum]


  export const Entities_contentScalarFieldEnum: {
    entities_content_id: 'entities_content_id',
    entity_id: 'entity_id',
    content_id: 'content_id',
    date_added: 'date_added',
    pinned: 'pinned',
    date_pinned: 'date_pinned'
  };

  export type Entities_contentScalarFieldEnum = (typeof Entities_contentScalarFieldEnum)[keyof typeof Entities_contentScalarFieldEnum]


  export const Entities_dislikesScalarFieldEnum: {
    dislike_id: 'dislike_id',
    entity_id: 'entity_id',
    content_id: 'content_id'
  };

  export type Entities_dislikesScalarFieldEnum = (typeof Entities_dislikesScalarFieldEnum)[keyof typeof Entities_dislikesScalarFieldEnum]


  export const Entities_likesScalarFieldEnum: {
    like_id: 'like_id',
    entity_id: 'entity_id',
    content_id: 'content_id'
  };

  export type Entities_likesScalarFieldEnum = (typeof Entities_likesScalarFieldEnum)[keyof typeof Entities_likesScalarFieldEnum]


  export const Entities_referencesScalarFieldEnum: {
    reference_id: 'reference_id',
    entity_id: 'entity_id',
    title: 'title',
    author: 'author',
    url: 'url'
  };

  export type Entities_referencesScalarFieldEnum = (typeof Entities_referencesScalarFieldEnum)[keyof typeof Entities_referencesScalarFieldEnum]


  export const GroupsScalarFieldEnum: {
    group_id: 'group_id',
    group_handle: 'group_handle',
    group_name: 'group_name',
    group_current_issue: 'group_current_issue',
    group_stances: 'group_stances',
    group_description: 'group_description',
    profile_picture_id: 'profile_picture_id'
  };

  export type GroupsScalarFieldEnum = (typeof GroupsScalarFieldEnum)[keyof typeof GroupsScalarFieldEnum]


  export const Groups_membersScalarFieldEnum: {
    groups_members_id: 'groups_members_id',
    group_id: 'group_id',
    entity_id: 'entity_id'
  };

  export type Groups_membersScalarFieldEnum = (typeof Groups_membersScalarFieldEnum)[keyof typeof Groups_membersScalarFieldEnum]


  export const ImagesScalarFieldEnum: {
    image_id: 'image_id',
    image_creator_id: 'image_creator_id',
    image_title: 'image_title',
    image_description: 'image_description',
    image_filename: 'image_filename',
    image_data_id: 'image_data_id',
    image_likes: 'image_likes',
    image_dislikes: 'image_dislikes',
    image_views: 'image_views',
    image_date_posted: 'image_date_posted'
  };

  export type ImagesScalarFieldEnum = (typeof ImagesScalarFieldEnum)[keyof typeof ImagesScalarFieldEnum]


  export const Images_dataScalarFieldEnum: {
    image_data_id: 'image_data_id',
    image_data: 'image_data'
  };

  export type Images_dataScalarFieldEnum = (typeof Images_dataScalarFieldEnum)[keyof typeof Images_dataScalarFieldEnum]


  export const IndividualsScalarFieldEnum: {
    individual_id: 'individual_id',
    individual_username: 'individual_username',
    individual_name: 'individual_name',
    individual_current_issue: 'individual_current_issue',
    individual_roles: 'individual_roles',
    individual_description: 'individual_description',
    profile_picture_id: 'profile_picture_id'
  };

  export type IndividualsScalarFieldEnum = (typeof IndividualsScalarFieldEnum)[keyof typeof IndividualsScalarFieldEnum]


  export const OrganizationsScalarFieldEnum: {
    organization_id: 'organization_id',
    organization_handle: 'organization_handle',
    organization_name: 'organization_name',
    organization_current_issue: 'organization_current_issue',
    organization_stances: 'organization_stances',
    organization_description: 'organization_description',
    profile_picture_id: 'profile_picture_id'
  };

  export type OrganizationsScalarFieldEnum = (typeof OrganizationsScalarFieldEnum)[keyof typeof OrganizationsScalarFieldEnum]


  export const Organizations_membersScalarFieldEnum: {
    organizations_members_id: 'organizations_members_id',
    organization_id: 'organization_id',
    entity_id: 'entity_id'
  };

  export type Organizations_membersScalarFieldEnum = (typeof Organizations_membersScalarFieldEnum)[keyof typeof Organizations_membersScalarFieldEnum]


  export const Profile_picturesScalarFieldEnum: {
    profile_picture_id: 'profile_picture_id',
    profile_picture_data: 'profile_picture_data',
    profile_picture_filename: 'profile_picture_filename'
  };

  export type Profile_picturesScalarFieldEnum = (typeof Profile_picturesScalarFieldEnum)[keyof typeof Profile_picturesScalarFieldEnum]


  export const SheetsScalarFieldEnum: {
    sheet_id: 'sheet_id',
    sheet_author_id: 'sheet_author_id',
    sheet_title: 'sheet_title',
    sheet_subject: 'sheet_subject',
    sheet_filename: 'sheet_filename',
    sheet_data_id: 'sheet_data_id',
    sheet_thumbnail_id: 'sheet_thumbnail_id',
    sheet_likes: 'sheet_likes',
    sheet_dislikes: 'sheet_dislikes',
    sheet_views: 'sheet_views',
    sheet_date_posted: 'sheet_date_posted'
  };

  export type SheetsScalarFieldEnum = (typeof SheetsScalarFieldEnum)[keyof typeof SheetsScalarFieldEnum]


  export const Sheets_dataScalarFieldEnum: {
    sheet_data_id: 'sheet_data_id',
    sheet_data: 'sheet_data'
  };

  export type Sheets_dataScalarFieldEnum = (typeof Sheets_dataScalarFieldEnum)[keyof typeof Sheets_dataScalarFieldEnum]


  export const Sheets_thumbnailsScalarFieldEnum: {
    sheet_thumbnail_id: 'sheet_thumbnail_id',
    sheet_thumbnail_data: 'sheet_thumbnail_data',
    sheet_thumbnail_filename: 'sheet_thumbnail_filename',
    sheet_thumbnail_description: 'sheet_thumbnail_description'
  };

  export type Sheets_thumbnailsScalarFieldEnum = (typeof Sheets_thumbnailsScalarFieldEnum)[keyof typeof Sheets_thumbnailsScalarFieldEnum]


  export const TablesScalarFieldEnum: {
    table_id: 'table_id',
    table_name: 'table_name',
    table_creation_date: 'table_creation_date',
    last_message: 'last_message',
    last_message_date: 'last_message_date',
    tables_pictures_id: 'tables_pictures_id'
  };

  export type TablesScalarFieldEnum = (typeof TablesScalarFieldEnum)[keyof typeof TablesScalarFieldEnum]


  export const Tables_membersScalarFieldEnum: {
    tables_members_id: 'tables_members_id',
    table_id: 'table_id',
    member_id: 'member_id',
    table_position: 'table_position',
    live: 'live'
  };

  export type Tables_membersScalarFieldEnum = (typeof Tables_membersScalarFieldEnum)[keyof typeof Tables_membersScalarFieldEnum]


  export const Tables_messages_logsScalarFieldEnum: {
    tables_messages_logs_id: 'tables_messages_logs_id',
    table_id: 'table_id',
    entity_id: 'entity_id',
    message: 'message',
    message_date: 'message_date'
  };

  export type Tables_messages_logsScalarFieldEnum = (typeof Tables_messages_logsScalarFieldEnum)[keyof typeof Tables_messages_logsScalarFieldEnum]


  export const Tables_picturesScalarFieldEnum: {
    tables_pictures_id: 'tables_pictures_id',
    table_picture_data: 'table_picture_data',
    table_picture_filename: 'table_picture_filename'
  };

  export type Tables_picturesScalarFieldEnum = (typeof Tables_picturesScalarFieldEnum)[keyof typeof Tables_picturesScalarFieldEnum]


  export const Tables_tabletopsScalarFieldEnum: {
    tables_tabletops_id: 'tables_tabletops_id',
    table_id: 'table_id',
    creator_id: 'creator_id',
    tables_tabletops_data_id: 'tables_tabletops_data_id',
    type: 'type',
    content_date_posted: 'content_date_posted',
    content_x_position: 'content_x_position',
    content_y_position: 'content_y_position',
    content_rotation: 'content_rotation',
    content_filename: 'content_filename'
  };

  export type Tables_tabletopsScalarFieldEnum = (typeof Tables_tabletopsScalarFieldEnum)[keyof typeof Tables_tabletopsScalarFieldEnum]


  export const Tables_tabletops_dataScalarFieldEnum: {
    tables_tabletops_data_id: 'tables_tabletops_data_id',
    tables_tabletops_data: 'tables_tabletops_data'
  };

  export type Tables_tabletops_dataScalarFieldEnum = (typeof Tables_tabletops_dataScalarFieldEnum)[keyof typeof Tables_tabletops_dataScalarFieldEnum]


  export const User_credentialsScalarFieldEnum: {
    user_id: 'user_id',
    username: 'username',
    user_password: 'user_password',
    user_first_name: 'user_first_name',
    user_last_name: 'user_last_name',
    user_email: 'user_email',
    user_phone_number: 'user_phone_number'
  };

  export type User_credentialsScalarFieldEnum = (typeof User_credentialsScalarFieldEnum)[keyof typeof User_credentialsScalarFieldEnum]


  export const VideosScalarFieldEnum: {
    video_id: 'video_id',
    video_creator_id: 'video_creator_id',
    video_title: 'video_title',
    video_description: 'video_description',
    video_filename: 'video_filename',
    video_data_id: 'video_data_id',
    video_thumbnail_id: 'video_thumbnail_id',
    video_likes: 'video_likes',
    video_dislikes: 'video_dislikes',
    video_views: 'video_views',
    video_date_posted: 'video_date_posted'
  };

  export type VideosScalarFieldEnum = (typeof VideosScalarFieldEnum)[keyof typeof VideosScalarFieldEnum]


  export const Videos_dataScalarFieldEnum: {
    video_data_id: 'video_data_id',
    video_data: 'video_data'
  };

  export type Videos_dataScalarFieldEnum = (typeof Videos_dataScalarFieldEnum)[keyof typeof Videos_dataScalarFieldEnum]


  export const Videos_thumbnailsScalarFieldEnum: {
    video_thumbnail_id: 'video_thumbnail_id',
    video_thumbnail_data: 'video_thumbnail_data',
    video_thumbnail_filename: 'video_thumbnail_filename',
    video_thumbnail_description: 'video_thumbnail_description'
  };

  export type Videos_thumbnailsScalarFieldEnum = (typeof Videos_thumbnailsScalarFieldEnum)[keyof typeof Videos_thumbnailsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type affiliates_relationsWhereInput = {
    AND?: affiliates_relationsWhereInput | affiliates_relationsWhereInput[]
    OR?: affiliates_relationsWhereInput[]
    NOT?: affiliates_relationsWhereInput | affiliates_relationsWhereInput[]
    affiliate_relation_id?: StringFilter<"affiliates_relations"> | string
    affiliate_id_root?: StringFilter<"affiliates_relations"> | string
    affiliate_id_target?: StringFilter<"affiliates_relations"> | string
    affiliate_relation_date?: DateTimeFilter<"affiliates_relations"> | Date | string
  }

  export type affiliates_relationsOrderByWithRelationInput = {
    affiliate_relation_id?: SortOrder
    affiliate_id_root?: SortOrder
    affiliate_id_target?: SortOrder
    affiliate_relation_date?: SortOrder
  }

  export type affiliates_relationsWhereUniqueInput = Prisma.AtLeast<{
    affiliate_relation_id?: string
    affiliate_id_root_affiliate_id_target?: affiliates_relationsAffiliate_id_rootAffiliate_id_targetCompoundUniqueInput
    AND?: affiliates_relationsWhereInput | affiliates_relationsWhereInput[]
    OR?: affiliates_relationsWhereInput[]
    NOT?: affiliates_relationsWhereInput | affiliates_relationsWhereInput[]
    affiliate_id_root?: StringFilter<"affiliates_relations"> | string
    affiliate_id_target?: StringFilter<"affiliates_relations"> | string
    affiliate_relation_date?: DateTimeFilter<"affiliates_relations"> | Date | string
  }, "affiliate_relation_id" | "affiliate_relation_id" | "affiliate_id_root_affiliate_id_target">

  export type affiliates_relationsOrderByWithAggregationInput = {
    affiliate_relation_id?: SortOrder
    affiliate_id_root?: SortOrder
    affiliate_id_target?: SortOrder
    affiliate_relation_date?: SortOrder
    _count?: affiliates_relationsCountOrderByAggregateInput
    _max?: affiliates_relationsMaxOrderByAggregateInput
    _min?: affiliates_relationsMinOrderByAggregateInput
  }

  export type affiliates_relationsScalarWhereWithAggregatesInput = {
    AND?: affiliates_relationsScalarWhereWithAggregatesInput | affiliates_relationsScalarWhereWithAggregatesInput[]
    OR?: affiliates_relationsScalarWhereWithAggregatesInput[]
    NOT?: affiliates_relationsScalarWhereWithAggregatesInput | affiliates_relationsScalarWhereWithAggregatesInput[]
    affiliate_relation_id?: StringWithAggregatesFilter<"affiliates_relations"> | string
    affiliate_id_root?: StringWithAggregatesFilter<"affiliates_relations"> | string
    affiliate_id_target?: StringWithAggregatesFilter<"affiliates_relations"> | string
    affiliate_relation_date?: DateTimeWithAggregatesFilter<"affiliates_relations"> | Date | string
  }

  export type collectionsWhereInput = {
    AND?: collectionsWhereInput | collectionsWhereInput[]
    OR?: collectionsWhereInput[]
    NOT?: collectionsWhereInput | collectionsWhereInput[]
    collection_id?: StringFilter<"collections"> | string
    collection_name?: StringFilter<"collections"> | string
    entity_id?: StringFilter<"collections"> | string
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
    collections_content?: Collections_contentListRelationFilter
  }

  export type collectionsOrderByWithRelationInput = {
    collection_id?: SortOrder
    collection_name?: SortOrder
    entity_id?: SortOrder
    entities?: entitiesOrderByWithRelationInput
    collections_content?: collections_contentOrderByRelationAggregateInput
  }

  export type collectionsWhereUniqueInput = Prisma.AtLeast<{
    collection_id?: string
    AND?: collectionsWhereInput | collectionsWhereInput[]
    OR?: collectionsWhereInput[]
    NOT?: collectionsWhereInput | collectionsWhereInput[]
    collection_name?: StringFilter<"collections"> | string
    entity_id?: StringFilter<"collections"> | string
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
    collections_content?: Collections_contentListRelationFilter
  }, "collection_id" | "collection_id">

  export type collectionsOrderByWithAggregationInput = {
    collection_id?: SortOrder
    collection_name?: SortOrder
    entity_id?: SortOrder
    _count?: collectionsCountOrderByAggregateInput
    _max?: collectionsMaxOrderByAggregateInput
    _min?: collectionsMinOrderByAggregateInput
  }

  export type collectionsScalarWhereWithAggregatesInput = {
    AND?: collectionsScalarWhereWithAggregatesInput | collectionsScalarWhereWithAggregatesInput[]
    OR?: collectionsScalarWhereWithAggregatesInput[]
    NOT?: collectionsScalarWhereWithAggregatesInput | collectionsScalarWhereWithAggregatesInput[]
    collection_id?: StringWithAggregatesFilter<"collections"> | string
    collection_name?: StringWithAggregatesFilter<"collections"> | string
    entity_id?: StringWithAggregatesFilter<"collections"> | string
  }

  export type collections_contentWhereInput = {
    AND?: collections_contentWhereInput | collections_contentWhereInput[]
    OR?: collections_contentWhereInput[]
    NOT?: collections_contentWhereInput | collections_contentWhereInput[]
    collections_content_id?: StringFilter<"collections_content"> | string
    collection_id?: StringFilter<"collections_content"> | string
    content_id?: StringFilter<"collections_content"> | string
    date_added?: DateTimeFilter<"collections_content"> | Date | string
    pinned?: BoolFilter<"collections_content"> | boolean
    date_pinned?: DateTimeNullableFilter<"collections_content"> | Date | string | null
    collections?: XOR<CollectionsRelationFilter, collectionsWhereInput>
    content?: XOR<ContentRelationFilter, contentWhereInput>
  }

  export type collections_contentOrderByWithRelationInput = {
    collections_content_id?: SortOrder
    collection_id?: SortOrder
    content_id?: SortOrder
    date_added?: SortOrder
    pinned?: SortOrder
    date_pinned?: SortOrderInput | SortOrder
    collections?: collectionsOrderByWithRelationInput
    content?: contentOrderByWithRelationInput
  }

  export type collections_contentWhereUniqueInput = Prisma.AtLeast<{
    collections_content_id?: string
    AND?: collections_contentWhereInput | collections_contentWhereInput[]
    OR?: collections_contentWhereInput[]
    NOT?: collections_contentWhereInput | collections_contentWhereInput[]
    collection_id?: StringFilter<"collections_content"> | string
    content_id?: StringFilter<"collections_content"> | string
    date_added?: DateTimeFilter<"collections_content"> | Date | string
    pinned?: BoolFilter<"collections_content"> | boolean
    date_pinned?: DateTimeNullableFilter<"collections_content"> | Date | string | null
    collections?: XOR<CollectionsRelationFilter, collectionsWhereInput>
    content?: XOR<ContentRelationFilter, contentWhereInput>
  }, "collections_content_id" | "collections_content_id">

  export type collections_contentOrderByWithAggregationInput = {
    collections_content_id?: SortOrder
    collection_id?: SortOrder
    content_id?: SortOrder
    date_added?: SortOrder
    pinned?: SortOrder
    date_pinned?: SortOrderInput | SortOrder
    _count?: collections_contentCountOrderByAggregateInput
    _max?: collections_contentMaxOrderByAggregateInput
    _min?: collections_contentMinOrderByAggregateInput
  }

  export type collections_contentScalarWhereWithAggregatesInput = {
    AND?: collections_contentScalarWhereWithAggregatesInput | collections_contentScalarWhereWithAggregatesInput[]
    OR?: collections_contentScalarWhereWithAggregatesInput[]
    NOT?: collections_contentScalarWhereWithAggregatesInput | collections_contentScalarWhereWithAggregatesInput[]
    collections_content_id?: StringWithAggregatesFilter<"collections_content"> | string
    collection_id?: StringWithAggregatesFilter<"collections_content"> | string
    content_id?: StringWithAggregatesFilter<"collections_content"> | string
    date_added?: DateTimeWithAggregatesFilter<"collections_content"> | Date | string
    pinned?: BoolWithAggregatesFilter<"collections_content"> | boolean
    date_pinned?: DateTimeNullableWithAggregatesFilter<"collections_content"> | Date | string | null
  }

  export type contactsWhereInput = {
    AND?: contactsWhereInput | contactsWhereInput[]
    OR?: contactsWhereInput[]
    NOT?: contactsWhereInput | contactsWhereInput[]
    contact_id?: StringFilter<"contacts"> | string
    conversation_id?: StringFilter<"contacts"> | string
    contact_id_root?: StringFilter<"contacts"> | string
    contact_id_target?: StringFilter<"contacts"> | string
    contact_creation_date?: DateTimeFilter<"contacts"> | Date | string
    last_message?: StringNullableFilter<"contacts"> | string | null
    last_contact_date?: DateTimeNullableFilter<"contacts"> | Date | string | null
    contacts_pictures_id?: StringNullableFilter<"contacts"> | string | null
    entities_contacts_contact_id_rootToentities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
    entities_contacts_contact_id_targetToentities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
    contacts_pictures?: XOR<Contacts_picturesNullableRelationFilter, contacts_picturesWhereInput> | null
  }

  export type contactsOrderByWithRelationInput = {
    contact_id?: SortOrder
    conversation_id?: SortOrder
    contact_id_root?: SortOrder
    contact_id_target?: SortOrder
    contact_creation_date?: SortOrder
    last_message?: SortOrderInput | SortOrder
    last_contact_date?: SortOrderInput | SortOrder
    contacts_pictures_id?: SortOrderInput | SortOrder
    entities_contacts_contact_id_rootToentities?: entitiesOrderByWithRelationInput
    entities_contacts_contact_id_targetToentities?: entitiesOrderByWithRelationInput
    contacts_pictures?: contacts_picturesOrderByWithRelationInput
  }

  export type contactsWhereUniqueInput = Prisma.AtLeast<{
    contact_id?: string
    conversation_id?: string
    contact_id_conversation_id?: contactsContact_idConversation_idCompoundUniqueInput
    contact_id_root_contact_id_target?: contactsContact_id_rootContact_id_targetCompoundUniqueInput
    AND?: contactsWhereInput | contactsWhereInput[]
    OR?: contactsWhereInput[]
    NOT?: contactsWhereInput | contactsWhereInput[]
    contact_id_root?: StringFilter<"contacts"> | string
    contact_id_target?: StringFilter<"contacts"> | string
    contact_creation_date?: DateTimeFilter<"contacts"> | Date | string
    last_message?: StringNullableFilter<"contacts"> | string | null
    last_contact_date?: DateTimeNullableFilter<"contacts"> | Date | string | null
    contacts_pictures_id?: StringNullableFilter<"contacts"> | string | null
    entities_contacts_contact_id_rootToentities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
    entities_contacts_contact_id_targetToentities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
    contacts_pictures?: XOR<Contacts_picturesNullableRelationFilter, contacts_picturesWhereInput> | null
  }, "contact_id" | "contact_id" | "conversation_id" | "contact_id_conversation_id" | "contact_id_root_contact_id_target">

  export type contactsOrderByWithAggregationInput = {
    contact_id?: SortOrder
    conversation_id?: SortOrder
    contact_id_root?: SortOrder
    contact_id_target?: SortOrder
    contact_creation_date?: SortOrder
    last_message?: SortOrderInput | SortOrder
    last_contact_date?: SortOrderInput | SortOrder
    contacts_pictures_id?: SortOrderInput | SortOrder
    _count?: contactsCountOrderByAggregateInput
    _max?: contactsMaxOrderByAggregateInput
    _min?: contactsMinOrderByAggregateInput
  }

  export type contactsScalarWhereWithAggregatesInput = {
    AND?: contactsScalarWhereWithAggregatesInput | contactsScalarWhereWithAggregatesInput[]
    OR?: contactsScalarWhereWithAggregatesInput[]
    NOT?: contactsScalarWhereWithAggregatesInput | contactsScalarWhereWithAggregatesInput[]
    contact_id?: StringWithAggregatesFilter<"contacts"> | string
    conversation_id?: StringWithAggregatesFilter<"contacts"> | string
    contact_id_root?: StringWithAggregatesFilter<"contacts"> | string
    contact_id_target?: StringWithAggregatesFilter<"contacts"> | string
    contact_creation_date?: DateTimeWithAggregatesFilter<"contacts"> | Date | string
    last_message?: StringNullableWithAggregatesFilter<"contacts"> | string | null
    last_contact_date?: DateTimeNullableWithAggregatesFilter<"contacts"> | Date | string | null
    contacts_pictures_id?: StringNullableWithAggregatesFilter<"contacts"> | string | null
  }

  export type contacts_picturesWhereInput = {
    AND?: contacts_picturesWhereInput | contacts_picturesWhereInput[]
    OR?: contacts_picturesWhereInput[]
    NOT?: contacts_picturesWhereInput | contacts_picturesWhereInput[]
    contacts_pictures_id?: StringFilter<"contacts_pictures"> | string
    contact_picture_data?: BytesFilter<"contacts_pictures"> | Buffer
    contact_picture_filename?: StringFilter<"contacts_pictures"> | string
    contacts?: ContactsListRelationFilter
  }

  export type contacts_picturesOrderByWithRelationInput = {
    contacts_pictures_id?: SortOrder
    contact_picture_data?: SortOrder
    contact_picture_filename?: SortOrder
    contacts?: contactsOrderByRelationAggregateInput
  }

  export type contacts_picturesWhereUniqueInput = Prisma.AtLeast<{
    contacts_pictures_id?: string
    AND?: contacts_picturesWhereInput | contacts_picturesWhereInput[]
    OR?: contacts_picturesWhereInput[]
    NOT?: contacts_picturesWhereInput | contacts_picturesWhereInput[]
    contact_picture_data?: BytesFilter<"contacts_pictures"> | Buffer
    contact_picture_filename?: StringFilter<"contacts_pictures"> | string
    contacts?: ContactsListRelationFilter
  }, "contacts_pictures_id" | "contacts_pictures_id">

  export type contacts_picturesOrderByWithAggregationInput = {
    contacts_pictures_id?: SortOrder
    contact_picture_data?: SortOrder
    contact_picture_filename?: SortOrder
    _count?: contacts_picturesCountOrderByAggregateInput
    _max?: contacts_picturesMaxOrderByAggregateInput
    _min?: contacts_picturesMinOrderByAggregateInput
  }

  export type contacts_picturesScalarWhereWithAggregatesInput = {
    AND?: contacts_picturesScalarWhereWithAggregatesInput | contacts_picturesScalarWhereWithAggregatesInput[]
    OR?: contacts_picturesScalarWhereWithAggregatesInput[]
    NOT?: contacts_picturesScalarWhereWithAggregatesInput | contacts_picturesScalarWhereWithAggregatesInput[]
    contacts_pictures_id?: StringWithAggregatesFilter<"contacts_pictures"> | string
    contact_picture_data?: BytesWithAggregatesFilter<"contacts_pictures"> | Buffer
    contact_picture_filename?: StringWithAggregatesFilter<"contacts_pictures"> | string
  }

  export type contentWhereInput = {
    AND?: contentWhereInput | contentWhereInput[]
    OR?: contentWhereInput[]
    NOT?: contentWhereInput | contentWhereInput[]
    content_id?: StringFilter<"content"> | string
    content_type?: IntNullableFilter<"content"> | number | null
    collections_content?: Collections_contentListRelationFilter
    entities_content?: Entities_contentListRelationFilter
    entities_dislikes?: Entities_dislikesListRelationFilter
    entities_likes?: Entities_likesListRelationFilter
  }

  export type contentOrderByWithRelationInput = {
    content_id?: SortOrder
    content_type?: SortOrderInput | SortOrder
    collections_content?: collections_contentOrderByRelationAggregateInput
    entities_content?: entities_contentOrderByRelationAggregateInput
    entities_dislikes?: entities_dislikesOrderByRelationAggregateInput
    entities_likes?: entities_likesOrderByRelationAggregateInput
  }

  export type contentWhereUniqueInput = Prisma.AtLeast<{
    content_id?: string
    AND?: contentWhereInput | contentWhereInput[]
    OR?: contentWhereInput[]
    NOT?: contentWhereInput | contentWhereInput[]
    content_type?: IntNullableFilter<"content"> | number | null
    collections_content?: Collections_contentListRelationFilter
    entities_content?: Entities_contentListRelationFilter
    entities_dislikes?: Entities_dislikesListRelationFilter
    entities_likes?: Entities_likesListRelationFilter
  }, "content_id" | "content_id">

  export type contentOrderByWithAggregationInput = {
    content_id?: SortOrder
    content_type?: SortOrderInput | SortOrder
    _count?: contentCountOrderByAggregateInput
    _avg?: contentAvgOrderByAggregateInput
    _max?: contentMaxOrderByAggregateInput
    _min?: contentMinOrderByAggregateInput
    _sum?: contentSumOrderByAggregateInput
  }

  export type contentScalarWhereWithAggregatesInput = {
    AND?: contentScalarWhereWithAggregatesInput | contentScalarWhereWithAggregatesInput[]
    OR?: contentScalarWhereWithAggregatesInput[]
    NOT?: contentScalarWhereWithAggregatesInput | contentScalarWhereWithAggregatesInput[]
    content_id?: StringWithAggregatesFilter<"content"> | string
    content_type?: IntNullableWithAggregatesFilter<"content"> | number | null
  }

  export type conversationsWhereInput = {
    AND?: conversationsWhereInput | conversationsWhereInput[]
    OR?: conversationsWhereInput[]
    NOT?: conversationsWhereInput | conversationsWhereInput[]
    conversation_id?: StringFilter<"conversations"> | string
    conversation_name?: StringNullableFilter<"conversations"> | string | null
    conversation_creation_date?: DateTimeFilter<"conversations"> | Date | string
    last_message?: StringNullableFilter<"conversations"> | string | null
    last_message_date?: DateTimeNullableFilter<"conversations"> | Date | string | null
    conversations_pictures_id?: StringNullableFilter<"conversations"> | string | null
    conversations_pictures?: XOR<Conversations_picturesNullableRelationFilter, conversations_picturesWhereInput> | null
    conversations_members?: Conversations_membersListRelationFilter
    conversations_messages_logs?: Conversations_messages_logsListRelationFilter
  }

  export type conversationsOrderByWithRelationInput = {
    conversation_id?: SortOrder
    conversation_name?: SortOrderInput | SortOrder
    conversation_creation_date?: SortOrder
    last_message?: SortOrderInput | SortOrder
    last_message_date?: SortOrderInput | SortOrder
    conversations_pictures_id?: SortOrderInput | SortOrder
    conversations_pictures?: conversations_picturesOrderByWithRelationInput
    conversations_members?: conversations_membersOrderByRelationAggregateInput
    conversations_messages_logs?: conversations_messages_logsOrderByRelationAggregateInput
  }

  export type conversationsWhereUniqueInput = Prisma.AtLeast<{
    conversation_id?: string
    AND?: conversationsWhereInput | conversationsWhereInput[]
    OR?: conversationsWhereInput[]
    NOT?: conversationsWhereInput | conversationsWhereInput[]
    conversation_name?: StringNullableFilter<"conversations"> | string | null
    conversation_creation_date?: DateTimeFilter<"conversations"> | Date | string
    last_message?: StringNullableFilter<"conversations"> | string | null
    last_message_date?: DateTimeNullableFilter<"conversations"> | Date | string | null
    conversations_pictures_id?: StringNullableFilter<"conversations"> | string | null
    conversations_pictures?: XOR<Conversations_picturesNullableRelationFilter, conversations_picturesWhereInput> | null
    conversations_members?: Conversations_membersListRelationFilter
    conversations_messages_logs?: Conversations_messages_logsListRelationFilter
  }, "conversation_id" | "conversation_id">

  export type conversationsOrderByWithAggregationInput = {
    conversation_id?: SortOrder
    conversation_name?: SortOrderInput | SortOrder
    conversation_creation_date?: SortOrder
    last_message?: SortOrderInput | SortOrder
    last_message_date?: SortOrderInput | SortOrder
    conversations_pictures_id?: SortOrderInput | SortOrder
    _count?: conversationsCountOrderByAggregateInput
    _max?: conversationsMaxOrderByAggregateInput
    _min?: conversationsMinOrderByAggregateInput
  }

  export type conversationsScalarWhereWithAggregatesInput = {
    AND?: conversationsScalarWhereWithAggregatesInput | conversationsScalarWhereWithAggregatesInput[]
    OR?: conversationsScalarWhereWithAggregatesInput[]
    NOT?: conversationsScalarWhereWithAggregatesInput | conversationsScalarWhereWithAggregatesInput[]
    conversation_id?: StringWithAggregatesFilter<"conversations"> | string
    conversation_name?: StringNullableWithAggregatesFilter<"conversations"> | string | null
    conversation_creation_date?: DateTimeWithAggregatesFilter<"conversations"> | Date | string
    last_message?: StringNullableWithAggregatesFilter<"conversations"> | string | null
    last_message_date?: DateTimeNullableWithAggregatesFilter<"conversations"> | Date | string | null
    conversations_pictures_id?: StringNullableWithAggregatesFilter<"conversations"> | string | null
  }

  export type conversations_membersWhereInput = {
    AND?: conversations_membersWhereInput | conversations_membersWhereInput[]
    OR?: conversations_membersWhereInput[]
    NOT?: conversations_membersWhereInput | conversations_membersWhereInput[]
    conversations_members_id?: StringFilter<"conversations_members"> | string
    conversation_id?: StringFilter<"conversations_members"> | string
    member_id?: StringFilter<"conversations_members"> | string
    conversations?: XOR<ConversationsRelationFilter, conversationsWhereInput>
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
  }

  export type conversations_membersOrderByWithRelationInput = {
    conversations_members_id?: SortOrder
    conversation_id?: SortOrder
    member_id?: SortOrder
    conversations?: conversationsOrderByWithRelationInput
    entities?: entitiesOrderByWithRelationInput
  }

  export type conversations_membersWhereUniqueInput = Prisma.AtLeast<{
    conversations_members_id?: string
    conversation_id_member_id?: conversations_membersConversation_idMember_idCompoundUniqueInput
    AND?: conversations_membersWhereInput | conversations_membersWhereInput[]
    OR?: conversations_membersWhereInput[]
    NOT?: conversations_membersWhereInput | conversations_membersWhereInput[]
    conversation_id?: StringFilter<"conversations_members"> | string
    member_id?: StringFilter<"conversations_members"> | string
    conversations?: XOR<ConversationsRelationFilter, conversationsWhereInput>
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
  }, "conversations_members_id" | "conversations_members_id" | "conversation_id_member_id">

  export type conversations_membersOrderByWithAggregationInput = {
    conversations_members_id?: SortOrder
    conversation_id?: SortOrder
    member_id?: SortOrder
    _count?: conversations_membersCountOrderByAggregateInput
    _max?: conversations_membersMaxOrderByAggregateInput
    _min?: conversations_membersMinOrderByAggregateInput
  }

  export type conversations_membersScalarWhereWithAggregatesInput = {
    AND?: conversations_membersScalarWhereWithAggregatesInput | conversations_membersScalarWhereWithAggregatesInput[]
    OR?: conversations_membersScalarWhereWithAggregatesInput[]
    NOT?: conversations_membersScalarWhereWithAggregatesInput | conversations_membersScalarWhereWithAggregatesInput[]
    conversations_members_id?: StringWithAggregatesFilter<"conversations_members"> | string
    conversation_id?: StringWithAggregatesFilter<"conversations_members"> | string
    member_id?: StringWithAggregatesFilter<"conversations_members"> | string
  }

  export type conversations_messages_logsWhereInput = {
    AND?: conversations_messages_logsWhereInput | conversations_messages_logsWhereInput[]
    OR?: conversations_messages_logsWhereInput[]
    NOT?: conversations_messages_logsWhereInput | conversations_messages_logsWhereInput[]
    conversations_messages_logs_id?: StringFilter<"conversations_messages_logs"> | string
    conversation_id?: StringFilter<"conversations_messages_logs"> | string
    entity_id?: StringFilter<"conversations_messages_logs"> | string
    message?: StringFilter<"conversations_messages_logs"> | string
    message_date?: DateTimeFilter<"conversations_messages_logs"> | Date | string
    conversations?: XOR<ConversationsRelationFilter, conversationsWhereInput>
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
  }

  export type conversations_messages_logsOrderByWithRelationInput = {
    conversations_messages_logs_id?: SortOrder
    conversation_id?: SortOrder
    entity_id?: SortOrder
    message?: SortOrder
    message_date?: SortOrder
    conversations?: conversationsOrderByWithRelationInput
    entities?: entitiesOrderByWithRelationInput
  }

  export type conversations_messages_logsWhereUniqueInput = Prisma.AtLeast<{
    conversations_messages_logs_id?: string
    AND?: conversations_messages_logsWhereInput | conversations_messages_logsWhereInput[]
    OR?: conversations_messages_logsWhereInput[]
    NOT?: conversations_messages_logsWhereInput | conversations_messages_logsWhereInput[]
    conversation_id?: StringFilter<"conversations_messages_logs"> | string
    entity_id?: StringFilter<"conversations_messages_logs"> | string
    message?: StringFilter<"conversations_messages_logs"> | string
    message_date?: DateTimeFilter<"conversations_messages_logs"> | Date | string
    conversations?: XOR<ConversationsRelationFilter, conversationsWhereInput>
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
  }, "conversations_messages_logs_id">

  export type conversations_messages_logsOrderByWithAggregationInput = {
    conversations_messages_logs_id?: SortOrder
    conversation_id?: SortOrder
    entity_id?: SortOrder
    message?: SortOrder
    message_date?: SortOrder
    _count?: conversations_messages_logsCountOrderByAggregateInput
    _max?: conversations_messages_logsMaxOrderByAggregateInput
    _min?: conversations_messages_logsMinOrderByAggregateInput
  }

  export type conversations_messages_logsScalarWhereWithAggregatesInput = {
    AND?: conversations_messages_logsScalarWhereWithAggregatesInput | conversations_messages_logsScalarWhereWithAggregatesInput[]
    OR?: conversations_messages_logsScalarWhereWithAggregatesInput[]
    NOT?: conversations_messages_logsScalarWhereWithAggregatesInput | conversations_messages_logsScalarWhereWithAggregatesInput[]
    conversations_messages_logs_id?: StringWithAggregatesFilter<"conversations_messages_logs"> | string
    conversation_id?: StringWithAggregatesFilter<"conversations_messages_logs"> | string
    entity_id?: StringWithAggregatesFilter<"conversations_messages_logs"> | string
    message?: StringWithAggregatesFilter<"conversations_messages_logs"> | string
    message_date?: DateTimeWithAggregatesFilter<"conversations_messages_logs"> | Date | string
  }

  export type conversations_picturesWhereInput = {
    AND?: conversations_picturesWhereInput | conversations_picturesWhereInput[]
    OR?: conversations_picturesWhereInput[]
    NOT?: conversations_picturesWhereInput | conversations_picturesWhereInput[]
    conversations_pictures_id?: StringFilter<"conversations_pictures"> | string
    conversation_picture_data?: BytesFilter<"conversations_pictures"> | Buffer
    conversation_picture_filename?: StringFilter<"conversations_pictures"> | string
    conversations?: ConversationsListRelationFilter
  }

  export type conversations_picturesOrderByWithRelationInput = {
    conversations_pictures_id?: SortOrder
    conversation_picture_data?: SortOrder
    conversation_picture_filename?: SortOrder
    conversations?: conversationsOrderByRelationAggregateInput
  }

  export type conversations_picturesWhereUniqueInput = Prisma.AtLeast<{
    conversations_pictures_id?: string
    AND?: conversations_picturesWhereInput | conversations_picturesWhereInput[]
    OR?: conversations_picturesWhereInput[]
    NOT?: conversations_picturesWhereInput | conversations_picturesWhereInput[]
    conversation_picture_data?: BytesFilter<"conversations_pictures"> | Buffer
    conversation_picture_filename?: StringFilter<"conversations_pictures"> | string
    conversations?: ConversationsListRelationFilter
  }, "conversations_pictures_id" | "conversations_pictures_id">

  export type conversations_picturesOrderByWithAggregationInput = {
    conversations_pictures_id?: SortOrder
    conversation_picture_data?: SortOrder
    conversation_picture_filename?: SortOrder
    _count?: conversations_picturesCountOrderByAggregateInput
    _max?: conversations_picturesMaxOrderByAggregateInput
    _min?: conversations_picturesMinOrderByAggregateInput
  }

  export type conversations_picturesScalarWhereWithAggregatesInput = {
    AND?: conversations_picturesScalarWhereWithAggregatesInput | conversations_picturesScalarWhereWithAggregatesInput[]
    OR?: conversations_picturesScalarWhereWithAggregatesInput[]
    NOT?: conversations_picturesScalarWhereWithAggregatesInput | conversations_picturesScalarWhereWithAggregatesInput[]
    conversations_pictures_id?: StringWithAggregatesFilter<"conversations_pictures"> | string
    conversation_picture_data?: BytesWithAggregatesFilter<"conversations_pictures"> | Buffer
    conversation_picture_filename?: StringWithAggregatesFilter<"conversations_pictures"> | string
  }

  export type entitiesWhereInput = {
    AND?: entitiesWhereInput | entitiesWhereInput[]
    OR?: entitiesWhereInput[]
    NOT?: entitiesWhereInput | entitiesWhereInput[]
    entity_id?: StringFilter<"entities"> | string
    entity_username?: StringFilter<"entities"> | string
    entity_type?: IntFilter<"entities"> | number
    collections?: CollectionsListRelationFilter
    contacts_contacts_contact_id_rootToentities?: ContactsListRelationFilter
    contacts_contacts_contact_id_targetToentities?: ContactsListRelationFilter
    conversations_members?: Conversations_membersListRelationFilter
    conversations_messages_logs?: Conversations_messages_logsListRelationFilter
    entities_content?: Entities_contentListRelationFilter
    entities_dislikes?: Entities_dislikesListRelationFilter
    entities_likes?: Entities_likesListRelationFilter
    entities_references?: Entities_referencesListRelationFilter
    groups_members?: Groups_membersListRelationFilter
    images?: ImagesListRelationFilter
    organizations_members?: Organizations_membersListRelationFilter
    sheets?: SheetsListRelationFilter
    tables_members?: Tables_membersListRelationFilter
    tables_messages_logs?: Tables_messages_logsListRelationFilter
    tables_tabletops?: Tables_tabletopsListRelationFilter
    videos?: VideosListRelationFilter
  }

  export type entitiesOrderByWithRelationInput = {
    entity_id?: SortOrder
    entity_username?: SortOrder
    entity_type?: SortOrder
    collections?: collectionsOrderByRelationAggregateInput
    contacts_contacts_contact_id_rootToentities?: contactsOrderByRelationAggregateInput
    contacts_contacts_contact_id_targetToentities?: contactsOrderByRelationAggregateInput
    conversations_members?: conversations_membersOrderByRelationAggregateInput
    conversations_messages_logs?: conversations_messages_logsOrderByRelationAggregateInput
    entities_content?: entities_contentOrderByRelationAggregateInput
    entities_dislikes?: entities_dislikesOrderByRelationAggregateInput
    entities_likes?: entities_likesOrderByRelationAggregateInput
    entities_references?: entities_referencesOrderByRelationAggregateInput
    groups_members?: groups_membersOrderByRelationAggregateInput
    images?: imagesOrderByRelationAggregateInput
    organizations_members?: organizations_membersOrderByRelationAggregateInput
    sheets?: sheetsOrderByRelationAggregateInput
    tables_members?: tables_membersOrderByRelationAggregateInput
    tables_messages_logs?: tables_messages_logsOrderByRelationAggregateInput
    tables_tabletops?: tables_tabletopsOrderByRelationAggregateInput
    videos?: videosOrderByRelationAggregateInput
  }

  export type entitiesWhereUniqueInput = Prisma.AtLeast<{
    entity_id?: string
    entity_username?: string
    AND?: entitiesWhereInput | entitiesWhereInput[]
    OR?: entitiesWhereInput[]
    NOT?: entitiesWhereInput | entitiesWhereInput[]
    entity_type?: IntFilter<"entities"> | number
    collections?: CollectionsListRelationFilter
    contacts_contacts_contact_id_rootToentities?: ContactsListRelationFilter
    contacts_contacts_contact_id_targetToentities?: ContactsListRelationFilter
    conversations_members?: Conversations_membersListRelationFilter
    conversations_messages_logs?: Conversations_messages_logsListRelationFilter
    entities_content?: Entities_contentListRelationFilter
    entities_dislikes?: Entities_dislikesListRelationFilter
    entities_likes?: Entities_likesListRelationFilter
    entities_references?: Entities_referencesListRelationFilter
    groups_members?: Groups_membersListRelationFilter
    images?: ImagesListRelationFilter
    organizations_members?: Organizations_membersListRelationFilter
    sheets?: SheetsListRelationFilter
    tables_members?: Tables_membersListRelationFilter
    tables_messages_logs?: Tables_messages_logsListRelationFilter
    tables_tabletops?: Tables_tabletopsListRelationFilter
    videos?: VideosListRelationFilter
  }, "entity_id" | "entity_id" | "entity_username">

  export type entitiesOrderByWithAggregationInput = {
    entity_id?: SortOrder
    entity_username?: SortOrder
    entity_type?: SortOrder
    _count?: entitiesCountOrderByAggregateInput
    _avg?: entitiesAvgOrderByAggregateInput
    _max?: entitiesMaxOrderByAggregateInput
    _min?: entitiesMinOrderByAggregateInput
    _sum?: entitiesSumOrderByAggregateInput
  }

  export type entitiesScalarWhereWithAggregatesInput = {
    AND?: entitiesScalarWhereWithAggregatesInput | entitiesScalarWhereWithAggregatesInput[]
    OR?: entitiesScalarWhereWithAggregatesInput[]
    NOT?: entitiesScalarWhereWithAggregatesInput | entitiesScalarWhereWithAggregatesInput[]
    entity_id?: StringWithAggregatesFilter<"entities"> | string
    entity_username?: StringWithAggregatesFilter<"entities"> | string
    entity_type?: IntWithAggregatesFilter<"entities"> | number
  }

  export type entities_contentWhereInput = {
    AND?: entities_contentWhereInput | entities_contentWhereInput[]
    OR?: entities_contentWhereInput[]
    NOT?: entities_contentWhereInput | entities_contentWhereInput[]
    entities_content_id?: StringFilter<"entities_content"> | string
    entity_id?: StringFilter<"entities_content"> | string
    content_id?: StringFilter<"entities_content"> | string
    date_added?: DateTimeFilter<"entities_content"> | Date | string
    pinned?: BoolFilter<"entities_content"> | boolean
    date_pinned?: DateTimeNullableFilter<"entities_content"> | Date | string | null
    content?: XOR<ContentRelationFilter, contentWhereInput>
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
  }

  export type entities_contentOrderByWithRelationInput = {
    entities_content_id?: SortOrder
    entity_id?: SortOrder
    content_id?: SortOrder
    date_added?: SortOrder
    pinned?: SortOrder
    date_pinned?: SortOrderInput | SortOrder
    content?: contentOrderByWithRelationInput
    entities?: entitiesOrderByWithRelationInput
  }

  export type entities_contentWhereUniqueInput = Prisma.AtLeast<{
    entities_content_id?: string
    AND?: entities_contentWhereInput | entities_contentWhereInput[]
    OR?: entities_contentWhereInput[]
    NOT?: entities_contentWhereInput | entities_contentWhereInput[]
    entity_id?: StringFilter<"entities_content"> | string
    content_id?: StringFilter<"entities_content"> | string
    date_added?: DateTimeFilter<"entities_content"> | Date | string
    pinned?: BoolFilter<"entities_content"> | boolean
    date_pinned?: DateTimeNullableFilter<"entities_content"> | Date | string | null
    content?: XOR<ContentRelationFilter, contentWhereInput>
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
  }, "entities_content_id" | "entities_content_id">

  export type entities_contentOrderByWithAggregationInput = {
    entities_content_id?: SortOrder
    entity_id?: SortOrder
    content_id?: SortOrder
    date_added?: SortOrder
    pinned?: SortOrder
    date_pinned?: SortOrderInput | SortOrder
    _count?: entities_contentCountOrderByAggregateInput
    _max?: entities_contentMaxOrderByAggregateInput
    _min?: entities_contentMinOrderByAggregateInput
  }

  export type entities_contentScalarWhereWithAggregatesInput = {
    AND?: entities_contentScalarWhereWithAggregatesInput | entities_contentScalarWhereWithAggregatesInput[]
    OR?: entities_contentScalarWhereWithAggregatesInput[]
    NOT?: entities_contentScalarWhereWithAggregatesInput | entities_contentScalarWhereWithAggregatesInput[]
    entities_content_id?: StringWithAggregatesFilter<"entities_content"> | string
    entity_id?: StringWithAggregatesFilter<"entities_content"> | string
    content_id?: StringWithAggregatesFilter<"entities_content"> | string
    date_added?: DateTimeWithAggregatesFilter<"entities_content"> | Date | string
    pinned?: BoolWithAggregatesFilter<"entities_content"> | boolean
    date_pinned?: DateTimeNullableWithAggregatesFilter<"entities_content"> | Date | string | null
  }

  export type entities_dislikesWhereInput = {
    AND?: entities_dislikesWhereInput | entities_dislikesWhereInput[]
    OR?: entities_dislikesWhereInput[]
    NOT?: entities_dislikesWhereInput | entities_dislikesWhereInput[]
    dislike_id?: StringFilter<"entities_dislikes"> | string
    entity_id?: StringFilter<"entities_dislikes"> | string
    content_id?: StringFilter<"entities_dislikes"> | string
    content?: XOR<ContentRelationFilter, contentWhereInput>
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
  }

  export type entities_dislikesOrderByWithRelationInput = {
    dislike_id?: SortOrder
    entity_id?: SortOrder
    content_id?: SortOrder
    content?: contentOrderByWithRelationInput
    entities?: entitiesOrderByWithRelationInput
  }

  export type entities_dislikesWhereUniqueInput = Prisma.AtLeast<{
    dislike_id?: string
    entity_id_content_id?: entities_dislikesEntity_idContent_idCompoundUniqueInput
    AND?: entities_dislikesWhereInput | entities_dislikesWhereInput[]
    OR?: entities_dislikesWhereInput[]
    NOT?: entities_dislikesWhereInput | entities_dislikesWhereInput[]
    entity_id?: StringFilter<"entities_dislikes"> | string
    content_id?: StringFilter<"entities_dislikes"> | string
    content?: XOR<ContentRelationFilter, contentWhereInput>
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
  }, "dislike_id" | "dislike_id" | "entity_id_content_id">

  export type entities_dislikesOrderByWithAggregationInput = {
    dislike_id?: SortOrder
    entity_id?: SortOrder
    content_id?: SortOrder
    _count?: entities_dislikesCountOrderByAggregateInput
    _max?: entities_dislikesMaxOrderByAggregateInput
    _min?: entities_dislikesMinOrderByAggregateInput
  }

  export type entities_dislikesScalarWhereWithAggregatesInput = {
    AND?: entities_dislikesScalarWhereWithAggregatesInput | entities_dislikesScalarWhereWithAggregatesInput[]
    OR?: entities_dislikesScalarWhereWithAggregatesInput[]
    NOT?: entities_dislikesScalarWhereWithAggregatesInput | entities_dislikesScalarWhereWithAggregatesInput[]
    dislike_id?: StringWithAggregatesFilter<"entities_dislikes"> | string
    entity_id?: StringWithAggregatesFilter<"entities_dislikes"> | string
    content_id?: StringWithAggregatesFilter<"entities_dislikes"> | string
  }

  export type entities_likesWhereInput = {
    AND?: entities_likesWhereInput | entities_likesWhereInput[]
    OR?: entities_likesWhereInput[]
    NOT?: entities_likesWhereInput | entities_likesWhereInput[]
    like_id?: StringFilter<"entities_likes"> | string
    entity_id?: StringFilter<"entities_likes"> | string
    content_id?: StringFilter<"entities_likes"> | string
    content?: XOR<ContentRelationFilter, contentWhereInput>
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
  }

  export type entities_likesOrderByWithRelationInput = {
    like_id?: SortOrder
    entity_id?: SortOrder
    content_id?: SortOrder
    content?: contentOrderByWithRelationInput
    entities?: entitiesOrderByWithRelationInput
  }

  export type entities_likesWhereUniqueInput = Prisma.AtLeast<{
    like_id?: string
    entity_id_content_id?: entities_likesEntity_idContent_idCompoundUniqueInput
    AND?: entities_likesWhereInput | entities_likesWhereInput[]
    OR?: entities_likesWhereInput[]
    NOT?: entities_likesWhereInput | entities_likesWhereInput[]
    entity_id?: StringFilter<"entities_likes"> | string
    content_id?: StringFilter<"entities_likes"> | string
    content?: XOR<ContentRelationFilter, contentWhereInput>
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
  }, "like_id" | "like_id" | "entity_id_content_id">

  export type entities_likesOrderByWithAggregationInput = {
    like_id?: SortOrder
    entity_id?: SortOrder
    content_id?: SortOrder
    _count?: entities_likesCountOrderByAggregateInput
    _max?: entities_likesMaxOrderByAggregateInput
    _min?: entities_likesMinOrderByAggregateInput
  }

  export type entities_likesScalarWhereWithAggregatesInput = {
    AND?: entities_likesScalarWhereWithAggregatesInput | entities_likesScalarWhereWithAggregatesInput[]
    OR?: entities_likesScalarWhereWithAggregatesInput[]
    NOT?: entities_likesScalarWhereWithAggregatesInput | entities_likesScalarWhereWithAggregatesInput[]
    like_id?: StringWithAggregatesFilter<"entities_likes"> | string
    entity_id?: StringWithAggregatesFilter<"entities_likes"> | string
    content_id?: StringWithAggregatesFilter<"entities_likes"> | string
  }

  export type entities_referencesWhereInput = {
    AND?: entities_referencesWhereInput | entities_referencesWhereInput[]
    OR?: entities_referencesWhereInput[]
    NOT?: entities_referencesWhereInput | entities_referencesWhereInput[]
    reference_id?: StringFilter<"entities_references"> | string
    entity_id?: StringFilter<"entities_references"> | string
    title?: StringFilter<"entities_references"> | string
    author?: StringFilter<"entities_references"> | string
    url?: StringFilter<"entities_references"> | string
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
  }

  export type entities_referencesOrderByWithRelationInput = {
    reference_id?: SortOrder
    entity_id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    url?: SortOrder
    entities?: entitiesOrderByWithRelationInput
  }

  export type entities_referencesWhereUniqueInput = Prisma.AtLeast<{
    reference_id?: string
    AND?: entities_referencesWhereInput | entities_referencesWhereInput[]
    OR?: entities_referencesWhereInput[]
    NOT?: entities_referencesWhereInput | entities_referencesWhereInput[]
    entity_id?: StringFilter<"entities_references"> | string
    title?: StringFilter<"entities_references"> | string
    author?: StringFilter<"entities_references"> | string
    url?: StringFilter<"entities_references"> | string
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
  }, "reference_id" | "reference_id">

  export type entities_referencesOrderByWithAggregationInput = {
    reference_id?: SortOrder
    entity_id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    url?: SortOrder
    _count?: entities_referencesCountOrderByAggregateInput
    _max?: entities_referencesMaxOrderByAggregateInput
    _min?: entities_referencesMinOrderByAggregateInput
  }

  export type entities_referencesScalarWhereWithAggregatesInput = {
    AND?: entities_referencesScalarWhereWithAggregatesInput | entities_referencesScalarWhereWithAggregatesInput[]
    OR?: entities_referencesScalarWhereWithAggregatesInput[]
    NOT?: entities_referencesScalarWhereWithAggregatesInput | entities_referencesScalarWhereWithAggregatesInput[]
    reference_id?: StringWithAggregatesFilter<"entities_references"> | string
    entity_id?: StringWithAggregatesFilter<"entities_references"> | string
    title?: StringWithAggregatesFilter<"entities_references"> | string
    author?: StringWithAggregatesFilter<"entities_references"> | string
    url?: StringWithAggregatesFilter<"entities_references"> | string
  }

  export type groupsWhereInput = {
    AND?: groupsWhereInput | groupsWhereInput[]
    OR?: groupsWhereInput[]
    NOT?: groupsWhereInput | groupsWhereInput[]
    group_id?: StringFilter<"groups"> | string
    group_handle?: StringFilter<"groups"> | string
    group_name?: StringNullableFilter<"groups"> | string | null
    group_current_issue?: StringNullableFilter<"groups"> | string | null
    group_stances?: StringNullableFilter<"groups"> | string | null
    group_description?: StringNullableFilter<"groups"> | string | null
    profile_picture_id?: StringNullableFilter<"groups"> | string | null
    profile_pictures?: XOR<Profile_picturesNullableRelationFilter, profile_picturesWhereInput> | null
    groups_members?: Groups_membersListRelationFilter
  }

  export type groupsOrderByWithRelationInput = {
    group_id?: SortOrder
    group_handle?: SortOrder
    group_name?: SortOrderInput | SortOrder
    group_current_issue?: SortOrderInput | SortOrder
    group_stances?: SortOrderInput | SortOrder
    group_description?: SortOrderInput | SortOrder
    profile_picture_id?: SortOrderInput | SortOrder
    profile_pictures?: profile_picturesOrderByWithRelationInput
    groups_members?: groups_membersOrderByRelationAggregateInput
  }

  export type groupsWhereUniqueInput = Prisma.AtLeast<{
    group_id?: string
    group_handle?: string
    AND?: groupsWhereInput | groupsWhereInput[]
    OR?: groupsWhereInput[]
    NOT?: groupsWhereInput | groupsWhereInput[]
    group_name?: StringNullableFilter<"groups"> | string | null
    group_current_issue?: StringNullableFilter<"groups"> | string | null
    group_stances?: StringNullableFilter<"groups"> | string | null
    group_description?: StringNullableFilter<"groups"> | string | null
    profile_picture_id?: StringNullableFilter<"groups"> | string | null
    profile_pictures?: XOR<Profile_picturesNullableRelationFilter, profile_picturesWhereInput> | null
    groups_members?: Groups_membersListRelationFilter
  }, "group_id" | "group_id" | "group_handle">

  export type groupsOrderByWithAggregationInput = {
    group_id?: SortOrder
    group_handle?: SortOrder
    group_name?: SortOrderInput | SortOrder
    group_current_issue?: SortOrderInput | SortOrder
    group_stances?: SortOrderInput | SortOrder
    group_description?: SortOrderInput | SortOrder
    profile_picture_id?: SortOrderInput | SortOrder
    _count?: groupsCountOrderByAggregateInput
    _max?: groupsMaxOrderByAggregateInput
    _min?: groupsMinOrderByAggregateInput
  }

  export type groupsScalarWhereWithAggregatesInput = {
    AND?: groupsScalarWhereWithAggregatesInput | groupsScalarWhereWithAggregatesInput[]
    OR?: groupsScalarWhereWithAggregatesInput[]
    NOT?: groupsScalarWhereWithAggregatesInput | groupsScalarWhereWithAggregatesInput[]
    group_id?: StringWithAggregatesFilter<"groups"> | string
    group_handle?: StringWithAggregatesFilter<"groups"> | string
    group_name?: StringNullableWithAggregatesFilter<"groups"> | string | null
    group_current_issue?: StringNullableWithAggregatesFilter<"groups"> | string | null
    group_stances?: StringNullableWithAggregatesFilter<"groups"> | string | null
    group_description?: StringNullableWithAggregatesFilter<"groups"> | string | null
    profile_picture_id?: StringNullableWithAggregatesFilter<"groups"> | string | null
  }

  export type groups_membersWhereInput = {
    AND?: groups_membersWhereInput | groups_membersWhereInput[]
    OR?: groups_membersWhereInput[]
    NOT?: groups_membersWhereInput | groups_membersWhereInput[]
    groups_members_id?: StringFilter<"groups_members"> | string
    group_id?: StringFilter<"groups_members"> | string
    entity_id?: StringFilter<"groups_members"> | string
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
    groups?: XOR<GroupsRelationFilter, groupsWhereInput>
  }

  export type groups_membersOrderByWithRelationInput = {
    groups_members_id?: SortOrder
    group_id?: SortOrder
    entity_id?: SortOrder
    entities?: entitiesOrderByWithRelationInput
    groups?: groupsOrderByWithRelationInput
  }

  export type groups_membersWhereUniqueInput = Prisma.AtLeast<{
    groups_members_id?: string
    group_id_entity_id?: groups_membersGroup_idEntity_idCompoundUniqueInput
    AND?: groups_membersWhereInput | groups_membersWhereInput[]
    OR?: groups_membersWhereInput[]
    NOT?: groups_membersWhereInput | groups_membersWhereInput[]
    group_id?: StringFilter<"groups_members"> | string
    entity_id?: StringFilter<"groups_members"> | string
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
    groups?: XOR<GroupsRelationFilter, groupsWhereInput>
  }, "groups_members_id" | "groups_members_id" | "group_id_entity_id">

  export type groups_membersOrderByWithAggregationInput = {
    groups_members_id?: SortOrder
    group_id?: SortOrder
    entity_id?: SortOrder
    _count?: groups_membersCountOrderByAggregateInput
    _max?: groups_membersMaxOrderByAggregateInput
    _min?: groups_membersMinOrderByAggregateInput
  }

  export type groups_membersScalarWhereWithAggregatesInput = {
    AND?: groups_membersScalarWhereWithAggregatesInput | groups_membersScalarWhereWithAggregatesInput[]
    OR?: groups_membersScalarWhereWithAggregatesInput[]
    NOT?: groups_membersScalarWhereWithAggregatesInput | groups_membersScalarWhereWithAggregatesInput[]
    groups_members_id?: StringWithAggregatesFilter<"groups_members"> | string
    group_id?: StringWithAggregatesFilter<"groups_members"> | string
    entity_id?: StringWithAggregatesFilter<"groups_members"> | string
  }

  export type imagesWhereInput = {
    AND?: imagesWhereInput | imagesWhereInput[]
    OR?: imagesWhereInput[]
    NOT?: imagesWhereInput | imagesWhereInput[]
    image_id?: StringFilter<"images"> | string
    image_creator_id?: StringFilter<"images"> | string
    image_title?: StringFilter<"images"> | string
    image_description?: StringFilter<"images"> | string
    image_filename?: StringFilter<"images"> | string
    image_data_id?: StringFilter<"images"> | string
    image_likes?: IntFilter<"images"> | number
    image_dislikes?: IntFilter<"images"> | number
    image_views?: IntFilter<"images"> | number
    image_date_posted?: DateTimeFilter<"images"> | Date | string
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
    images_data?: XOR<Images_dataRelationFilter, images_dataWhereInput>
  }

  export type imagesOrderByWithRelationInput = {
    image_id?: SortOrder
    image_creator_id?: SortOrder
    image_title?: SortOrder
    image_description?: SortOrder
    image_filename?: SortOrder
    image_data_id?: SortOrder
    image_likes?: SortOrder
    image_dislikes?: SortOrder
    image_views?: SortOrder
    image_date_posted?: SortOrder
    entities?: entitiesOrderByWithRelationInput
    images_data?: images_dataOrderByWithRelationInput
  }

  export type imagesWhereUniqueInput = Prisma.AtLeast<{
    image_id?: string
    AND?: imagesWhereInput | imagesWhereInput[]
    OR?: imagesWhereInput[]
    NOT?: imagesWhereInput | imagesWhereInput[]
    image_creator_id?: StringFilter<"images"> | string
    image_title?: StringFilter<"images"> | string
    image_description?: StringFilter<"images"> | string
    image_filename?: StringFilter<"images"> | string
    image_data_id?: StringFilter<"images"> | string
    image_likes?: IntFilter<"images"> | number
    image_dislikes?: IntFilter<"images"> | number
    image_views?: IntFilter<"images"> | number
    image_date_posted?: DateTimeFilter<"images"> | Date | string
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
    images_data?: XOR<Images_dataRelationFilter, images_dataWhereInput>
  }, "image_id" | "image_id">

  export type imagesOrderByWithAggregationInput = {
    image_id?: SortOrder
    image_creator_id?: SortOrder
    image_title?: SortOrder
    image_description?: SortOrder
    image_filename?: SortOrder
    image_data_id?: SortOrder
    image_likes?: SortOrder
    image_dislikes?: SortOrder
    image_views?: SortOrder
    image_date_posted?: SortOrder
    _count?: imagesCountOrderByAggregateInput
    _avg?: imagesAvgOrderByAggregateInput
    _max?: imagesMaxOrderByAggregateInput
    _min?: imagesMinOrderByAggregateInput
    _sum?: imagesSumOrderByAggregateInput
  }

  export type imagesScalarWhereWithAggregatesInput = {
    AND?: imagesScalarWhereWithAggregatesInput | imagesScalarWhereWithAggregatesInput[]
    OR?: imagesScalarWhereWithAggregatesInput[]
    NOT?: imagesScalarWhereWithAggregatesInput | imagesScalarWhereWithAggregatesInput[]
    image_id?: StringWithAggregatesFilter<"images"> | string
    image_creator_id?: StringWithAggregatesFilter<"images"> | string
    image_title?: StringWithAggregatesFilter<"images"> | string
    image_description?: StringWithAggregatesFilter<"images"> | string
    image_filename?: StringWithAggregatesFilter<"images"> | string
    image_data_id?: StringWithAggregatesFilter<"images"> | string
    image_likes?: IntWithAggregatesFilter<"images"> | number
    image_dislikes?: IntWithAggregatesFilter<"images"> | number
    image_views?: IntWithAggregatesFilter<"images"> | number
    image_date_posted?: DateTimeWithAggregatesFilter<"images"> | Date | string
  }

  export type images_dataWhereInput = {
    AND?: images_dataWhereInput | images_dataWhereInput[]
    OR?: images_dataWhereInput[]
    NOT?: images_dataWhereInput | images_dataWhereInput[]
    image_data_id?: StringFilter<"images_data"> | string
    image_data?: BytesFilter<"images_data"> | Buffer
    images?: ImagesListRelationFilter
  }

  export type images_dataOrderByWithRelationInput = {
    image_data_id?: SortOrder
    image_data?: SortOrder
    images?: imagesOrderByRelationAggregateInput
  }

  export type images_dataWhereUniqueInput = Prisma.AtLeast<{
    image_data_id?: string
    AND?: images_dataWhereInput | images_dataWhereInput[]
    OR?: images_dataWhereInput[]
    NOT?: images_dataWhereInput | images_dataWhereInput[]
    image_data?: BytesFilter<"images_data"> | Buffer
    images?: ImagesListRelationFilter
  }, "image_data_id" | "image_data_id">

  export type images_dataOrderByWithAggregationInput = {
    image_data_id?: SortOrder
    image_data?: SortOrder
    _count?: images_dataCountOrderByAggregateInput
    _max?: images_dataMaxOrderByAggregateInput
    _min?: images_dataMinOrderByAggregateInput
  }

  export type images_dataScalarWhereWithAggregatesInput = {
    AND?: images_dataScalarWhereWithAggregatesInput | images_dataScalarWhereWithAggregatesInput[]
    OR?: images_dataScalarWhereWithAggregatesInput[]
    NOT?: images_dataScalarWhereWithAggregatesInput | images_dataScalarWhereWithAggregatesInput[]
    image_data_id?: StringWithAggregatesFilter<"images_data"> | string
    image_data?: BytesWithAggregatesFilter<"images_data"> | Buffer
  }

  export type individualsWhereInput = {
    AND?: individualsWhereInput | individualsWhereInput[]
    OR?: individualsWhereInput[]
    NOT?: individualsWhereInput | individualsWhereInput[]
    individual_id?: StringFilter<"individuals"> | string
    individual_username?: StringFilter<"individuals"> | string
    individual_name?: StringNullableFilter<"individuals"> | string | null
    individual_current_issue?: StringNullableFilter<"individuals"> | string | null
    individual_roles?: StringNullableFilter<"individuals"> | string | null
    individual_description?: StringNullableFilter<"individuals"> | string | null
    profile_picture_id?: StringNullableFilter<"individuals"> | string | null
    user_credentials?: XOR<User_credentialsRelationFilter, user_credentialsWhereInput>
    profile_pictures?: XOR<Profile_picturesNullableRelationFilter, profile_picturesWhereInput> | null
  }

  export type individualsOrderByWithRelationInput = {
    individual_id?: SortOrder
    individual_username?: SortOrder
    individual_name?: SortOrderInput | SortOrder
    individual_current_issue?: SortOrderInput | SortOrder
    individual_roles?: SortOrderInput | SortOrder
    individual_description?: SortOrderInput | SortOrder
    profile_picture_id?: SortOrderInput | SortOrder
    user_credentials?: user_credentialsOrderByWithRelationInput
    profile_pictures?: profile_picturesOrderByWithRelationInput
  }

  export type individualsWhereUniqueInput = Prisma.AtLeast<{
    individual_id?: string
    individual_username?: string
    AND?: individualsWhereInput | individualsWhereInput[]
    OR?: individualsWhereInput[]
    NOT?: individualsWhereInput | individualsWhereInput[]
    individual_name?: StringNullableFilter<"individuals"> | string | null
    individual_current_issue?: StringNullableFilter<"individuals"> | string | null
    individual_roles?: StringNullableFilter<"individuals"> | string | null
    individual_description?: StringNullableFilter<"individuals"> | string | null
    profile_picture_id?: StringNullableFilter<"individuals"> | string | null
    user_credentials?: XOR<User_credentialsRelationFilter, user_credentialsWhereInput>
    profile_pictures?: XOR<Profile_picturesNullableRelationFilter, profile_picturesWhereInput> | null
  }, "individual_id" | "individual_id" | "individual_username">

  export type individualsOrderByWithAggregationInput = {
    individual_id?: SortOrder
    individual_username?: SortOrder
    individual_name?: SortOrderInput | SortOrder
    individual_current_issue?: SortOrderInput | SortOrder
    individual_roles?: SortOrderInput | SortOrder
    individual_description?: SortOrderInput | SortOrder
    profile_picture_id?: SortOrderInput | SortOrder
    _count?: individualsCountOrderByAggregateInput
    _max?: individualsMaxOrderByAggregateInput
    _min?: individualsMinOrderByAggregateInput
  }

  export type individualsScalarWhereWithAggregatesInput = {
    AND?: individualsScalarWhereWithAggregatesInput | individualsScalarWhereWithAggregatesInput[]
    OR?: individualsScalarWhereWithAggregatesInput[]
    NOT?: individualsScalarWhereWithAggregatesInput | individualsScalarWhereWithAggregatesInput[]
    individual_id?: StringWithAggregatesFilter<"individuals"> | string
    individual_username?: StringWithAggregatesFilter<"individuals"> | string
    individual_name?: StringNullableWithAggregatesFilter<"individuals"> | string | null
    individual_current_issue?: StringNullableWithAggregatesFilter<"individuals"> | string | null
    individual_roles?: StringNullableWithAggregatesFilter<"individuals"> | string | null
    individual_description?: StringNullableWithAggregatesFilter<"individuals"> | string | null
    profile_picture_id?: StringNullableWithAggregatesFilter<"individuals"> | string | null
  }

  export type organizationsWhereInput = {
    AND?: organizationsWhereInput | organizationsWhereInput[]
    OR?: organizationsWhereInput[]
    NOT?: organizationsWhereInput | organizationsWhereInput[]
    organization_id?: StringFilter<"organizations"> | string
    organization_handle?: StringFilter<"organizations"> | string
    organization_name?: StringNullableFilter<"organizations"> | string | null
    organization_current_issue?: StringNullableFilter<"organizations"> | string | null
    organization_stances?: StringNullableFilter<"organizations"> | string | null
    organization_description?: StringNullableFilter<"organizations"> | string | null
    profile_picture_id?: StringNullableFilter<"organizations"> | string | null
    profile_pictures?: XOR<Profile_picturesNullableRelationFilter, profile_picturesWhereInput> | null
    organizations_members?: Organizations_membersListRelationFilter
  }

  export type organizationsOrderByWithRelationInput = {
    organization_id?: SortOrder
    organization_handle?: SortOrder
    organization_name?: SortOrderInput | SortOrder
    organization_current_issue?: SortOrderInput | SortOrder
    organization_stances?: SortOrderInput | SortOrder
    organization_description?: SortOrderInput | SortOrder
    profile_picture_id?: SortOrderInput | SortOrder
    profile_pictures?: profile_picturesOrderByWithRelationInput
    organizations_members?: organizations_membersOrderByRelationAggregateInput
  }

  export type organizationsWhereUniqueInput = Prisma.AtLeast<{
    organization_id?: string
    organization_handle?: string
    AND?: organizationsWhereInput | organizationsWhereInput[]
    OR?: organizationsWhereInput[]
    NOT?: organizationsWhereInput | organizationsWhereInput[]
    organization_name?: StringNullableFilter<"organizations"> | string | null
    organization_current_issue?: StringNullableFilter<"organizations"> | string | null
    organization_stances?: StringNullableFilter<"organizations"> | string | null
    organization_description?: StringNullableFilter<"organizations"> | string | null
    profile_picture_id?: StringNullableFilter<"organizations"> | string | null
    profile_pictures?: XOR<Profile_picturesNullableRelationFilter, profile_picturesWhereInput> | null
    organizations_members?: Organizations_membersListRelationFilter
  }, "organization_id" | "organization_id" | "organization_handle">

  export type organizationsOrderByWithAggregationInput = {
    organization_id?: SortOrder
    organization_handle?: SortOrder
    organization_name?: SortOrderInput | SortOrder
    organization_current_issue?: SortOrderInput | SortOrder
    organization_stances?: SortOrderInput | SortOrder
    organization_description?: SortOrderInput | SortOrder
    profile_picture_id?: SortOrderInput | SortOrder
    _count?: organizationsCountOrderByAggregateInput
    _max?: organizationsMaxOrderByAggregateInput
    _min?: organizationsMinOrderByAggregateInput
  }

  export type organizationsScalarWhereWithAggregatesInput = {
    AND?: organizationsScalarWhereWithAggregatesInput | organizationsScalarWhereWithAggregatesInput[]
    OR?: organizationsScalarWhereWithAggregatesInput[]
    NOT?: organizationsScalarWhereWithAggregatesInput | organizationsScalarWhereWithAggregatesInput[]
    organization_id?: StringWithAggregatesFilter<"organizations"> | string
    organization_handle?: StringWithAggregatesFilter<"organizations"> | string
    organization_name?: StringNullableWithAggregatesFilter<"organizations"> | string | null
    organization_current_issue?: StringNullableWithAggregatesFilter<"organizations"> | string | null
    organization_stances?: StringNullableWithAggregatesFilter<"organizations"> | string | null
    organization_description?: StringNullableWithAggregatesFilter<"organizations"> | string | null
    profile_picture_id?: StringNullableWithAggregatesFilter<"organizations"> | string | null
  }

  export type organizations_membersWhereInput = {
    AND?: organizations_membersWhereInput | organizations_membersWhereInput[]
    OR?: organizations_membersWhereInput[]
    NOT?: organizations_membersWhereInput | organizations_membersWhereInput[]
    organizations_members_id?: StringFilter<"organizations_members"> | string
    organization_id?: StringFilter<"organizations_members"> | string
    entity_id?: StringFilter<"organizations_members"> | string
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
    organizations?: XOR<OrganizationsRelationFilter, organizationsWhereInput>
  }

  export type organizations_membersOrderByWithRelationInput = {
    organizations_members_id?: SortOrder
    organization_id?: SortOrder
    entity_id?: SortOrder
    entities?: entitiesOrderByWithRelationInput
    organizations?: organizationsOrderByWithRelationInput
  }

  export type organizations_membersWhereUniqueInput = Prisma.AtLeast<{
    organizations_members_id?: string
    AND?: organizations_membersWhereInput | organizations_membersWhereInput[]
    OR?: organizations_membersWhereInput[]
    NOT?: organizations_membersWhereInput | organizations_membersWhereInput[]
    organization_id?: StringFilter<"organizations_members"> | string
    entity_id?: StringFilter<"organizations_members"> | string
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
    organizations?: XOR<OrganizationsRelationFilter, organizationsWhereInput>
  }, "organizations_members_id" | "organizations_members_id">

  export type organizations_membersOrderByWithAggregationInput = {
    organizations_members_id?: SortOrder
    organization_id?: SortOrder
    entity_id?: SortOrder
    _count?: organizations_membersCountOrderByAggregateInput
    _max?: organizations_membersMaxOrderByAggregateInput
    _min?: organizations_membersMinOrderByAggregateInput
  }

  export type organizations_membersScalarWhereWithAggregatesInput = {
    AND?: organizations_membersScalarWhereWithAggregatesInput | organizations_membersScalarWhereWithAggregatesInput[]
    OR?: organizations_membersScalarWhereWithAggregatesInput[]
    NOT?: organizations_membersScalarWhereWithAggregatesInput | organizations_membersScalarWhereWithAggregatesInput[]
    organizations_members_id?: StringWithAggregatesFilter<"organizations_members"> | string
    organization_id?: StringWithAggregatesFilter<"organizations_members"> | string
    entity_id?: StringWithAggregatesFilter<"organizations_members"> | string
  }

  export type profile_picturesWhereInput = {
    AND?: profile_picturesWhereInput | profile_picturesWhereInput[]
    OR?: profile_picturesWhereInput[]
    NOT?: profile_picturesWhereInput | profile_picturesWhereInput[]
    profile_picture_id?: StringFilter<"profile_pictures"> | string
    profile_picture_data?: BytesFilter<"profile_pictures"> | Buffer
    profile_picture_filename?: StringFilter<"profile_pictures"> | string
    groups?: GroupsListRelationFilter
    individuals?: IndividualsListRelationFilter
    organizations?: OrganizationsListRelationFilter
  }

  export type profile_picturesOrderByWithRelationInput = {
    profile_picture_id?: SortOrder
    profile_picture_data?: SortOrder
    profile_picture_filename?: SortOrder
    groups?: groupsOrderByRelationAggregateInput
    individuals?: individualsOrderByRelationAggregateInput
    organizations?: organizationsOrderByRelationAggregateInput
  }

  export type profile_picturesWhereUniqueInput = Prisma.AtLeast<{
    profile_picture_id?: string
    AND?: profile_picturesWhereInput | profile_picturesWhereInput[]
    OR?: profile_picturesWhereInput[]
    NOT?: profile_picturesWhereInput | profile_picturesWhereInput[]
    profile_picture_data?: BytesFilter<"profile_pictures"> | Buffer
    profile_picture_filename?: StringFilter<"profile_pictures"> | string
    groups?: GroupsListRelationFilter
    individuals?: IndividualsListRelationFilter
    organizations?: OrganizationsListRelationFilter
  }, "profile_picture_id" | "profile_picture_id">

  export type profile_picturesOrderByWithAggregationInput = {
    profile_picture_id?: SortOrder
    profile_picture_data?: SortOrder
    profile_picture_filename?: SortOrder
    _count?: profile_picturesCountOrderByAggregateInput
    _max?: profile_picturesMaxOrderByAggregateInput
    _min?: profile_picturesMinOrderByAggregateInput
  }

  export type profile_picturesScalarWhereWithAggregatesInput = {
    AND?: profile_picturesScalarWhereWithAggregatesInput | profile_picturesScalarWhereWithAggregatesInput[]
    OR?: profile_picturesScalarWhereWithAggregatesInput[]
    NOT?: profile_picturesScalarWhereWithAggregatesInput | profile_picturesScalarWhereWithAggregatesInput[]
    profile_picture_id?: StringWithAggregatesFilter<"profile_pictures"> | string
    profile_picture_data?: BytesWithAggregatesFilter<"profile_pictures"> | Buffer
    profile_picture_filename?: StringWithAggregatesFilter<"profile_pictures"> | string
  }

  export type sheetsWhereInput = {
    AND?: sheetsWhereInput | sheetsWhereInput[]
    OR?: sheetsWhereInput[]
    NOT?: sheetsWhereInput | sheetsWhereInput[]
    sheet_id?: StringFilter<"sheets"> | string
    sheet_author_id?: StringFilter<"sheets"> | string
    sheet_title?: StringFilter<"sheets"> | string
    sheet_subject?: StringFilter<"sheets"> | string
    sheet_filename?: StringFilter<"sheets"> | string
    sheet_data_id?: StringFilter<"sheets"> | string
    sheet_thumbnail_id?: StringNullableFilter<"sheets"> | string | null
    sheet_likes?: IntFilter<"sheets"> | number
    sheet_dislikes?: IntFilter<"sheets"> | number
    sheet_views?: IntFilter<"sheets"> | number
    sheet_date_posted?: DateTimeFilter<"sheets"> | Date | string
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
    sheets_data?: XOR<Sheets_dataRelationFilter, sheets_dataWhereInput>
    sheets_thumbnails?: XOR<Sheets_thumbnailsNullableRelationFilter, sheets_thumbnailsWhereInput> | null
  }

  export type sheetsOrderByWithRelationInput = {
    sheet_id?: SortOrder
    sheet_author_id?: SortOrder
    sheet_title?: SortOrder
    sheet_subject?: SortOrder
    sheet_filename?: SortOrder
    sheet_data_id?: SortOrder
    sheet_thumbnail_id?: SortOrderInput | SortOrder
    sheet_likes?: SortOrder
    sheet_dislikes?: SortOrder
    sheet_views?: SortOrder
    sheet_date_posted?: SortOrder
    entities?: entitiesOrderByWithRelationInput
    sheets_data?: sheets_dataOrderByWithRelationInput
    sheets_thumbnails?: sheets_thumbnailsOrderByWithRelationInput
  }

  export type sheetsWhereUniqueInput = Prisma.AtLeast<{
    sheet_id?: string
    AND?: sheetsWhereInput | sheetsWhereInput[]
    OR?: sheetsWhereInput[]
    NOT?: sheetsWhereInput | sheetsWhereInput[]
    sheet_author_id?: StringFilter<"sheets"> | string
    sheet_title?: StringFilter<"sheets"> | string
    sheet_subject?: StringFilter<"sheets"> | string
    sheet_filename?: StringFilter<"sheets"> | string
    sheet_data_id?: StringFilter<"sheets"> | string
    sheet_thumbnail_id?: StringNullableFilter<"sheets"> | string | null
    sheet_likes?: IntFilter<"sheets"> | number
    sheet_dislikes?: IntFilter<"sheets"> | number
    sheet_views?: IntFilter<"sheets"> | number
    sheet_date_posted?: DateTimeFilter<"sheets"> | Date | string
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
    sheets_data?: XOR<Sheets_dataRelationFilter, sheets_dataWhereInput>
    sheets_thumbnails?: XOR<Sheets_thumbnailsNullableRelationFilter, sheets_thumbnailsWhereInput> | null
  }, "sheet_id" | "sheet_id">

  export type sheetsOrderByWithAggregationInput = {
    sheet_id?: SortOrder
    sheet_author_id?: SortOrder
    sheet_title?: SortOrder
    sheet_subject?: SortOrder
    sheet_filename?: SortOrder
    sheet_data_id?: SortOrder
    sheet_thumbnail_id?: SortOrderInput | SortOrder
    sheet_likes?: SortOrder
    sheet_dislikes?: SortOrder
    sheet_views?: SortOrder
    sheet_date_posted?: SortOrder
    _count?: sheetsCountOrderByAggregateInput
    _avg?: sheetsAvgOrderByAggregateInput
    _max?: sheetsMaxOrderByAggregateInput
    _min?: sheetsMinOrderByAggregateInput
    _sum?: sheetsSumOrderByAggregateInput
  }

  export type sheetsScalarWhereWithAggregatesInput = {
    AND?: sheetsScalarWhereWithAggregatesInput | sheetsScalarWhereWithAggregatesInput[]
    OR?: sheetsScalarWhereWithAggregatesInput[]
    NOT?: sheetsScalarWhereWithAggregatesInput | sheetsScalarWhereWithAggregatesInput[]
    sheet_id?: StringWithAggregatesFilter<"sheets"> | string
    sheet_author_id?: StringWithAggregatesFilter<"sheets"> | string
    sheet_title?: StringWithAggregatesFilter<"sheets"> | string
    sheet_subject?: StringWithAggregatesFilter<"sheets"> | string
    sheet_filename?: StringWithAggregatesFilter<"sheets"> | string
    sheet_data_id?: StringWithAggregatesFilter<"sheets"> | string
    sheet_thumbnail_id?: StringNullableWithAggregatesFilter<"sheets"> | string | null
    sheet_likes?: IntWithAggregatesFilter<"sheets"> | number
    sheet_dislikes?: IntWithAggregatesFilter<"sheets"> | number
    sheet_views?: IntWithAggregatesFilter<"sheets"> | number
    sheet_date_posted?: DateTimeWithAggregatesFilter<"sheets"> | Date | string
  }

  export type sheets_dataWhereInput = {
    AND?: sheets_dataWhereInput | sheets_dataWhereInput[]
    OR?: sheets_dataWhereInput[]
    NOT?: sheets_dataWhereInput | sheets_dataWhereInput[]
    sheet_data_id?: StringFilter<"sheets_data"> | string
    sheet_data?: BytesFilter<"sheets_data"> | Buffer
    sheets?: SheetsListRelationFilter
  }

  export type sheets_dataOrderByWithRelationInput = {
    sheet_data_id?: SortOrder
    sheet_data?: SortOrder
    sheets?: sheetsOrderByRelationAggregateInput
  }

  export type sheets_dataWhereUniqueInput = Prisma.AtLeast<{
    sheet_data_id?: string
    AND?: sheets_dataWhereInput | sheets_dataWhereInput[]
    OR?: sheets_dataWhereInput[]
    NOT?: sheets_dataWhereInput | sheets_dataWhereInput[]
    sheet_data?: BytesFilter<"sheets_data"> | Buffer
    sheets?: SheetsListRelationFilter
  }, "sheet_data_id" | "sheet_data_id">

  export type sheets_dataOrderByWithAggregationInput = {
    sheet_data_id?: SortOrder
    sheet_data?: SortOrder
    _count?: sheets_dataCountOrderByAggregateInput
    _max?: sheets_dataMaxOrderByAggregateInput
    _min?: sheets_dataMinOrderByAggregateInput
  }

  export type sheets_dataScalarWhereWithAggregatesInput = {
    AND?: sheets_dataScalarWhereWithAggregatesInput | sheets_dataScalarWhereWithAggregatesInput[]
    OR?: sheets_dataScalarWhereWithAggregatesInput[]
    NOT?: sheets_dataScalarWhereWithAggregatesInput | sheets_dataScalarWhereWithAggregatesInput[]
    sheet_data_id?: StringWithAggregatesFilter<"sheets_data"> | string
    sheet_data?: BytesWithAggregatesFilter<"sheets_data"> | Buffer
  }

  export type sheets_thumbnailsWhereInput = {
    AND?: sheets_thumbnailsWhereInput | sheets_thumbnailsWhereInput[]
    OR?: sheets_thumbnailsWhereInput[]
    NOT?: sheets_thumbnailsWhereInput | sheets_thumbnailsWhereInput[]
    sheet_thumbnail_id?: StringFilter<"sheets_thumbnails"> | string
    sheet_thumbnail_data?: BytesFilter<"sheets_thumbnails"> | Buffer
    sheet_thumbnail_filename?: StringFilter<"sheets_thumbnails"> | string
    sheet_thumbnail_description?: StringNullableFilter<"sheets_thumbnails"> | string | null
    sheets?: SheetsListRelationFilter
  }

  export type sheets_thumbnailsOrderByWithRelationInput = {
    sheet_thumbnail_id?: SortOrder
    sheet_thumbnail_data?: SortOrder
    sheet_thumbnail_filename?: SortOrder
    sheet_thumbnail_description?: SortOrderInput | SortOrder
    sheets?: sheetsOrderByRelationAggregateInput
  }

  export type sheets_thumbnailsWhereUniqueInput = Prisma.AtLeast<{
    sheet_thumbnail_id?: string
    AND?: sheets_thumbnailsWhereInput | sheets_thumbnailsWhereInput[]
    OR?: sheets_thumbnailsWhereInput[]
    NOT?: sheets_thumbnailsWhereInput | sheets_thumbnailsWhereInput[]
    sheet_thumbnail_data?: BytesFilter<"sheets_thumbnails"> | Buffer
    sheet_thumbnail_filename?: StringFilter<"sheets_thumbnails"> | string
    sheet_thumbnail_description?: StringNullableFilter<"sheets_thumbnails"> | string | null
    sheets?: SheetsListRelationFilter
  }, "sheet_thumbnail_id" | "sheet_thumbnail_id">

  export type sheets_thumbnailsOrderByWithAggregationInput = {
    sheet_thumbnail_id?: SortOrder
    sheet_thumbnail_data?: SortOrder
    sheet_thumbnail_filename?: SortOrder
    sheet_thumbnail_description?: SortOrderInput | SortOrder
    _count?: sheets_thumbnailsCountOrderByAggregateInput
    _max?: sheets_thumbnailsMaxOrderByAggregateInput
    _min?: sheets_thumbnailsMinOrderByAggregateInput
  }

  export type sheets_thumbnailsScalarWhereWithAggregatesInput = {
    AND?: sheets_thumbnailsScalarWhereWithAggregatesInput | sheets_thumbnailsScalarWhereWithAggregatesInput[]
    OR?: sheets_thumbnailsScalarWhereWithAggregatesInput[]
    NOT?: sheets_thumbnailsScalarWhereWithAggregatesInput | sheets_thumbnailsScalarWhereWithAggregatesInput[]
    sheet_thumbnail_id?: StringWithAggregatesFilter<"sheets_thumbnails"> | string
    sheet_thumbnail_data?: BytesWithAggregatesFilter<"sheets_thumbnails"> | Buffer
    sheet_thumbnail_filename?: StringWithAggregatesFilter<"sheets_thumbnails"> | string
    sheet_thumbnail_description?: StringNullableWithAggregatesFilter<"sheets_thumbnails"> | string | null
  }

  export type tablesWhereInput = {
    AND?: tablesWhereInput | tablesWhereInput[]
    OR?: tablesWhereInput[]
    NOT?: tablesWhereInput | tablesWhereInput[]
    table_id?: StringFilter<"tables"> | string
    table_name?: StringNullableFilter<"tables"> | string | null
    table_creation_date?: DateTimeFilter<"tables"> | Date | string
    last_message?: StringNullableFilter<"tables"> | string | null
    last_message_date?: DateTimeNullableFilter<"tables"> | Date | string | null
    tables_pictures_id?: StringNullableFilter<"tables"> | string | null
    tables_pictures?: XOR<Tables_picturesNullableRelationFilter, tables_picturesWhereInput> | null
    tables_members?: Tables_membersListRelationFilter
    tables_messages_logs?: Tables_messages_logsListRelationFilter
    tables_tabletops?: Tables_tabletopsListRelationFilter
  }

  export type tablesOrderByWithRelationInput = {
    table_id?: SortOrder
    table_name?: SortOrderInput | SortOrder
    table_creation_date?: SortOrder
    last_message?: SortOrderInput | SortOrder
    last_message_date?: SortOrderInput | SortOrder
    tables_pictures_id?: SortOrderInput | SortOrder
    tables_pictures?: tables_picturesOrderByWithRelationInput
    tables_members?: tables_membersOrderByRelationAggregateInput
    tables_messages_logs?: tables_messages_logsOrderByRelationAggregateInput
    tables_tabletops?: tables_tabletopsOrderByRelationAggregateInput
  }

  export type tablesWhereUniqueInput = Prisma.AtLeast<{
    table_id?: string
    AND?: tablesWhereInput | tablesWhereInput[]
    OR?: tablesWhereInput[]
    NOT?: tablesWhereInput | tablesWhereInput[]
    table_name?: StringNullableFilter<"tables"> | string | null
    table_creation_date?: DateTimeFilter<"tables"> | Date | string
    last_message?: StringNullableFilter<"tables"> | string | null
    last_message_date?: DateTimeNullableFilter<"tables"> | Date | string | null
    tables_pictures_id?: StringNullableFilter<"tables"> | string | null
    tables_pictures?: XOR<Tables_picturesNullableRelationFilter, tables_picturesWhereInput> | null
    tables_members?: Tables_membersListRelationFilter
    tables_messages_logs?: Tables_messages_logsListRelationFilter
    tables_tabletops?: Tables_tabletopsListRelationFilter
  }, "table_id" | "table_id">

  export type tablesOrderByWithAggregationInput = {
    table_id?: SortOrder
    table_name?: SortOrderInput | SortOrder
    table_creation_date?: SortOrder
    last_message?: SortOrderInput | SortOrder
    last_message_date?: SortOrderInput | SortOrder
    tables_pictures_id?: SortOrderInput | SortOrder
    _count?: tablesCountOrderByAggregateInput
    _max?: tablesMaxOrderByAggregateInput
    _min?: tablesMinOrderByAggregateInput
  }

  export type tablesScalarWhereWithAggregatesInput = {
    AND?: tablesScalarWhereWithAggregatesInput | tablesScalarWhereWithAggregatesInput[]
    OR?: tablesScalarWhereWithAggregatesInput[]
    NOT?: tablesScalarWhereWithAggregatesInput | tablesScalarWhereWithAggregatesInput[]
    table_id?: StringWithAggregatesFilter<"tables"> | string
    table_name?: StringNullableWithAggregatesFilter<"tables"> | string | null
    table_creation_date?: DateTimeWithAggregatesFilter<"tables"> | Date | string
    last_message?: StringNullableWithAggregatesFilter<"tables"> | string | null
    last_message_date?: DateTimeNullableWithAggregatesFilter<"tables"> | Date | string | null
    tables_pictures_id?: StringNullableWithAggregatesFilter<"tables"> | string | null
  }

  export type tables_membersWhereInput = {
    AND?: tables_membersWhereInput | tables_membersWhereInput[]
    OR?: tables_membersWhereInput[]
    NOT?: tables_membersWhereInput | tables_membersWhereInput[]
    tables_members_id?: StringFilter<"tables_members"> | string
    table_id?: StringFilter<"tables_members"> | string
    member_id?: StringFilter<"tables_members"> | string
    table_position?: IntFilter<"tables_members"> | number
    live?: IntFilter<"tables_members"> | number
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
    tables?: XOR<TablesRelationFilter, tablesWhereInput>
  }

  export type tables_membersOrderByWithRelationInput = {
    tables_members_id?: SortOrder
    table_id?: SortOrder
    member_id?: SortOrder
    table_position?: SortOrder
    live?: SortOrder
    entities?: entitiesOrderByWithRelationInput
    tables?: tablesOrderByWithRelationInput
  }

  export type tables_membersWhereUniqueInput = Prisma.AtLeast<{
    tables_members_id?: string
    table_id_member_id?: tables_membersTable_idMember_idCompoundUniqueInput
    AND?: tables_membersWhereInput | tables_membersWhereInput[]
    OR?: tables_membersWhereInput[]
    NOT?: tables_membersWhereInput | tables_membersWhereInput[]
    table_id?: StringFilter<"tables_members"> | string
    member_id?: StringFilter<"tables_members"> | string
    table_position?: IntFilter<"tables_members"> | number
    live?: IntFilter<"tables_members"> | number
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
    tables?: XOR<TablesRelationFilter, tablesWhereInput>
  }, "tables_members_id" | "tables_members_id" | "table_id_member_id">

  export type tables_membersOrderByWithAggregationInput = {
    tables_members_id?: SortOrder
    table_id?: SortOrder
    member_id?: SortOrder
    table_position?: SortOrder
    live?: SortOrder
    _count?: tables_membersCountOrderByAggregateInput
    _avg?: tables_membersAvgOrderByAggregateInput
    _max?: tables_membersMaxOrderByAggregateInput
    _min?: tables_membersMinOrderByAggregateInput
    _sum?: tables_membersSumOrderByAggregateInput
  }

  export type tables_membersScalarWhereWithAggregatesInput = {
    AND?: tables_membersScalarWhereWithAggregatesInput | tables_membersScalarWhereWithAggregatesInput[]
    OR?: tables_membersScalarWhereWithAggregatesInput[]
    NOT?: tables_membersScalarWhereWithAggregatesInput | tables_membersScalarWhereWithAggregatesInput[]
    tables_members_id?: StringWithAggregatesFilter<"tables_members"> | string
    table_id?: StringWithAggregatesFilter<"tables_members"> | string
    member_id?: StringWithAggregatesFilter<"tables_members"> | string
    table_position?: IntWithAggregatesFilter<"tables_members"> | number
    live?: IntWithAggregatesFilter<"tables_members"> | number
  }

  export type tables_messages_logsWhereInput = {
    AND?: tables_messages_logsWhereInput | tables_messages_logsWhereInput[]
    OR?: tables_messages_logsWhereInput[]
    NOT?: tables_messages_logsWhereInput | tables_messages_logsWhereInput[]
    tables_messages_logs_id?: StringFilter<"tables_messages_logs"> | string
    table_id?: StringFilter<"tables_messages_logs"> | string
    entity_id?: StringFilter<"tables_messages_logs"> | string
    message?: StringFilter<"tables_messages_logs"> | string
    message_date?: DateTimeFilter<"tables_messages_logs"> | Date | string
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
    tables?: XOR<TablesRelationFilter, tablesWhereInput>
  }

  export type tables_messages_logsOrderByWithRelationInput = {
    tables_messages_logs_id?: SortOrder
    table_id?: SortOrder
    entity_id?: SortOrder
    message?: SortOrder
    message_date?: SortOrder
    entities?: entitiesOrderByWithRelationInput
    tables?: tablesOrderByWithRelationInput
  }

  export type tables_messages_logsWhereUniqueInput = Prisma.AtLeast<{
    tables_messages_logs_id?: string
    AND?: tables_messages_logsWhereInput | tables_messages_logsWhereInput[]
    OR?: tables_messages_logsWhereInput[]
    NOT?: tables_messages_logsWhereInput | tables_messages_logsWhereInput[]
    table_id?: StringFilter<"tables_messages_logs"> | string
    entity_id?: StringFilter<"tables_messages_logs"> | string
    message?: StringFilter<"tables_messages_logs"> | string
    message_date?: DateTimeFilter<"tables_messages_logs"> | Date | string
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
    tables?: XOR<TablesRelationFilter, tablesWhereInput>
  }, "tables_messages_logs_id" | "tables_messages_logs_id">

  export type tables_messages_logsOrderByWithAggregationInput = {
    tables_messages_logs_id?: SortOrder
    table_id?: SortOrder
    entity_id?: SortOrder
    message?: SortOrder
    message_date?: SortOrder
    _count?: tables_messages_logsCountOrderByAggregateInput
    _max?: tables_messages_logsMaxOrderByAggregateInput
    _min?: tables_messages_logsMinOrderByAggregateInput
  }

  export type tables_messages_logsScalarWhereWithAggregatesInput = {
    AND?: tables_messages_logsScalarWhereWithAggregatesInput | tables_messages_logsScalarWhereWithAggregatesInput[]
    OR?: tables_messages_logsScalarWhereWithAggregatesInput[]
    NOT?: tables_messages_logsScalarWhereWithAggregatesInput | tables_messages_logsScalarWhereWithAggregatesInput[]
    tables_messages_logs_id?: StringWithAggregatesFilter<"tables_messages_logs"> | string
    table_id?: StringWithAggregatesFilter<"tables_messages_logs"> | string
    entity_id?: StringWithAggregatesFilter<"tables_messages_logs"> | string
    message?: StringWithAggregatesFilter<"tables_messages_logs"> | string
    message_date?: DateTimeWithAggregatesFilter<"tables_messages_logs"> | Date | string
  }

  export type tables_picturesWhereInput = {
    AND?: tables_picturesWhereInput | tables_picturesWhereInput[]
    OR?: tables_picturesWhereInput[]
    NOT?: tables_picturesWhereInput | tables_picturesWhereInput[]
    tables_pictures_id?: StringFilter<"tables_pictures"> | string
    table_picture_data?: BytesFilter<"tables_pictures"> | Buffer
    table_picture_filename?: StringFilter<"tables_pictures"> | string
    tables?: TablesListRelationFilter
  }

  export type tables_picturesOrderByWithRelationInput = {
    tables_pictures_id?: SortOrder
    table_picture_data?: SortOrder
    table_picture_filename?: SortOrder
    tables?: tablesOrderByRelationAggregateInput
  }

  export type tables_picturesWhereUniqueInput = Prisma.AtLeast<{
    tables_pictures_id?: string
    AND?: tables_picturesWhereInput | tables_picturesWhereInput[]
    OR?: tables_picturesWhereInput[]
    NOT?: tables_picturesWhereInput | tables_picturesWhereInput[]
    table_picture_data?: BytesFilter<"tables_pictures"> | Buffer
    table_picture_filename?: StringFilter<"tables_pictures"> | string
    tables?: TablesListRelationFilter
  }, "tables_pictures_id" | "tables_pictures_id">

  export type tables_picturesOrderByWithAggregationInput = {
    tables_pictures_id?: SortOrder
    table_picture_data?: SortOrder
    table_picture_filename?: SortOrder
    _count?: tables_picturesCountOrderByAggregateInput
    _max?: tables_picturesMaxOrderByAggregateInput
    _min?: tables_picturesMinOrderByAggregateInput
  }

  export type tables_picturesScalarWhereWithAggregatesInput = {
    AND?: tables_picturesScalarWhereWithAggregatesInput | tables_picturesScalarWhereWithAggregatesInput[]
    OR?: tables_picturesScalarWhereWithAggregatesInput[]
    NOT?: tables_picturesScalarWhereWithAggregatesInput | tables_picturesScalarWhereWithAggregatesInput[]
    tables_pictures_id?: StringWithAggregatesFilter<"tables_pictures"> | string
    table_picture_data?: BytesWithAggregatesFilter<"tables_pictures"> | Buffer
    table_picture_filename?: StringWithAggregatesFilter<"tables_pictures"> | string
  }

  export type tables_tabletopsWhereInput = {
    AND?: tables_tabletopsWhereInput | tables_tabletopsWhereInput[]
    OR?: tables_tabletopsWhereInput[]
    NOT?: tables_tabletopsWhereInput | tables_tabletopsWhereInput[]
    tables_tabletops_id?: StringFilter<"tables_tabletops"> | string
    table_id?: StringFilter<"tables_tabletops"> | string
    creator_id?: StringFilter<"tables_tabletops"> | string
    tables_tabletops_data_id?: StringNullableFilter<"tables_tabletops"> | string | null
    type?: IntFilter<"tables_tabletops"> | number
    content_date_posted?: DateTimeFilter<"tables_tabletops"> | Date | string
    content_x_position?: IntFilter<"tables_tabletops"> | number
    content_y_position?: IntFilter<"tables_tabletops"> | number
    content_rotation?: IntFilter<"tables_tabletops"> | number
    content_filename?: StringNullableFilter<"tables_tabletops"> | string | null
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
    tables?: XOR<TablesRelationFilter, tablesWhereInput>
    tables_tabletops_data?: XOR<Tables_tabletops_dataNullableRelationFilter, tables_tabletops_dataWhereInput> | null
  }

  export type tables_tabletopsOrderByWithRelationInput = {
    tables_tabletops_id?: SortOrder
    table_id?: SortOrder
    creator_id?: SortOrder
    tables_tabletops_data_id?: SortOrderInput | SortOrder
    type?: SortOrder
    content_date_posted?: SortOrder
    content_x_position?: SortOrder
    content_y_position?: SortOrder
    content_rotation?: SortOrder
    content_filename?: SortOrderInput | SortOrder
    entities?: entitiesOrderByWithRelationInput
    tables?: tablesOrderByWithRelationInput
    tables_tabletops_data?: tables_tabletops_dataOrderByWithRelationInput
  }

  export type tables_tabletopsWhereUniqueInput = Prisma.AtLeast<{
    tables_tabletops_id?: string
    AND?: tables_tabletopsWhereInput | tables_tabletopsWhereInput[]
    OR?: tables_tabletopsWhereInput[]
    NOT?: tables_tabletopsWhereInput | tables_tabletopsWhereInput[]
    table_id?: StringFilter<"tables_tabletops"> | string
    creator_id?: StringFilter<"tables_tabletops"> | string
    tables_tabletops_data_id?: StringNullableFilter<"tables_tabletops"> | string | null
    type?: IntFilter<"tables_tabletops"> | number
    content_date_posted?: DateTimeFilter<"tables_tabletops"> | Date | string
    content_x_position?: IntFilter<"tables_tabletops"> | number
    content_y_position?: IntFilter<"tables_tabletops"> | number
    content_rotation?: IntFilter<"tables_tabletops"> | number
    content_filename?: StringNullableFilter<"tables_tabletops"> | string | null
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
    tables?: XOR<TablesRelationFilter, tablesWhereInput>
    tables_tabletops_data?: XOR<Tables_tabletops_dataNullableRelationFilter, tables_tabletops_dataWhereInput> | null
  }, "tables_tabletops_id" | "tables_tabletops_id">

  export type tables_tabletopsOrderByWithAggregationInput = {
    tables_tabletops_id?: SortOrder
    table_id?: SortOrder
    creator_id?: SortOrder
    tables_tabletops_data_id?: SortOrderInput | SortOrder
    type?: SortOrder
    content_date_posted?: SortOrder
    content_x_position?: SortOrder
    content_y_position?: SortOrder
    content_rotation?: SortOrder
    content_filename?: SortOrderInput | SortOrder
    _count?: tables_tabletopsCountOrderByAggregateInput
    _avg?: tables_tabletopsAvgOrderByAggregateInput
    _max?: tables_tabletopsMaxOrderByAggregateInput
    _min?: tables_tabletopsMinOrderByAggregateInput
    _sum?: tables_tabletopsSumOrderByAggregateInput
  }

  export type tables_tabletopsScalarWhereWithAggregatesInput = {
    AND?: tables_tabletopsScalarWhereWithAggregatesInput | tables_tabletopsScalarWhereWithAggregatesInput[]
    OR?: tables_tabletopsScalarWhereWithAggregatesInput[]
    NOT?: tables_tabletopsScalarWhereWithAggregatesInput | tables_tabletopsScalarWhereWithAggregatesInput[]
    tables_tabletops_id?: StringWithAggregatesFilter<"tables_tabletops"> | string
    table_id?: StringWithAggregatesFilter<"tables_tabletops"> | string
    creator_id?: StringWithAggregatesFilter<"tables_tabletops"> | string
    tables_tabletops_data_id?: StringNullableWithAggregatesFilter<"tables_tabletops"> | string | null
    type?: IntWithAggregatesFilter<"tables_tabletops"> | number
    content_date_posted?: DateTimeWithAggregatesFilter<"tables_tabletops"> | Date | string
    content_x_position?: IntWithAggregatesFilter<"tables_tabletops"> | number
    content_y_position?: IntWithAggregatesFilter<"tables_tabletops"> | number
    content_rotation?: IntWithAggregatesFilter<"tables_tabletops"> | number
    content_filename?: StringNullableWithAggregatesFilter<"tables_tabletops"> | string | null
  }

  export type tables_tabletops_dataWhereInput = {
    AND?: tables_tabletops_dataWhereInput | tables_tabletops_dataWhereInput[]
    OR?: tables_tabletops_dataWhereInput[]
    NOT?: tables_tabletops_dataWhereInput | tables_tabletops_dataWhereInput[]
    tables_tabletops_data_id?: StringFilter<"tables_tabletops_data"> | string
    tables_tabletops_data?: BytesFilter<"tables_tabletops_data"> | Buffer
    tables_tabletops?: Tables_tabletopsListRelationFilter
  }

  export type tables_tabletops_dataOrderByWithRelationInput = {
    tables_tabletops_data_id?: SortOrder
    tables_tabletops_data?: SortOrder
    tables_tabletops?: tables_tabletopsOrderByRelationAggregateInput
  }

  export type tables_tabletops_dataWhereUniqueInput = Prisma.AtLeast<{
    tables_tabletops_data_id?: string
    AND?: tables_tabletops_dataWhereInput | tables_tabletops_dataWhereInput[]
    OR?: tables_tabletops_dataWhereInput[]
    NOT?: tables_tabletops_dataWhereInput | tables_tabletops_dataWhereInput[]
    tables_tabletops_data?: BytesFilter<"tables_tabletops_data"> | Buffer
    tables_tabletops?: Tables_tabletopsListRelationFilter
  }, "tables_tabletops_data_id" | "tables_tabletops_data_id">

  export type tables_tabletops_dataOrderByWithAggregationInput = {
    tables_tabletops_data_id?: SortOrder
    tables_tabletops_data?: SortOrder
    _count?: tables_tabletops_dataCountOrderByAggregateInput
    _max?: tables_tabletops_dataMaxOrderByAggregateInput
    _min?: tables_tabletops_dataMinOrderByAggregateInput
  }

  export type tables_tabletops_dataScalarWhereWithAggregatesInput = {
    AND?: tables_tabletops_dataScalarWhereWithAggregatesInput | tables_tabletops_dataScalarWhereWithAggregatesInput[]
    OR?: tables_tabletops_dataScalarWhereWithAggregatesInput[]
    NOT?: tables_tabletops_dataScalarWhereWithAggregatesInput | tables_tabletops_dataScalarWhereWithAggregatesInput[]
    tables_tabletops_data_id?: StringWithAggregatesFilter<"tables_tabletops_data"> | string
    tables_tabletops_data?: BytesWithAggregatesFilter<"tables_tabletops_data"> | Buffer
  }

  export type user_credentialsWhereInput = {
    AND?: user_credentialsWhereInput | user_credentialsWhereInput[]
    OR?: user_credentialsWhereInput[]
    NOT?: user_credentialsWhereInput | user_credentialsWhereInput[]
    user_id?: StringFilter<"user_credentials"> | string
    username?: StringFilter<"user_credentials"> | string
    user_password?: StringFilter<"user_credentials"> | string
    user_first_name?: StringNullableFilter<"user_credentials"> | string | null
    user_last_name?: StringNullableFilter<"user_credentials"> | string | null
    user_email?: StringNullableFilter<"user_credentials"> | string | null
    user_phone_number?: StringNullableFilter<"user_credentials"> | string | null
    individuals?: XOR<IndividualsNullableRelationFilter, individualsWhereInput> | null
  }

  export type user_credentialsOrderByWithRelationInput = {
    user_id?: SortOrder
    username?: SortOrder
    user_password?: SortOrder
    user_first_name?: SortOrderInput | SortOrder
    user_last_name?: SortOrderInput | SortOrder
    user_email?: SortOrderInput | SortOrder
    user_phone_number?: SortOrderInput | SortOrder
    individuals?: individualsOrderByWithRelationInput
  }

  export type user_credentialsWhereUniqueInput = Prisma.AtLeast<{
    user_id?: string
    username?: string
    AND?: user_credentialsWhereInput | user_credentialsWhereInput[]
    OR?: user_credentialsWhereInput[]
    NOT?: user_credentialsWhereInput | user_credentialsWhereInput[]
    user_password?: StringFilter<"user_credentials"> | string
    user_first_name?: StringNullableFilter<"user_credentials"> | string | null
    user_last_name?: StringNullableFilter<"user_credentials"> | string | null
    user_email?: StringNullableFilter<"user_credentials"> | string | null
    user_phone_number?: StringNullableFilter<"user_credentials"> | string | null
    individuals?: XOR<IndividualsNullableRelationFilter, individualsWhereInput> | null
  }, "user_id" | "user_id" | "username">

  export type user_credentialsOrderByWithAggregationInput = {
    user_id?: SortOrder
    username?: SortOrder
    user_password?: SortOrder
    user_first_name?: SortOrderInput | SortOrder
    user_last_name?: SortOrderInput | SortOrder
    user_email?: SortOrderInput | SortOrder
    user_phone_number?: SortOrderInput | SortOrder
    _count?: user_credentialsCountOrderByAggregateInput
    _max?: user_credentialsMaxOrderByAggregateInput
    _min?: user_credentialsMinOrderByAggregateInput
  }

  export type user_credentialsScalarWhereWithAggregatesInput = {
    AND?: user_credentialsScalarWhereWithAggregatesInput | user_credentialsScalarWhereWithAggregatesInput[]
    OR?: user_credentialsScalarWhereWithAggregatesInput[]
    NOT?: user_credentialsScalarWhereWithAggregatesInput | user_credentialsScalarWhereWithAggregatesInput[]
    user_id?: StringWithAggregatesFilter<"user_credentials"> | string
    username?: StringWithAggregatesFilter<"user_credentials"> | string
    user_password?: StringWithAggregatesFilter<"user_credentials"> | string
    user_first_name?: StringNullableWithAggregatesFilter<"user_credentials"> | string | null
    user_last_name?: StringNullableWithAggregatesFilter<"user_credentials"> | string | null
    user_email?: StringNullableWithAggregatesFilter<"user_credentials"> | string | null
    user_phone_number?: StringNullableWithAggregatesFilter<"user_credentials"> | string | null
  }

  export type videosWhereInput = {
    AND?: videosWhereInput | videosWhereInput[]
    OR?: videosWhereInput[]
    NOT?: videosWhereInput | videosWhereInput[]
    video_id?: StringFilter<"videos"> | string
    video_creator_id?: StringFilter<"videos"> | string
    video_title?: StringFilter<"videos"> | string
    video_description?: StringFilter<"videos"> | string
    video_filename?: StringFilter<"videos"> | string
    video_data_id?: StringFilter<"videos"> | string
    video_thumbnail_id?: StringNullableFilter<"videos"> | string | null
    video_likes?: IntFilter<"videos"> | number
    video_dislikes?: IntFilter<"videos"> | number
    video_views?: IntFilter<"videos"> | number
    video_date_posted?: DateTimeNullableFilter<"videos"> | Date | string | null
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
    videos_data?: XOR<Videos_dataRelationFilter, videos_dataWhereInput>
    videos_thumbnails?: XOR<Videos_thumbnailsNullableRelationFilter, videos_thumbnailsWhereInput> | null
  }

  export type videosOrderByWithRelationInput = {
    video_id?: SortOrder
    video_creator_id?: SortOrder
    video_title?: SortOrder
    video_description?: SortOrder
    video_filename?: SortOrder
    video_data_id?: SortOrder
    video_thumbnail_id?: SortOrderInput | SortOrder
    video_likes?: SortOrder
    video_dislikes?: SortOrder
    video_views?: SortOrder
    video_date_posted?: SortOrderInput | SortOrder
    entities?: entitiesOrderByWithRelationInput
    videos_data?: videos_dataOrderByWithRelationInput
    videos_thumbnails?: videos_thumbnailsOrderByWithRelationInput
  }

  export type videosWhereUniqueInput = Prisma.AtLeast<{
    video_id?: string
    AND?: videosWhereInput | videosWhereInput[]
    OR?: videosWhereInput[]
    NOT?: videosWhereInput | videosWhereInput[]
    video_creator_id?: StringFilter<"videos"> | string
    video_title?: StringFilter<"videos"> | string
    video_description?: StringFilter<"videos"> | string
    video_filename?: StringFilter<"videos"> | string
    video_data_id?: StringFilter<"videos"> | string
    video_thumbnail_id?: StringNullableFilter<"videos"> | string | null
    video_likes?: IntFilter<"videos"> | number
    video_dislikes?: IntFilter<"videos"> | number
    video_views?: IntFilter<"videos"> | number
    video_date_posted?: DateTimeNullableFilter<"videos"> | Date | string | null
    entities?: XOR<EntitiesRelationFilter, entitiesWhereInput>
    videos_data?: XOR<Videos_dataRelationFilter, videos_dataWhereInput>
    videos_thumbnails?: XOR<Videos_thumbnailsNullableRelationFilter, videos_thumbnailsWhereInput> | null
  }, "video_id" | "video_id">

  export type videosOrderByWithAggregationInput = {
    video_id?: SortOrder
    video_creator_id?: SortOrder
    video_title?: SortOrder
    video_description?: SortOrder
    video_filename?: SortOrder
    video_data_id?: SortOrder
    video_thumbnail_id?: SortOrderInput | SortOrder
    video_likes?: SortOrder
    video_dislikes?: SortOrder
    video_views?: SortOrder
    video_date_posted?: SortOrderInput | SortOrder
    _count?: videosCountOrderByAggregateInput
    _avg?: videosAvgOrderByAggregateInput
    _max?: videosMaxOrderByAggregateInput
    _min?: videosMinOrderByAggregateInput
    _sum?: videosSumOrderByAggregateInput
  }

  export type videosScalarWhereWithAggregatesInput = {
    AND?: videosScalarWhereWithAggregatesInput | videosScalarWhereWithAggregatesInput[]
    OR?: videosScalarWhereWithAggregatesInput[]
    NOT?: videosScalarWhereWithAggregatesInput | videosScalarWhereWithAggregatesInput[]
    video_id?: StringWithAggregatesFilter<"videos"> | string
    video_creator_id?: StringWithAggregatesFilter<"videos"> | string
    video_title?: StringWithAggregatesFilter<"videos"> | string
    video_description?: StringWithAggregatesFilter<"videos"> | string
    video_filename?: StringWithAggregatesFilter<"videos"> | string
    video_data_id?: StringWithAggregatesFilter<"videos"> | string
    video_thumbnail_id?: StringNullableWithAggregatesFilter<"videos"> | string | null
    video_likes?: IntWithAggregatesFilter<"videos"> | number
    video_dislikes?: IntWithAggregatesFilter<"videos"> | number
    video_views?: IntWithAggregatesFilter<"videos"> | number
    video_date_posted?: DateTimeNullableWithAggregatesFilter<"videos"> | Date | string | null
  }

  export type videos_dataWhereInput = {
    AND?: videos_dataWhereInput | videos_dataWhereInput[]
    OR?: videos_dataWhereInput[]
    NOT?: videos_dataWhereInput | videos_dataWhereInput[]
    video_data_id?: StringFilter<"videos_data"> | string
    video_data?: BytesFilter<"videos_data"> | Buffer
    videos?: VideosListRelationFilter
  }

  export type videos_dataOrderByWithRelationInput = {
    video_data_id?: SortOrder
    video_data?: SortOrder
    videos?: videosOrderByRelationAggregateInput
  }

  export type videos_dataWhereUniqueInput = Prisma.AtLeast<{
    video_data_id?: string
    AND?: videos_dataWhereInput | videos_dataWhereInput[]
    OR?: videos_dataWhereInput[]
    NOT?: videos_dataWhereInput | videos_dataWhereInput[]
    video_data?: BytesFilter<"videos_data"> | Buffer
    videos?: VideosListRelationFilter
  }, "video_data_id" | "video_data_id">

  export type videos_dataOrderByWithAggregationInput = {
    video_data_id?: SortOrder
    video_data?: SortOrder
    _count?: videos_dataCountOrderByAggregateInput
    _max?: videos_dataMaxOrderByAggregateInput
    _min?: videos_dataMinOrderByAggregateInput
  }

  export type videos_dataScalarWhereWithAggregatesInput = {
    AND?: videos_dataScalarWhereWithAggregatesInput | videos_dataScalarWhereWithAggregatesInput[]
    OR?: videos_dataScalarWhereWithAggregatesInput[]
    NOT?: videos_dataScalarWhereWithAggregatesInput | videos_dataScalarWhereWithAggregatesInput[]
    video_data_id?: StringWithAggregatesFilter<"videos_data"> | string
    video_data?: BytesWithAggregatesFilter<"videos_data"> | Buffer
  }

  export type videos_thumbnailsWhereInput = {
    AND?: videos_thumbnailsWhereInput | videos_thumbnailsWhereInput[]
    OR?: videos_thumbnailsWhereInput[]
    NOT?: videos_thumbnailsWhereInput | videos_thumbnailsWhereInput[]
    video_thumbnail_id?: StringFilter<"videos_thumbnails"> | string
    video_thumbnail_data?: BytesFilter<"videos_thumbnails"> | Buffer
    video_thumbnail_filename?: StringFilter<"videos_thumbnails"> | string
    video_thumbnail_description?: StringNullableFilter<"videos_thumbnails"> | string | null
    videos?: VideosListRelationFilter
  }

  export type videos_thumbnailsOrderByWithRelationInput = {
    video_thumbnail_id?: SortOrder
    video_thumbnail_data?: SortOrder
    video_thumbnail_filename?: SortOrder
    video_thumbnail_description?: SortOrderInput | SortOrder
    videos?: videosOrderByRelationAggregateInput
  }

  export type videos_thumbnailsWhereUniqueInput = Prisma.AtLeast<{
    video_thumbnail_id?: string
    AND?: videos_thumbnailsWhereInput | videos_thumbnailsWhereInput[]
    OR?: videos_thumbnailsWhereInput[]
    NOT?: videos_thumbnailsWhereInput | videos_thumbnailsWhereInput[]
    video_thumbnail_data?: BytesFilter<"videos_thumbnails"> | Buffer
    video_thumbnail_filename?: StringFilter<"videos_thumbnails"> | string
    video_thumbnail_description?: StringNullableFilter<"videos_thumbnails"> | string | null
    videos?: VideosListRelationFilter
  }, "video_thumbnail_id" | "video_thumbnail_id">

  export type videos_thumbnailsOrderByWithAggregationInput = {
    video_thumbnail_id?: SortOrder
    video_thumbnail_data?: SortOrder
    video_thumbnail_filename?: SortOrder
    video_thumbnail_description?: SortOrderInput | SortOrder
    _count?: videos_thumbnailsCountOrderByAggregateInput
    _max?: videos_thumbnailsMaxOrderByAggregateInput
    _min?: videos_thumbnailsMinOrderByAggregateInput
  }

  export type videos_thumbnailsScalarWhereWithAggregatesInput = {
    AND?: videos_thumbnailsScalarWhereWithAggregatesInput | videos_thumbnailsScalarWhereWithAggregatesInput[]
    OR?: videos_thumbnailsScalarWhereWithAggregatesInput[]
    NOT?: videos_thumbnailsScalarWhereWithAggregatesInput | videos_thumbnailsScalarWhereWithAggregatesInput[]
    video_thumbnail_id?: StringWithAggregatesFilter<"videos_thumbnails"> | string
    video_thumbnail_data?: BytesWithAggregatesFilter<"videos_thumbnails"> | Buffer
    video_thumbnail_filename?: StringWithAggregatesFilter<"videos_thumbnails"> | string
    video_thumbnail_description?: StringNullableWithAggregatesFilter<"videos_thumbnails"> | string | null
  }

  export type affiliates_relationsCreateInput = {
    affiliate_relation_id: string
    affiliate_id_root: string
    affiliate_id_target: string
    affiliate_relation_date?: Date | string
  }

  export type affiliates_relationsUncheckedCreateInput = {
    affiliate_relation_id: string
    affiliate_id_root: string
    affiliate_id_target: string
    affiliate_relation_date?: Date | string
  }

  export type affiliates_relationsUpdateInput = {
    affiliate_relation_id?: StringFieldUpdateOperationsInput | string
    affiliate_id_root?: StringFieldUpdateOperationsInput | string
    affiliate_id_target?: StringFieldUpdateOperationsInput | string
    affiliate_relation_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type affiliates_relationsUncheckedUpdateInput = {
    affiliate_relation_id?: StringFieldUpdateOperationsInput | string
    affiliate_id_root?: StringFieldUpdateOperationsInput | string
    affiliate_id_target?: StringFieldUpdateOperationsInput | string
    affiliate_relation_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type affiliates_relationsCreateManyInput = {
    affiliate_relation_id: string
    affiliate_id_root: string
    affiliate_id_target: string
    affiliate_relation_date?: Date | string
  }

  export type affiliates_relationsUpdateManyMutationInput = {
    affiliate_relation_id?: StringFieldUpdateOperationsInput | string
    affiliate_id_root?: StringFieldUpdateOperationsInput | string
    affiliate_id_target?: StringFieldUpdateOperationsInput | string
    affiliate_relation_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type affiliates_relationsUncheckedUpdateManyInput = {
    affiliate_relation_id?: StringFieldUpdateOperationsInput | string
    affiliate_id_root?: StringFieldUpdateOperationsInput | string
    affiliate_id_target?: StringFieldUpdateOperationsInput | string
    affiliate_relation_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type collectionsCreateInput = {
    collection_id: string
    collection_name: string
    entities: entitiesCreateNestedOneWithoutCollectionsInput
    collections_content?: collections_contentCreateNestedManyWithoutCollectionsInput
  }

  export type collectionsUncheckedCreateInput = {
    collection_id: string
    collection_name: string
    entity_id: string
    collections_content?: collections_contentUncheckedCreateNestedManyWithoutCollectionsInput
  }

  export type collectionsUpdateInput = {
    collection_id?: StringFieldUpdateOperationsInput | string
    collection_name?: StringFieldUpdateOperationsInput | string
    entities?: entitiesUpdateOneRequiredWithoutCollectionsNestedInput
    collections_content?: collections_contentUpdateManyWithoutCollectionsNestedInput
  }

  export type collectionsUncheckedUpdateInput = {
    collection_id?: StringFieldUpdateOperationsInput | string
    collection_name?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    collections_content?: collections_contentUncheckedUpdateManyWithoutCollectionsNestedInput
  }

  export type collectionsCreateManyInput = {
    collection_id: string
    collection_name: string
    entity_id: string
  }

  export type collectionsUpdateManyMutationInput = {
    collection_id?: StringFieldUpdateOperationsInput | string
    collection_name?: StringFieldUpdateOperationsInput | string
  }

  export type collectionsUncheckedUpdateManyInput = {
    collection_id?: StringFieldUpdateOperationsInput | string
    collection_name?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
  }

  export type collections_contentCreateInput = {
    collections_content_id: string
    date_added: Date | string
    pinned: boolean
    date_pinned?: Date | string | null
    collections: collectionsCreateNestedOneWithoutCollections_contentInput
    content: contentCreateNestedOneWithoutCollections_contentInput
  }

  export type collections_contentUncheckedCreateInput = {
    collections_content_id: string
    collection_id: string
    content_id: string
    date_added: Date | string
    pinned: boolean
    date_pinned?: Date | string | null
  }

  export type collections_contentUpdateInput = {
    collections_content_id?: StringFieldUpdateOperationsInput | string
    date_added?: DateTimeFieldUpdateOperationsInput | Date | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    date_pinned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collections?: collectionsUpdateOneRequiredWithoutCollections_contentNestedInput
    content?: contentUpdateOneRequiredWithoutCollections_contentNestedInput
  }

  export type collections_contentUncheckedUpdateInput = {
    collections_content_id?: StringFieldUpdateOperationsInput | string
    collection_id?: StringFieldUpdateOperationsInput | string
    content_id?: StringFieldUpdateOperationsInput | string
    date_added?: DateTimeFieldUpdateOperationsInput | Date | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    date_pinned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type collections_contentCreateManyInput = {
    collections_content_id: string
    collection_id: string
    content_id: string
    date_added: Date | string
    pinned: boolean
    date_pinned?: Date | string | null
  }

  export type collections_contentUpdateManyMutationInput = {
    collections_content_id?: StringFieldUpdateOperationsInput | string
    date_added?: DateTimeFieldUpdateOperationsInput | Date | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    date_pinned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type collections_contentUncheckedUpdateManyInput = {
    collections_content_id?: StringFieldUpdateOperationsInput | string
    collection_id?: StringFieldUpdateOperationsInput | string
    content_id?: StringFieldUpdateOperationsInput | string
    date_added?: DateTimeFieldUpdateOperationsInput | Date | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    date_pinned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contactsCreateInput = {
    contact_id: string
    conversation_id: string
    contact_creation_date: Date | string
    last_message?: string | null
    last_contact_date?: Date | string | null
    entities_contacts_contact_id_rootToentities: entitiesCreateNestedOneWithoutContacts_contacts_contact_id_rootToentitiesInput
    entities_contacts_contact_id_targetToentities: entitiesCreateNestedOneWithoutContacts_contacts_contact_id_targetToentitiesInput
    contacts_pictures?: contacts_picturesCreateNestedOneWithoutContactsInput
  }

  export type contactsUncheckedCreateInput = {
    contact_id: string
    conversation_id: string
    contact_id_root: string
    contact_id_target: string
    contact_creation_date: Date | string
    last_message?: string | null
    last_contact_date?: Date | string | null
    contacts_pictures_id?: string | null
  }

  export type contactsUpdateInput = {
    contact_id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
    contact_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_contact_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entities_contacts_contact_id_rootToentities?: entitiesUpdateOneRequiredWithoutContacts_contacts_contact_id_rootToentitiesNestedInput
    entities_contacts_contact_id_targetToentities?: entitiesUpdateOneRequiredWithoutContacts_contacts_contact_id_targetToentitiesNestedInput
    contacts_pictures?: contacts_picturesUpdateOneWithoutContactsNestedInput
  }

  export type contactsUncheckedUpdateInput = {
    contact_id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
    contact_id_root?: StringFieldUpdateOperationsInput | string
    contact_id_target?: StringFieldUpdateOperationsInput | string
    contact_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_contact_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contacts_pictures_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contactsCreateManyInput = {
    contact_id: string
    conversation_id: string
    contact_id_root: string
    contact_id_target: string
    contact_creation_date: Date | string
    last_message?: string | null
    last_contact_date?: Date | string | null
    contacts_pictures_id?: string | null
  }

  export type contactsUpdateManyMutationInput = {
    contact_id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
    contact_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_contact_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contactsUncheckedUpdateManyInput = {
    contact_id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
    contact_id_root?: StringFieldUpdateOperationsInput | string
    contact_id_target?: StringFieldUpdateOperationsInput | string
    contact_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_contact_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contacts_pictures_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contacts_picturesCreateInput = {
    contacts_pictures_id: string
    contact_picture_data: Buffer
    contact_picture_filename: string
    contacts?: contactsCreateNestedManyWithoutContacts_picturesInput
  }

  export type contacts_picturesUncheckedCreateInput = {
    contacts_pictures_id: string
    contact_picture_data: Buffer
    contact_picture_filename: string
    contacts?: contactsUncheckedCreateNestedManyWithoutContacts_picturesInput
  }

  export type contacts_picturesUpdateInput = {
    contacts_pictures_id?: StringFieldUpdateOperationsInput | string
    contact_picture_data?: BytesFieldUpdateOperationsInput | Buffer
    contact_picture_filename?: StringFieldUpdateOperationsInput | string
    contacts?: contactsUpdateManyWithoutContacts_picturesNestedInput
  }

  export type contacts_picturesUncheckedUpdateInput = {
    contacts_pictures_id?: StringFieldUpdateOperationsInput | string
    contact_picture_data?: BytesFieldUpdateOperationsInput | Buffer
    contact_picture_filename?: StringFieldUpdateOperationsInput | string
    contacts?: contactsUncheckedUpdateManyWithoutContacts_picturesNestedInput
  }

  export type contacts_picturesCreateManyInput = {
    contacts_pictures_id: string
    contact_picture_data: Buffer
    contact_picture_filename: string
  }

  export type contacts_picturesUpdateManyMutationInput = {
    contacts_pictures_id?: StringFieldUpdateOperationsInput | string
    contact_picture_data?: BytesFieldUpdateOperationsInput | Buffer
    contact_picture_filename?: StringFieldUpdateOperationsInput | string
  }

  export type contacts_picturesUncheckedUpdateManyInput = {
    contacts_pictures_id?: StringFieldUpdateOperationsInput | string
    contact_picture_data?: BytesFieldUpdateOperationsInput | Buffer
    contact_picture_filename?: StringFieldUpdateOperationsInput | string
  }

  export type contentCreateInput = {
    content_id: string
    content_type?: number | null
    collections_content?: collections_contentCreateNestedManyWithoutContentInput
    entities_content?: entities_contentCreateNestedManyWithoutContentInput
    entities_dislikes?: entities_dislikesCreateNestedManyWithoutContentInput
    entities_likes?: entities_likesCreateNestedManyWithoutContentInput
  }

  export type contentUncheckedCreateInput = {
    content_id: string
    content_type?: number | null
    collections_content?: collections_contentUncheckedCreateNestedManyWithoutContentInput
    entities_content?: entities_contentUncheckedCreateNestedManyWithoutContentInput
    entities_dislikes?: entities_dislikesUncheckedCreateNestedManyWithoutContentInput
    entities_likes?: entities_likesUncheckedCreateNestedManyWithoutContentInput
  }

  export type contentUpdateInput = {
    content_id?: StringFieldUpdateOperationsInput | string
    content_type?: NullableIntFieldUpdateOperationsInput | number | null
    collections_content?: collections_contentUpdateManyWithoutContentNestedInput
    entities_content?: entities_contentUpdateManyWithoutContentNestedInput
    entities_dislikes?: entities_dislikesUpdateManyWithoutContentNestedInput
    entities_likes?: entities_likesUpdateManyWithoutContentNestedInput
  }

  export type contentUncheckedUpdateInput = {
    content_id?: StringFieldUpdateOperationsInput | string
    content_type?: NullableIntFieldUpdateOperationsInput | number | null
    collections_content?: collections_contentUncheckedUpdateManyWithoutContentNestedInput
    entities_content?: entities_contentUncheckedUpdateManyWithoutContentNestedInput
    entities_dislikes?: entities_dislikesUncheckedUpdateManyWithoutContentNestedInput
    entities_likes?: entities_likesUncheckedUpdateManyWithoutContentNestedInput
  }

  export type contentCreateManyInput = {
    content_id: string
    content_type?: number | null
  }

  export type contentUpdateManyMutationInput = {
    content_id?: StringFieldUpdateOperationsInput | string
    content_type?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type contentUncheckedUpdateManyInput = {
    content_id?: StringFieldUpdateOperationsInput | string
    content_type?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type conversationsCreateInput = {
    conversation_id: string
    conversation_name?: string | null
    conversation_creation_date: Date | string
    last_message?: string | null
    last_message_date?: Date | string | null
    conversations_pictures?: conversations_picturesCreateNestedOneWithoutConversationsInput
    conversations_members?: conversations_membersCreateNestedManyWithoutConversationsInput
    conversations_messages_logs?: conversations_messages_logsCreateNestedManyWithoutConversationsInput
  }

  export type conversationsUncheckedCreateInput = {
    conversation_id: string
    conversation_name?: string | null
    conversation_creation_date: Date | string
    last_message?: string | null
    last_message_date?: Date | string | null
    conversations_pictures_id?: string | null
    conversations_members?: conversations_membersUncheckedCreateNestedManyWithoutConversationsInput
    conversations_messages_logs?: conversations_messages_logsUncheckedCreateNestedManyWithoutConversationsInput
  }

  export type conversationsUpdateInput = {
    conversation_id?: StringFieldUpdateOperationsInput | string
    conversation_name?: NullableStringFieldUpdateOperationsInput | string | null
    conversation_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations_pictures?: conversations_picturesUpdateOneWithoutConversationsNestedInput
    conversations_members?: conversations_membersUpdateManyWithoutConversationsNestedInput
    conversations_messages_logs?: conversations_messages_logsUpdateManyWithoutConversationsNestedInput
  }

  export type conversationsUncheckedUpdateInput = {
    conversation_id?: StringFieldUpdateOperationsInput | string
    conversation_name?: NullableStringFieldUpdateOperationsInput | string | null
    conversation_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations_pictures_id?: NullableStringFieldUpdateOperationsInput | string | null
    conversations_members?: conversations_membersUncheckedUpdateManyWithoutConversationsNestedInput
    conversations_messages_logs?: conversations_messages_logsUncheckedUpdateManyWithoutConversationsNestedInput
  }

  export type conversationsCreateManyInput = {
    conversation_id: string
    conversation_name?: string | null
    conversation_creation_date: Date | string
    last_message?: string | null
    last_message_date?: Date | string | null
    conversations_pictures_id?: string | null
  }

  export type conversationsUpdateManyMutationInput = {
    conversation_id?: StringFieldUpdateOperationsInput | string
    conversation_name?: NullableStringFieldUpdateOperationsInput | string | null
    conversation_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conversationsUncheckedUpdateManyInput = {
    conversation_id?: StringFieldUpdateOperationsInput | string
    conversation_name?: NullableStringFieldUpdateOperationsInput | string | null
    conversation_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations_pictures_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type conversations_membersCreateInput = {
    conversations_members_id: string
    conversations: conversationsCreateNestedOneWithoutConversations_membersInput
    entities: entitiesCreateNestedOneWithoutConversations_membersInput
  }

  export type conversations_membersUncheckedCreateInput = {
    conversations_members_id: string
    conversation_id: string
    member_id: string
  }

  export type conversations_membersUpdateInput = {
    conversations_members_id?: StringFieldUpdateOperationsInput | string
    conversations?: conversationsUpdateOneRequiredWithoutConversations_membersNestedInput
    entities?: entitiesUpdateOneRequiredWithoutConversations_membersNestedInput
  }

  export type conversations_membersUncheckedUpdateInput = {
    conversations_members_id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
    member_id?: StringFieldUpdateOperationsInput | string
  }

  export type conversations_membersCreateManyInput = {
    conversations_members_id: string
    conversation_id: string
    member_id: string
  }

  export type conversations_membersUpdateManyMutationInput = {
    conversations_members_id?: StringFieldUpdateOperationsInput | string
  }

  export type conversations_membersUncheckedUpdateManyInput = {
    conversations_members_id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
    member_id?: StringFieldUpdateOperationsInput | string
  }

  export type conversations_messages_logsCreateInput = {
    conversations_messages_logs_id: string
    message: string
    message_date: Date | string
    conversations: conversationsCreateNestedOneWithoutConversations_messages_logsInput
    entities: entitiesCreateNestedOneWithoutConversations_messages_logsInput
  }

  export type conversations_messages_logsUncheckedCreateInput = {
    conversations_messages_logs_id: string
    conversation_id: string
    entity_id: string
    message: string
    message_date: Date | string
  }

  export type conversations_messages_logsUpdateInput = {
    conversations_messages_logs_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    message_date?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: conversationsUpdateOneRequiredWithoutConversations_messages_logsNestedInput
    entities?: entitiesUpdateOneRequiredWithoutConversations_messages_logsNestedInput
  }

  export type conversations_messages_logsUncheckedUpdateInput = {
    conversations_messages_logs_id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    message_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type conversations_messages_logsCreateManyInput = {
    conversations_messages_logs_id: string
    conversation_id: string
    entity_id: string
    message: string
    message_date: Date | string
  }

  export type conversations_messages_logsUpdateManyMutationInput = {
    conversations_messages_logs_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    message_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type conversations_messages_logsUncheckedUpdateManyInput = {
    conversations_messages_logs_id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    message_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type conversations_picturesCreateInput = {
    conversations_pictures_id: string
    conversation_picture_data: Buffer
    conversation_picture_filename: string
    conversations?: conversationsCreateNestedManyWithoutConversations_picturesInput
  }

  export type conversations_picturesUncheckedCreateInput = {
    conversations_pictures_id: string
    conversation_picture_data: Buffer
    conversation_picture_filename: string
    conversations?: conversationsUncheckedCreateNestedManyWithoutConversations_picturesInput
  }

  export type conversations_picturesUpdateInput = {
    conversations_pictures_id?: StringFieldUpdateOperationsInput | string
    conversation_picture_data?: BytesFieldUpdateOperationsInput | Buffer
    conversation_picture_filename?: StringFieldUpdateOperationsInput | string
    conversations?: conversationsUpdateManyWithoutConversations_picturesNestedInput
  }

  export type conversations_picturesUncheckedUpdateInput = {
    conversations_pictures_id?: StringFieldUpdateOperationsInput | string
    conversation_picture_data?: BytesFieldUpdateOperationsInput | Buffer
    conversation_picture_filename?: StringFieldUpdateOperationsInput | string
    conversations?: conversationsUncheckedUpdateManyWithoutConversations_picturesNestedInput
  }

  export type conversations_picturesCreateManyInput = {
    conversations_pictures_id: string
    conversation_picture_data: Buffer
    conversation_picture_filename: string
  }

  export type conversations_picturesUpdateManyMutationInput = {
    conversations_pictures_id?: StringFieldUpdateOperationsInput | string
    conversation_picture_data?: BytesFieldUpdateOperationsInput | Buffer
    conversation_picture_filename?: StringFieldUpdateOperationsInput | string
  }

  export type conversations_picturesUncheckedUpdateManyInput = {
    conversations_pictures_id?: StringFieldUpdateOperationsInput | string
    conversation_picture_data?: BytesFieldUpdateOperationsInput | Buffer
    conversation_picture_filename?: StringFieldUpdateOperationsInput | string
  }

  export type entitiesCreateInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersCreateNestedManyWithoutEntitiesInput
    images?: imagesCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsCreateNestedManyWithoutEntitiesInput
    videos?: videosCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesUncheckedCreateInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsUncheckedCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentUncheckedCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesUncheckedCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersUncheckedCreateNestedManyWithoutEntitiesInput
    images?: imagesUncheckedCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersUncheckedCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsUncheckedCreateNestedManyWithoutEntitiesInput
    videos?: videosUncheckedCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesUpdateInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUpdateManyWithoutEntitiesNestedInput
    images?: imagesUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUpdateManyWithoutEntitiesNestedInput
    videos?: videosUpdateManyWithoutEntitiesNestedInput
  }

  export type entitiesUncheckedUpdateInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUncheckedUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUncheckedUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    images?: imagesUncheckedUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUncheckedUpdateManyWithoutEntitiesNestedInput
    videos?: videosUncheckedUpdateManyWithoutEntitiesNestedInput
  }

  export type entitiesCreateManyInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
  }

  export type entitiesUpdateManyMutationInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
  }

  export type entitiesUncheckedUpdateManyInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
  }

  export type entities_contentCreateInput = {
    entities_content_id: string
    date_added: Date | string
    pinned: boolean
    date_pinned?: Date | string | null
    content: contentCreateNestedOneWithoutEntities_contentInput
    entities: entitiesCreateNestedOneWithoutEntities_contentInput
  }

  export type entities_contentUncheckedCreateInput = {
    entities_content_id: string
    entity_id: string
    content_id: string
    date_added: Date | string
    pinned: boolean
    date_pinned?: Date | string | null
  }

  export type entities_contentUpdateInput = {
    entities_content_id?: StringFieldUpdateOperationsInput | string
    date_added?: DateTimeFieldUpdateOperationsInput | Date | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    date_pinned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: contentUpdateOneRequiredWithoutEntities_contentNestedInput
    entities?: entitiesUpdateOneRequiredWithoutEntities_contentNestedInput
  }

  export type entities_contentUncheckedUpdateInput = {
    entities_content_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    content_id?: StringFieldUpdateOperationsInput | string
    date_added?: DateTimeFieldUpdateOperationsInput | Date | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    date_pinned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type entities_contentCreateManyInput = {
    entities_content_id: string
    entity_id: string
    content_id: string
    date_added: Date | string
    pinned: boolean
    date_pinned?: Date | string | null
  }

  export type entities_contentUpdateManyMutationInput = {
    entities_content_id?: StringFieldUpdateOperationsInput | string
    date_added?: DateTimeFieldUpdateOperationsInput | Date | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    date_pinned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type entities_contentUncheckedUpdateManyInput = {
    entities_content_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    content_id?: StringFieldUpdateOperationsInput | string
    date_added?: DateTimeFieldUpdateOperationsInput | Date | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    date_pinned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type entities_dislikesCreateInput = {
    dislike_id: string
    content: contentCreateNestedOneWithoutEntities_dislikesInput
    entities: entitiesCreateNestedOneWithoutEntities_dislikesInput
  }

  export type entities_dislikesUncheckedCreateInput = {
    dislike_id: string
    entity_id: string
    content_id: string
  }

  export type entities_dislikesUpdateInput = {
    dislike_id?: StringFieldUpdateOperationsInput | string
    content?: contentUpdateOneRequiredWithoutEntities_dislikesNestedInput
    entities?: entitiesUpdateOneRequiredWithoutEntities_dislikesNestedInput
  }

  export type entities_dislikesUncheckedUpdateInput = {
    dislike_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    content_id?: StringFieldUpdateOperationsInput | string
  }

  export type entities_dislikesCreateManyInput = {
    dislike_id: string
    entity_id: string
    content_id: string
  }

  export type entities_dislikesUpdateManyMutationInput = {
    dislike_id?: StringFieldUpdateOperationsInput | string
  }

  export type entities_dislikesUncheckedUpdateManyInput = {
    dislike_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    content_id?: StringFieldUpdateOperationsInput | string
  }

  export type entities_likesCreateInput = {
    like_id: string
    content: contentCreateNestedOneWithoutEntities_likesInput
    entities: entitiesCreateNestedOneWithoutEntities_likesInput
  }

  export type entities_likesUncheckedCreateInput = {
    like_id: string
    entity_id: string
    content_id: string
  }

  export type entities_likesUpdateInput = {
    like_id?: StringFieldUpdateOperationsInput | string
    content?: contentUpdateOneRequiredWithoutEntities_likesNestedInput
    entities?: entitiesUpdateOneRequiredWithoutEntities_likesNestedInput
  }

  export type entities_likesUncheckedUpdateInput = {
    like_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    content_id?: StringFieldUpdateOperationsInput | string
  }

  export type entities_likesCreateManyInput = {
    like_id: string
    entity_id: string
    content_id: string
  }

  export type entities_likesUpdateManyMutationInput = {
    like_id?: StringFieldUpdateOperationsInput | string
  }

  export type entities_likesUncheckedUpdateManyInput = {
    like_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    content_id?: StringFieldUpdateOperationsInput | string
  }

  export type entities_referencesCreateInput = {
    reference_id: string
    title: string
    author: string
    url: string
    entities: entitiesCreateNestedOneWithoutEntities_referencesInput
  }

  export type entities_referencesUncheckedCreateInput = {
    reference_id: string
    entity_id: string
    title: string
    author: string
    url: string
  }

  export type entities_referencesUpdateInput = {
    reference_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    entities?: entitiesUpdateOneRequiredWithoutEntities_referencesNestedInput
  }

  export type entities_referencesUncheckedUpdateInput = {
    reference_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type entities_referencesCreateManyInput = {
    reference_id: string
    entity_id: string
    title: string
    author: string
    url: string
  }

  export type entities_referencesUpdateManyMutationInput = {
    reference_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type entities_referencesUncheckedUpdateManyInput = {
    reference_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type groupsCreateInput = {
    group_id: string
    group_handle: string
    group_name?: string | null
    group_current_issue?: string | null
    group_stances?: string | null
    group_description?: string | null
    profile_pictures?: profile_picturesCreateNestedOneWithoutGroupsInput
    groups_members?: groups_membersCreateNestedManyWithoutGroupsInput
  }

  export type groupsUncheckedCreateInput = {
    group_id: string
    group_handle: string
    group_name?: string | null
    group_current_issue?: string | null
    group_stances?: string | null
    group_description?: string | null
    profile_picture_id?: string | null
    groups_members?: groups_membersUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type groupsUpdateInput = {
    group_id?: StringFieldUpdateOperationsInput | string
    group_handle?: StringFieldUpdateOperationsInput | string
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    group_current_issue?: NullableStringFieldUpdateOperationsInput | string | null
    group_stances?: NullableStringFieldUpdateOperationsInput | string | null
    group_description?: NullableStringFieldUpdateOperationsInput | string | null
    profile_pictures?: profile_picturesUpdateOneWithoutGroupsNestedInput
    groups_members?: groups_membersUpdateManyWithoutGroupsNestedInput
  }

  export type groupsUncheckedUpdateInput = {
    group_id?: StringFieldUpdateOperationsInput | string
    group_handle?: StringFieldUpdateOperationsInput | string
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    group_current_issue?: NullableStringFieldUpdateOperationsInput | string | null
    group_stances?: NullableStringFieldUpdateOperationsInput | string | null
    group_description?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_id?: NullableStringFieldUpdateOperationsInput | string | null
    groups_members?: groups_membersUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type groupsCreateManyInput = {
    group_id: string
    group_handle: string
    group_name?: string | null
    group_current_issue?: string | null
    group_stances?: string | null
    group_description?: string | null
    profile_picture_id?: string | null
  }

  export type groupsUpdateManyMutationInput = {
    group_id?: StringFieldUpdateOperationsInput | string
    group_handle?: StringFieldUpdateOperationsInput | string
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    group_current_issue?: NullableStringFieldUpdateOperationsInput | string | null
    group_stances?: NullableStringFieldUpdateOperationsInput | string | null
    group_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type groupsUncheckedUpdateManyInput = {
    group_id?: StringFieldUpdateOperationsInput | string
    group_handle?: StringFieldUpdateOperationsInput | string
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    group_current_issue?: NullableStringFieldUpdateOperationsInput | string | null
    group_stances?: NullableStringFieldUpdateOperationsInput | string | null
    group_description?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type groups_membersCreateInput = {
    groups_members_id: string
    entities: entitiesCreateNestedOneWithoutGroups_membersInput
    groups: groupsCreateNestedOneWithoutGroups_membersInput
  }

  export type groups_membersUncheckedCreateInput = {
    groups_members_id: string
    group_id: string
    entity_id: string
  }

  export type groups_membersUpdateInput = {
    groups_members_id?: StringFieldUpdateOperationsInput | string
    entities?: entitiesUpdateOneRequiredWithoutGroups_membersNestedInput
    groups?: groupsUpdateOneRequiredWithoutGroups_membersNestedInput
  }

  export type groups_membersUncheckedUpdateInput = {
    groups_members_id?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
  }

  export type groups_membersCreateManyInput = {
    groups_members_id: string
    group_id: string
    entity_id: string
  }

  export type groups_membersUpdateManyMutationInput = {
    groups_members_id?: StringFieldUpdateOperationsInput | string
  }

  export type groups_membersUncheckedUpdateManyInput = {
    groups_members_id?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
  }

  export type imagesCreateInput = {
    image_id: string
    image_title: string
    image_description: string
    image_filename: string
    image_likes?: number
    image_dislikes?: number
    image_views?: number
    image_date_posted?: Date | string
    entities: entitiesCreateNestedOneWithoutImagesInput
    images_data: images_dataCreateNestedOneWithoutImagesInput
  }

  export type imagesUncheckedCreateInput = {
    image_id: string
    image_creator_id: string
    image_title: string
    image_description: string
    image_filename: string
    image_data_id: string
    image_likes?: number
    image_dislikes?: number
    image_views?: number
    image_date_posted?: Date | string
  }

  export type imagesUpdateInput = {
    image_id?: StringFieldUpdateOperationsInput | string
    image_title?: StringFieldUpdateOperationsInput | string
    image_description?: StringFieldUpdateOperationsInput | string
    image_filename?: StringFieldUpdateOperationsInput | string
    image_likes?: IntFieldUpdateOperationsInput | number
    image_dislikes?: IntFieldUpdateOperationsInput | number
    image_views?: IntFieldUpdateOperationsInput | number
    image_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
    entities?: entitiesUpdateOneRequiredWithoutImagesNestedInput
    images_data?: images_dataUpdateOneRequiredWithoutImagesNestedInput
  }

  export type imagesUncheckedUpdateInput = {
    image_id?: StringFieldUpdateOperationsInput | string
    image_creator_id?: StringFieldUpdateOperationsInput | string
    image_title?: StringFieldUpdateOperationsInput | string
    image_description?: StringFieldUpdateOperationsInput | string
    image_filename?: StringFieldUpdateOperationsInput | string
    image_data_id?: StringFieldUpdateOperationsInput | string
    image_likes?: IntFieldUpdateOperationsInput | number
    image_dislikes?: IntFieldUpdateOperationsInput | number
    image_views?: IntFieldUpdateOperationsInput | number
    image_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type imagesCreateManyInput = {
    image_id: string
    image_creator_id: string
    image_title: string
    image_description: string
    image_filename: string
    image_data_id: string
    image_likes?: number
    image_dislikes?: number
    image_views?: number
    image_date_posted?: Date | string
  }

  export type imagesUpdateManyMutationInput = {
    image_id?: StringFieldUpdateOperationsInput | string
    image_title?: StringFieldUpdateOperationsInput | string
    image_description?: StringFieldUpdateOperationsInput | string
    image_filename?: StringFieldUpdateOperationsInput | string
    image_likes?: IntFieldUpdateOperationsInput | number
    image_dislikes?: IntFieldUpdateOperationsInput | number
    image_views?: IntFieldUpdateOperationsInput | number
    image_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type imagesUncheckedUpdateManyInput = {
    image_id?: StringFieldUpdateOperationsInput | string
    image_creator_id?: StringFieldUpdateOperationsInput | string
    image_title?: StringFieldUpdateOperationsInput | string
    image_description?: StringFieldUpdateOperationsInput | string
    image_filename?: StringFieldUpdateOperationsInput | string
    image_data_id?: StringFieldUpdateOperationsInput | string
    image_likes?: IntFieldUpdateOperationsInput | number
    image_dislikes?: IntFieldUpdateOperationsInput | number
    image_views?: IntFieldUpdateOperationsInput | number
    image_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type images_dataCreateInput = {
    image_data_id: string
    image_data: Buffer
    images?: imagesCreateNestedManyWithoutImages_dataInput
  }

  export type images_dataUncheckedCreateInput = {
    image_data_id: string
    image_data: Buffer
    images?: imagesUncheckedCreateNestedManyWithoutImages_dataInput
  }

  export type images_dataUpdateInput = {
    image_data_id?: StringFieldUpdateOperationsInput | string
    image_data?: BytesFieldUpdateOperationsInput | Buffer
    images?: imagesUpdateManyWithoutImages_dataNestedInput
  }

  export type images_dataUncheckedUpdateInput = {
    image_data_id?: StringFieldUpdateOperationsInput | string
    image_data?: BytesFieldUpdateOperationsInput | Buffer
    images?: imagesUncheckedUpdateManyWithoutImages_dataNestedInput
  }

  export type images_dataCreateManyInput = {
    image_data_id: string
    image_data: Buffer
  }

  export type images_dataUpdateManyMutationInput = {
    image_data_id?: StringFieldUpdateOperationsInput | string
    image_data?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type images_dataUncheckedUpdateManyInput = {
    image_data_id?: StringFieldUpdateOperationsInput | string
    image_data?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type individualsCreateInput = {
    individual_username: string
    individual_name?: string | null
    individual_current_issue?: string | null
    individual_roles?: string | null
    individual_description?: string | null
    user_credentials: user_credentialsCreateNestedOneWithoutIndividualsInput
    profile_pictures?: profile_picturesCreateNestedOneWithoutIndividualsInput
  }

  export type individualsUncheckedCreateInput = {
    individual_id: string
    individual_username: string
    individual_name?: string | null
    individual_current_issue?: string | null
    individual_roles?: string | null
    individual_description?: string | null
    profile_picture_id?: string | null
  }

  export type individualsUpdateInput = {
    individual_username?: StringFieldUpdateOperationsInput | string
    individual_name?: NullableStringFieldUpdateOperationsInput | string | null
    individual_current_issue?: NullableStringFieldUpdateOperationsInput | string | null
    individual_roles?: NullableStringFieldUpdateOperationsInput | string | null
    individual_description?: NullableStringFieldUpdateOperationsInput | string | null
    user_credentials?: user_credentialsUpdateOneRequiredWithoutIndividualsNestedInput
    profile_pictures?: profile_picturesUpdateOneWithoutIndividualsNestedInput
  }

  export type individualsUncheckedUpdateInput = {
    individual_id?: StringFieldUpdateOperationsInput | string
    individual_username?: StringFieldUpdateOperationsInput | string
    individual_name?: NullableStringFieldUpdateOperationsInput | string | null
    individual_current_issue?: NullableStringFieldUpdateOperationsInput | string | null
    individual_roles?: NullableStringFieldUpdateOperationsInput | string | null
    individual_description?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type individualsCreateManyInput = {
    individual_id: string
    individual_username: string
    individual_name?: string | null
    individual_current_issue?: string | null
    individual_roles?: string | null
    individual_description?: string | null
    profile_picture_id?: string | null
  }

  export type individualsUpdateManyMutationInput = {
    individual_username?: StringFieldUpdateOperationsInput | string
    individual_name?: NullableStringFieldUpdateOperationsInput | string | null
    individual_current_issue?: NullableStringFieldUpdateOperationsInput | string | null
    individual_roles?: NullableStringFieldUpdateOperationsInput | string | null
    individual_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type individualsUncheckedUpdateManyInput = {
    individual_id?: StringFieldUpdateOperationsInput | string
    individual_username?: StringFieldUpdateOperationsInput | string
    individual_name?: NullableStringFieldUpdateOperationsInput | string | null
    individual_current_issue?: NullableStringFieldUpdateOperationsInput | string | null
    individual_roles?: NullableStringFieldUpdateOperationsInput | string | null
    individual_description?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type organizationsCreateInput = {
    organization_id: string
    organization_handle: string
    organization_name?: string | null
    organization_current_issue?: string | null
    organization_stances?: string | null
    organization_description?: string | null
    profile_pictures?: profile_picturesCreateNestedOneWithoutOrganizationsInput
    organizations_members?: organizations_membersCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateInput = {
    organization_id: string
    organization_handle: string
    organization_name?: string | null
    organization_current_issue?: string | null
    organization_stances?: string | null
    organization_description?: string | null
    profile_picture_id?: string | null
    organizations_members?: organizations_membersUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUpdateInput = {
    organization_id?: StringFieldUpdateOperationsInput | string
    organization_handle?: StringFieldUpdateOperationsInput | string
    organization_name?: NullableStringFieldUpdateOperationsInput | string | null
    organization_current_issue?: NullableStringFieldUpdateOperationsInput | string | null
    organization_stances?: NullableStringFieldUpdateOperationsInput | string | null
    organization_description?: NullableStringFieldUpdateOperationsInput | string | null
    profile_pictures?: profile_picturesUpdateOneWithoutOrganizationsNestedInput
    organizations_members?: organizations_membersUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateInput = {
    organization_id?: StringFieldUpdateOperationsInput | string
    organization_handle?: StringFieldUpdateOperationsInput | string
    organization_name?: NullableStringFieldUpdateOperationsInput | string | null
    organization_current_issue?: NullableStringFieldUpdateOperationsInput | string | null
    organization_stances?: NullableStringFieldUpdateOperationsInput | string | null
    organization_description?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_id?: NullableStringFieldUpdateOperationsInput | string | null
    organizations_members?: organizations_membersUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsCreateManyInput = {
    organization_id: string
    organization_handle: string
    organization_name?: string | null
    organization_current_issue?: string | null
    organization_stances?: string | null
    organization_description?: string | null
    profile_picture_id?: string | null
  }

  export type organizationsUpdateManyMutationInput = {
    organization_id?: StringFieldUpdateOperationsInput | string
    organization_handle?: StringFieldUpdateOperationsInput | string
    organization_name?: NullableStringFieldUpdateOperationsInput | string | null
    organization_current_issue?: NullableStringFieldUpdateOperationsInput | string | null
    organization_stances?: NullableStringFieldUpdateOperationsInput | string | null
    organization_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type organizationsUncheckedUpdateManyInput = {
    organization_id?: StringFieldUpdateOperationsInput | string
    organization_handle?: StringFieldUpdateOperationsInput | string
    organization_name?: NullableStringFieldUpdateOperationsInput | string | null
    organization_current_issue?: NullableStringFieldUpdateOperationsInput | string | null
    organization_stances?: NullableStringFieldUpdateOperationsInput | string | null
    organization_description?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type organizations_membersCreateInput = {
    organizations_members_id: string
    entities: entitiesCreateNestedOneWithoutOrganizations_membersInput
    organizations: organizationsCreateNestedOneWithoutOrganizations_membersInput
  }

  export type organizations_membersUncheckedCreateInput = {
    organizations_members_id: string
    organization_id: string
    entity_id: string
  }

  export type organizations_membersUpdateInput = {
    organizations_members_id?: StringFieldUpdateOperationsInput | string
    entities?: entitiesUpdateOneRequiredWithoutOrganizations_membersNestedInput
    organizations?: organizationsUpdateOneRequiredWithoutOrganizations_membersNestedInput
  }

  export type organizations_membersUncheckedUpdateInput = {
    organizations_members_id?: StringFieldUpdateOperationsInput | string
    organization_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
  }

  export type organizations_membersCreateManyInput = {
    organizations_members_id: string
    organization_id: string
    entity_id: string
  }

  export type organizations_membersUpdateManyMutationInput = {
    organizations_members_id?: StringFieldUpdateOperationsInput | string
  }

  export type organizations_membersUncheckedUpdateManyInput = {
    organizations_members_id?: StringFieldUpdateOperationsInput | string
    organization_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
  }

  export type profile_picturesCreateInput = {
    profile_picture_id: string
    profile_picture_data: Buffer
    profile_picture_filename: string
    groups?: groupsCreateNestedManyWithoutProfile_picturesInput
    individuals?: individualsCreateNestedManyWithoutProfile_picturesInput
    organizations?: organizationsCreateNestedManyWithoutProfile_picturesInput
  }

  export type profile_picturesUncheckedCreateInput = {
    profile_picture_id: string
    profile_picture_data: Buffer
    profile_picture_filename: string
    groups?: groupsUncheckedCreateNestedManyWithoutProfile_picturesInput
    individuals?: individualsUncheckedCreateNestedManyWithoutProfile_picturesInput
    organizations?: organizationsUncheckedCreateNestedManyWithoutProfile_picturesInput
  }

  export type profile_picturesUpdateInput = {
    profile_picture_id?: StringFieldUpdateOperationsInput | string
    profile_picture_data?: BytesFieldUpdateOperationsInput | Buffer
    profile_picture_filename?: StringFieldUpdateOperationsInput | string
    groups?: groupsUpdateManyWithoutProfile_picturesNestedInput
    individuals?: individualsUpdateManyWithoutProfile_picturesNestedInput
    organizations?: organizationsUpdateManyWithoutProfile_picturesNestedInput
  }

  export type profile_picturesUncheckedUpdateInput = {
    profile_picture_id?: StringFieldUpdateOperationsInput | string
    profile_picture_data?: BytesFieldUpdateOperationsInput | Buffer
    profile_picture_filename?: StringFieldUpdateOperationsInput | string
    groups?: groupsUncheckedUpdateManyWithoutProfile_picturesNestedInput
    individuals?: individualsUncheckedUpdateManyWithoutProfile_picturesNestedInput
    organizations?: organizationsUncheckedUpdateManyWithoutProfile_picturesNestedInput
  }

  export type profile_picturesCreateManyInput = {
    profile_picture_id: string
    profile_picture_data: Buffer
    profile_picture_filename: string
  }

  export type profile_picturesUpdateManyMutationInput = {
    profile_picture_id?: StringFieldUpdateOperationsInput | string
    profile_picture_data?: BytesFieldUpdateOperationsInput | Buffer
    profile_picture_filename?: StringFieldUpdateOperationsInput | string
  }

  export type profile_picturesUncheckedUpdateManyInput = {
    profile_picture_id?: StringFieldUpdateOperationsInput | string
    profile_picture_data?: BytesFieldUpdateOperationsInput | Buffer
    profile_picture_filename?: StringFieldUpdateOperationsInput | string
  }

  export type sheetsCreateInput = {
    sheet_id: string
    sheet_title: string
    sheet_subject: string
    sheet_filename: string
    sheet_likes?: number
    sheet_dislikes?: number
    sheet_views?: number
    sheet_date_posted?: Date | string
    entities: entitiesCreateNestedOneWithoutSheetsInput
    sheets_data: sheets_dataCreateNestedOneWithoutSheetsInput
    sheets_thumbnails?: sheets_thumbnailsCreateNestedOneWithoutSheetsInput
  }

  export type sheetsUncheckedCreateInput = {
    sheet_id: string
    sheet_author_id: string
    sheet_title: string
    sheet_subject: string
    sheet_filename: string
    sheet_data_id: string
    sheet_thumbnail_id?: string | null
    sheet_likes?: number
    sheet_dislikes?: number
    sheet_views?: number
    sheet_date_posted?: Date | string
  }

  export type sheetsUpdateInput = {
    sheet_id?: StringFieldUpdateOperationsInput | string
    sheet_title?: StringFieldUpdateOperationsInput | string
    sheet_subject?: StringFieldUpdateOperationsInput | string
    sheet_filename?: StringFieldUpdateOperationsInput | string
    sheet_likes?: IntFieldUpdateOperationsInput | number
    sheet_dislikes?: IntFieldUpdateOperationsInput | number
    sheet_views?: IntFieldUpdateOperationsInput | number
    sheet_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
    entities?: entitiesUpdateOneRequiredWithoutSheetsNestedInput
    sheets_data?: sheets_dataUpdateOneRequiredWithoutSheetsNestedInput
    sheets_thumbnails?: sheets_thumbnailsUpdateOneWithoutSheetsNestedInput
  }

  export type sheetsUncheckedUpdateInput = {
    sheet_id?: StringFieldUpdateOperationsInput | string
    sheet_author_id?: StringFieldUpdateOperationsInput | string
    sheet_title?: StringFieldUpdateOperationsInput | string
    sheet_subject?: StringFieldUpdateOperationsInput | string
    sheet_filename?: StringFieldUpdateOperationsInput | string
    sheet_data_id?: StringFieldUpdateOperationsInput | string
    sheet_thumbnail_id?: NullableStringFieldUpdateOperationsInput | string | null
    sheet_likes?: IntFieldUpdateOperationsInput | number
    sheet_dislikes?: IntFieldUpdateOperationsInput | number
    sheet_views?: IntFieldUpdateOperationsInput | number
    sheet_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sheetsCreateManyInput = {
    sheet_id: string
    sheet_author_id: string
    sheet_title: string
    sheet_subject: string
    sheet_filename: string
    sheet_data_id: string
    sheet_thumbnail_id?: string | null
    sheet_likes?: number
    sheet_dislikes?: number
    sheet_views?: number
    sheet_date_posted?: Date | string
  }

  export type sheetsUpdateManyMutationInput = {
    sheet_id?: StringFieldUpdateOperationsInput | string
    sheet_title?: StringFieldUpdateOperationsInput | string
    sheet_subject?: StringFieldUpdateOperationsInput | string
    sheet_filename?: StringFieldUpdateOperationsInput | string
    sheet_likes?: IntFieldUpdateOperationsInput | number
    sheet_dislikes?: IntFieldUpdateOperationsInput | number
    sheet_views?: IntFieldUpdateOperationsInput | number
    sheet_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sheetsUncheckedUpdateManyInput = {
    sheet_id?: StringFieldUpdateOperationsInput | string
    sheet_author_id?: StringFieldUpdateOperationsInput | string
    sheet_title?: StringFieldUpdateOperationsInput | string
    sheet_subject?: StringFieldUpdateOperationsInput | string
    sheet_filename?: StringFieldUpdateOperationsInput | string
    sheet_data_id?: StringFieldUpdateOperationsInput | string
    sheet_thumbnail_id?: NullableStringFieldUpdateOperationsInput | string | null
    sheet_likes?: IntFieldUpdateOperationsInput | number
    sheet_dislikes?: IntFieldUpdateOperationsInput | number
    sheet_views?: IntFieldUpdateOperationsInput | number
    sheet_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sheets_dataCreateInput = {
    sheet_data_id: string
    sheet_data: Buffer
    sheets?: sheetsCreateNestedManyWithoutSheets_dataInput
  }

  export type sheets_dataUncheckedCreateInput = {
    sheet_data_id: string
    sheet_data: Buffer
    sheets?: sheetsUncheckedCreateNestedManyWithoutSheets_dataInput
  }

  export type sheets_dataUpdateInput = {
    sheet_data_id?: StringFieldUpdateOperationsInput | string
    sheet_data?: BytesFieldUpdateOperationsInput | Buffer
    sheets?: sheetsUpdateManyWithoutSheets_dataNestedInput
  }

  export type sheets_dataUncheckedUpdateInput = {
    sheet_data_id?: StringFieldUpdateOperationsInput | string
    sheet_data?: BytesFieldUpdateOperationsInput | Buffer
    sheets?: sheetsUncheckedUpdateManyWithoutSheets_dataNestedInput
  }

  export type sheets_dataCreateManyInput = {
    sheet_data_id: string
    sheet_data: Buffer
  }

  export type sheets_dataUpdateManyMutationInput = {
    sheet_data_id?: StringFieldUpdateOperationsInput | string
    sheet_data?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type sheets_dataUncheckedUpdateManyInput = {
    sheet_data_id?: StringFieldUpdateOperationsInput | string
    sheet_data?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type sheets_thumbnailsCreateInput = {
    sheet_thumbnail_id: string
    sheet_thumbnail_data: Buffer
    sheet_thumbnail_filename: string
    sheet_thumbnail_description?: string | null
    sheets?: sheetsCreateNestedManyWithoutSheets_thumbnailsInput
  }

  export type sheets_thumbnailsUncheckedCreateInput = {
    sheet_thumbnail_id: string
    sheet_thumbnail_data: Buffer
    sheet_thumbnail_filename: string
    sheet_thumbnail_description?: string | null
    sheets?: sheetsUncheckedCreateNestedManyWithoutSheets_thumbnailsInput
  }

  export type sheets_thumbnailsUpdateInput = {
    sheet_thumbnail_id?: StringFieldUpdateOperationsInput | string
    sheet_thumbnail_data?: BytesFieldUpdateOperationsInput | Buffer
    sheet_thumbnail_filename?: StringFieldUpdateOperationsInput | string
    sheet_thumbnail_description?: NullableStringFieldUpdateOperationsInput | string | null
    sheets?: sheetsUpdateManyWithoutSheets_thumbnailsNestedInput
  }

  export type sheets_thumbnailsUncheckedUpdateInput = {
    sheet_thumbnail_id?: StringFieldUpdateOperationsInput | string
    sheet_thumbnail_data?: BytesFieldUpdateOperationsInput | Buffer
    sheet_thumbnail_filename?: StringFieldUpdateOperationsInput | string
    sheet_thumbnail_description?: NullableStringFieldUpdateOperationsInput | string | null
    sheets?: sheetsUncheckedUpdateManyWithoutSheets_thumbnailsNestedInput
  }

  export type sheets_thumbnailsCreateManyInput = {
    sheet_thumbnail_id: string
    sheet_thumbnail_data: Buffer
    sheet_thumbnail_filename: string
    sheet_thumbnail_description?: string | null
  }

  export type sheets_thumbnailsUpdateManyMutationInput = {
    sheet_thumbnail_id?: StringFieldUpdateOperationsInput | string
    sheet_thumbnail_data?: BytesFieldUpdateOperationsInput | Buffer
    sheet_thumbnail_filename?: StringFieldUpdateOperationsInput | string
    sheet_thumbnail_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sheets_thumbnailsUncheckedUpdateManyInput = {
    sheet_thumbnail_id?: StringFieldUpdateOperationsInput | string
    sheet_thumbnail_data?: BytesFieldUpdateOperationsInput | Buffer
    sheet_thumbnail_filename?: StringFieldUpdateOperationsInput | string
    sheet_thumbnail_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tablesCreateInput = {
    table_id: string
    table_name?: string | null
    table_creation_date: Date | string
    last_message?: string | null
    last_message_date?: Date | string | null
    tables_pictures?: tables_picturesCreateNestedOneWithoutTablesInput
    tables_members?: tables_membersCreateNestedManyWithoutTablesInput
    tables_messages_logs?: tables_messages_logsCreateNestedManyWithoutTablesInput
    tables_tabletops?: tables_tabletopsCreateNestedManyWithoutTablesInput
  }

  export type tablesUncheckedCreateInput = {
    table_id: string
    table_name?: string | null
    table_creation_date: Date | string
    last_message?: string | null
    last_message_date?: Date | string | null
    tables_pictures_id?: string | null
    tables_members?: tables_membersUncheckedCreateNestedManyWithoutTablesInput
    tables_messages_logs?: tables_messages_logsUncheckedCreateNestedManyWithoutTablesInput
    tables_tabletops?: tables_tabletopsUncheckedCreateNestedManyWithoutTablesInput
  }

  export type tablesUpdateInput = {
    table_id?: StringFieldUpdateOperationsInput | string
    table_name?: NullableStringFieldUpdateOperationsInput | string | null
    table_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tables_pictures?: tables_picturesUpdateOneWithoutTablesNestedInput
    tables_members?: tables_membersUpdateManyWithoutTablesNestedInput
    tables_messages_logs?: tables_messages_logsUpdateManyWithoutTablesNestedInput
    tables_tabletops?: tables_tabletopsUpdateManyWithoutTablesNestedInput
  }

  export type tablesUncheckedUpdateInput = {
    table_id?: StringFieldUpdateOperationsInput | string
    table_name?: NullableStringFieldUpdateOperationsInput | string | null
    table_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tables_pictures_id?: NullableStringFieldUpdateOperationsInput | string | null
    tables_members?: tables_membersUncheckedUpdateManyWithoutTablesNestedInput
    tables_messages_logs?: tables_messages_logsUncheckedUpdateManyWithoutTablesNestedInput
    tables_tabletops?: tables_tabletopsUncheckedUpdateManyWithoutTablesNestedInput
  }

  export type tablesCreateManyInput = {
    table_id: string
    table_name?: string | null
    table_creation_date: Date | string
    last_message?: string | null
    last_message_date?: Date | string | null
    tables_pictures_id?: string | null
  }

  export type tablesUpdateManyMutationInput = {
    table_id?: StringFieldUpdateOperationsInput | string
    table_name?: NullableStringFieldUpdateOperationsInput | string | null
    table_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tablesUncheckedUpdateManyInput = {
    table_id?: StringFieldUpdateOperationsInput | string
    table_name?: NullableStringFieldUpdateOperationsInput | string | null
    table_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tables_pictures_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tables_membersCreateInput = {
    tables_members_id: string
    table_position: number
    live?: number
    entities: entitiesCreateNestedOneWithoutTables_membersInput
    tables: tablesCreateNestedOneWithoutTables_membersInput
  }

  export type tables_membersUncheckedCreateInput = {
    tables_members_id: string
    table_id: string
    member_id: string
    table_position: number
    live?: number
  }

  export type tables_membersUpdateInput = {
    tables_members_id?: StringFieldUpdateOperationsInput | string
    table_position?: IntFieldUpdateOperationsInput | number
    live?: IntFieldUpdateOperationsInput | number
    entities?: entitiesUpdateOneRequiredWithoutTables_membersNestedInput
    tables?: tablesUpdateOneRequiredWithoutTables_membersNestedInput
  }

  export type tables_membersUncheckedUpdateInput = {
    tables_members_id?: StringFieldUpdateOperationsInput | string
    table_id?: StringFieldUpdateOperationsInput | string
    member_id?: StringFieldUpdateOperationsInput | string
    table_position?: IntFieldUpdateOperationsInput | number
    live?: IntFieldUpdateOperationsInput | number
  }

  export type tables_membersCreateManyInput = {
    tables_members_id: string
    table_id: string
    member_id: string
    table_position: number
    live?: number
  }

  export type tables_membersUpdateManyMutationInput = {
    tables_members_id?: StringFieldUpdateOperationsInput | string
    table_position?: IntFieldUpdateOperationsInput | number
    live?: IntFieldUpdateOperationsInput | number
  }

  export type tables_membersUncheckedUpdateManyInput = {
    tables_members_id?: StringFieldUpdateOperationsInput | string
    table_id?: StringFieldUpdateOperationsInput | string
    member_id?: StringFieldUpdateOperationsInput | string
    table_position?: IntFieldUpdateOperationsInput | number
    live?: IntFieldUpdateOperationsInput | number
  }

  export type tables_messages_logsCreateInput = {
    tables_messages_logs_id: string
    message: string
    message_date: Date | string
    entities: entitiesCreateNestedOneWithoutTables_messages_logsInput
    tables: tablesCreateNestedOneWithoutTables_messages_logsInput
  }

  export type tables_messages_logsUncheckedCreateInput = {
    tables_messages_logs_id: string
    table_id: string
    entity_id: string
    message: string
    message_date: Date | string
  }

  export type tables_messages_logsUpdateInput = {
    tables_messages_logs_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    message_date?: DateTimeFieldUpdateOperationsInput | Date | string
    entities?: entitiesUpdateOneRequiredWithoutTables_messages_logsNestedInput
    tables?: tablesUpdateOneRequiredWithoutTables_messages_logsNestedInput
  }

  export type tables_messages_logsUncheckedUpdateInput = {
    tables_messages_logs_id?: StringFieldUpdateOperationsInput | string
    table_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    message_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tables_messages_logsCreateManyInput = {
    tables_messages_logs_id: string
    table_id: string
    entity_id: string
    message: string
    message_date: Date | string
  }

  export type tables_messages_logsUpdateManyMutationInput = {
    tables_messages_logs_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    message_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tables_messages_logsUncheckedUpdateManyInput = {
    tables_messages_logs_id?: StringFieldUpdateOperationsInput | string
    table_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    message_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tables_picturesCreateInput = {
    tables_pictures_id: string
    table_picture_data: Buffer
    table_picture_filename: string
    tables?: tablesCreateNestedManyWithoutTables_picturesInput
  }

  export type tables_picturesUncheckedCreateInput = {
    tables_pictures_id: string
    table_picture_data: Buffer
    table_picture_filename: string
    tables?: tablesUncheckedCreateNestedManyWithoutTables_picturesInput
  }

  export type tables_picturesUpdateInput = {
    tables_pictures_id?: StringFieldUpdateOperationsInput | string
    table_picture_data?: BytesFieldUpdateOperationsInput | Buffer
    table_picture_filename?: StringFieldUpdateOperationsInput | string
    tables?: tablesUpdateManyWithoutTables_picturesNestedInput
  }

  export type tables_picturesUncheckedUpdateInput = {
    tables_pictures_id?: StringFieldUpdateOperationsInput | string
    table_picture_data?: BytesFieldUpdateOperationsInput | Buffer
    table_picture_filename?: StringFieldUpdateOperationsInput | string
    tables?: tablesUncheckedUpdateManyWithoutTables_picturesNestedInput
  }

  export type tables_picturesCreateManyInput = {
    tables_pictures_id: string
    table_picture_data: Buffer
    table_picture_filename: string
  }

  export type tables_picturesUpdateManyMutationInput = {
    tables_pictures_id?: StringFieldUpdateOperationsInput | string
    table_picture_data?: BytesFieldUpdateOperationsInput | Buffer
    table_picture_filename?: StringFieldUpdateOperationsInput | string
  }

  export type tables_picturesUncheckedUpdateManyInput = {
    tables_pictures_id?: StringFieldUpdateOperationsInput | string
    table_picture_data?: BytesFieldUpdateOperationsInput | Buffer
    table_picture_filename?: StringFieldUpdateOperationsInput | string
  }

  export type tables_tabletopsCreateInput = {
    tables_tabletops_id: string
    type: number
    content_date_posted: Date | string
    content_x_position: number
    content_y_position: number
    content_rotation: number
    content_filename?: string | null
    entities: entitiesCreateNestedOneWithoutTables_tabletopsInput
    tables: tablesCreateNestedOneWithoutTables_tabletopsInput
    tables_tabletops_data?: tables_tabletops_dataCreateNestedOneWithoutTables_tabletopsInput
  }

  export type tables_tabletopsUncheckedCreateInput = {
    tables_tabletops_id: string
    table_id: string
    creator_id: string
    tables_tabletops_data_id?: string | null
    type: number
    content_date_posted: Date | string
    content_x_position: number
    content_y_position: number
    content_rotation: number
    content_filename?: string | null
  }

  export type tables_tabletopsUpdateInput = {
    tables_tabletops_id?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    content_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
    content_x_position?: IntFieldUpdateOperationsInput | number
    content_y_position?: IntFieldUpdateOperationsInput | number
    content_rotation?: IntFieldUpdateOperationsInput | number
    content_filename?: NullableStringFieldUpdateOperationsInput | string | null
    entities?: entitiesUpdateOneRequiredWithoutTables_tabletopsNestedInput
    tables?: tablesUpdateOneRequiredWithoutTables_tabletopsNestedInput
    tables_tabletops_data?: tables_tabletops_dataUpdateOneWithoutTables_tabletopsNestedInput
  }

  export type tables_tabletopsUncheckedUpdateInput = {
    tables_tabletops_id?: StringFieldUpdateOperationsInput | string
    table_id?: StringFieldUpdateOperationsInput | string
    creator_id?: StringFieldUpdateOperationsInput | string
    tables_tabletops_data_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    content_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
    content_x_position?: IntFieldUpdateOperationsInput | number
    content_y_position?: IntFieldUpdateOperationsInput | number
    content_rotation?: IntFieldUpdateOperationsInput | number
    content_filename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tables_tabletopsCreateManyInput = {
    tables_tabletops_id: string
    table_id: string
    creator_id: string
    tables_tabletops_data_id?: string | null
    type: number
    content_date_posted: Date | string
    content_x_position: number
    content_y_position: number
    content_rotation: number
    content_filename?: string | null
  }

  export type tables_tabletopsUpdateManyMutationInput = {
    tables_tabletops_id?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    content_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
    content_x_position?: IntFieldUpdateOperationsInput | number
    content_y_position?: IntFieldUpdateOperationsInput | number
    content_rotation?: IntFieldUpdateOperationsInput | number
    content_filename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tables_tabletopsUncheckedUpdateManyInput = {
    tables_tabletops_id?: StringFieldUpdateOperationsInput | string
    table_id?: StringFieldUpdateOperationsInput | string
    creator_id?: StringFieldUpdateOperationsInput | string
    tables_tabletops_data_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    content_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
    content_x_position?: IntFieldUpdateOperationsInput | number
    content_y_position?: IntFieldUpdateOperationsInput | number
    content_rotation?: IntFieldUpdateOperationsInput | number
    content_filename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tables_tabletops_dataCreateInput = {
    tables_tabletops_data_id: string
    tables_tabletops_data: Buffer
    tables_tabletops?: tables_tabletopsCreateNestedManyWithoutTables_tabletops_dataInput
  }

  export type tables_tabletops_dataUncheckedCreateInput = {
    tables_tabletops_data_id: string
    tables_tabletops_data: Buffer
    tables_tabletops?: tables_tabletopsUncheckedCreateNestedManyWithoutTables_tabletops_dataInput
  }

  export type tables_tabletops_dataUpdateInput = {
    tables_tabletops_data_id?: StringFieldUpdateOperationsInput | string
    tables_tabletops_data?: BytesFieldUpdateOperationsInput | Buffer
    tables_tabletops?: tables_tabletopsUpdateManyWithoutTables_tabletops_dataNestedInput
  }

  export type tables_tabletops_dataUncheckedUpdateInput = {
    tables_tabletops_data_id?: StringFieldUpdateOperationsInput | string
    tables_tabletops_data?: BytesFieldUpdateOperationsInput | Buffer
    tables_tabletops?: tables_tabletopsUncheckedUpdateManyWithoutTables_tabletops_dataNestedInput
  }

  export type tables_tabletops_dataCreateManyInput = {
    tables_tabletops_data_id: string
    tables_tabletops_data: Buffer
  }

  export type tables_tabletops_dataUpdateManyMutationInput = {
    tables_tabletops_data_id?: StringFieldUpdateOperationsInput | string
    tables_tabletops_data?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type tables_tabletops_dataUncheckedUpdateManyInput = {
    tables_tabletops_data_id?: StringFieldUpdateOperationsInput | string
    tables_tabletops_data?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type user_credentialsCreateInput = {
    user_id: string
    username: string
    user_password: string
    user_first_name?: string | null
    user_last_name?: string | null
    user_email?: string | null
    user_phone_number?: string | null
    individuals?: individualsCreateNestedOneWithoutUser_credentialsInput
  }

  export type user_credentialsUncheckedCreateInput = {
    user_id: string
    username: string
    user_password: string
    user_first_name?: string | null
    user_last_name?: string | null
    user_email?: string | null
    user_phone_number?: string | null
    individuals?: individualsUncheckedCreateNestedOneWithoutUser_credentialsInput
  }

  export type user_credentialsUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    user_first_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_last_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_email?: NullableStringFieldUpdateOperationsInput | string | null
    user_phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    individuals?: individualsUpdateOneWithoutUser_credentialsNestedInput
  }

  export type user_credentialsUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    user_first_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_last_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_email?: NullableStringFieldUpdateOperationsInput | string | null
    user_phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    individuals?: individualsUncheckedUpdateOneWithoutUser_credentialsNestedInput
  }

  export type user_credentialsCreateManyInput = {
    user_id: string
    username: string
    user_password: string
    user_first_name?: string | null
    user_last_name?: string | null
    user_email?: string | null
    user_phone_number?: string | null
  }

  export type user_credentialsUpdateManyMutationInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    user_first_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_last_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_email?: NullableStringFieldUpdateOperationsInput | string | null
    user_phone_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_credentialsUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    user_first_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_last_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_email?: NullableStringFieldUpdateOperationsInput | string | null
    user_phone_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type videosCreateInput = {
    video_id: string
    video_title: string
    video_description: string
    video_filename: string
    video_likes?: number
    video_dislikes?: number
    video_views?: number
    video_date_posted?: Date | string | null
    entities: entitiesCreateNestedOneWithoutVideosInput
    videos_data: videos_dataCreateNestedOneWithoutVideosInput
    videos_thumbnails?: videos_thumbnailsCreateNestedOneWithoutVideosInput
  }

  export type videosUncheckedCreateInput = {
    video_id: string
    video_creator_id: string
    video_title: string
    video_description: string
    video_filename: string
    video_data_id: string
    video_thumbnail_id?: string | null
    video_likes?: number
    video_dislikes?: number
    video_views?: number
    video_date_posted?: Date | string | null
  }

  export type videosUpdateInput = {
    video_id?: StringFieldUpdateOperationsInput | string
    video_title?: StringFieldUpdateOperationsInput | string
    video_description?: StringFieldUpdateOperationsInput | string
    video_filename?: StringFieldUpdateOperationsInput | string
    video_likes?: IntFieldUpdateOperationsInput | number
    video_dislikes?: IntFieldUpdateOperationsInput | number
    video_views?: IntFieldUpdateOperationsInput | number
    video_date_posted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entities?: entitiesUpdateOneRequiredWithoutVideosNestedInput
    videos_data?: videos_dataUpdateOneRequiredWithoutVideosNestedInput
    videos_thumbnails?: videos_thumbnailsUpdateOneWithoutVideosNestedInput
  }

  export type videosUncheckedUpdateInput = {
    video_id?: StringFieldUpdateOperationsInput | string
    video_creator_id?: StringFieldUpdateOperationsInput | string
    video_title?: StringFieldUpdateOperationsInput | string
    video_description?: StringFieldUpdateOperationsInput | string
    video_filename?: StringFieldUpdateOperationsInput | string
    video_data_id?: StringFieldUpdateOperationsInput | string
    video_thumbnail_id?: NullableStringFieldUpdateOperationsInput | string | null
    video_likes?: IntFieldUpdateOperationsInput | number
    video_dislikes?: IntFieldUpdateOperationsInput | number
    video_views?: IntFieldUpdateOperationsInput | number
    video_date_posted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type videosCreateManyInput = {
    video_id: string
    video_creator_id: string
    video_title: string
    video_description: string
    video_filename: string
    video_data_id: string
    video_thumbnail_id?: string | null
    video_likes?: number
    video_dislikes?: number
    video_views?: number
    video_date_posted?: Date | string | null
  }

  export type videosUpdateManyMutationInput = {
    video_id?: StringFieldUpdateOperationsInput | string
    video_title?: StringFieldUpdateOperationsInput | string
    video_description?: StringFieldUpdateOperationsInput | string
    video_filename?: StringFieldUpdateOperationsInput | string
    video_likes?: IntFieldUpdateOperationsInput | number
    video_dislikes?: IntFieldUpdateOperationsInput | number
    video_views?: IntFieldUpdateOperationsInput | number
    video_date_posted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type videosUncheckedUpdateManyInput = {
    video_id?: StringFieldUpdateOperationsInput | string
    video_creator_id?: StringFieldUpdateOperationsInput | string
    video_title?: StringFieldUpdateOperationsInput | string
    video_description?: StringFieldUpdateOperationsInput | string
    video_filename?: StringFieldUpdateOperationsInput | string
    video_data_id?: StringFieldUpdateOperationsInput | string
    video_thumbnail_id?: NullableStringFieldUpdateOperationsInput | string | null
    video_likes?: IntFieldUpdateOperationsInput | number
    video_dislikes?: IntFieldUpdateOperationsInput | number
    video_views?: IntFieldUpdateOperationsInput | number
    video_date_posted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type videos_dataCreateInput = {
    video_data_id: string
    video_data: Buffer
    videos?: videosCreateNestedManyWithoutVideos_dataInput
  }

  export type videos_dataUncheckedCreateInput = {
    video_data_id: string
    video_data: Buffer
    videos?: videosUncheckedCreateNestedManyWithoutVideos_dataInput
  }

  export type videos_dataUpdateInput = {
    video_data_id?: StringFieldUpdateOperationsInput | string
    video_data?: BytesFieldUpdateOperationsInput | Buffer
    videos?: videosUpdateManyWithoutVideos_dataNestedInput
  }

  export type videos_dataUncheckedUpdateInput = {
    video_data_id?: StringFieldUpdateOperationsInput | string
    video_data?: BytesFieldUpdateOperationsInput | Buffer
    videos?: videosUncheckedUpdateManyWithoutVideos_dataNestedInput
  }

  export type videos_dataCreateManyInput = {
    video_data_id: string
    video_data: Buffer
  }

  export type videos_dataUpdateManyMutationInput = {
    video_data_id?: StringFieldUpdateOperationsInput | string
    video_data?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type videos_dataUncheckedUpdateManyInput = {
    video_data_id?: StringFieldUpdateOperationsInput | string
    video_data?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type videos_thumbnailsCreateInput = {
    video_thumbnail_id: string
    video_thumbnail_data: Buffer
    video_thumbnail_filename: string
    video_thumbnail_description?: string | null
    videos?: videosCreateNestedManyWithoutVideos_thumbnailsInput
  }

  export type videos_thumbnailsUncheckedCreateInput = {
    video_thumbnail_id: string
    video_thumbnail_data: Buffer
    video_thumbnail_filename: string
    video_thumbnail_description?: string | null
    videos?: videosUncheckedCreateNestedManyWithoutVideos_thumbnailsInput
  }

  export type videos_thumbnailsUpdateInput = {
    video_thumbnail_id?: StringFieldUpdateOperationsInput | string
    video_thumbnail_data?: BytesFieldUpdateOperationsInput | Buffer
    video_thumbnail_filename?: StringFieldUpdateOperationsInput | string
    video_thumbnail_description?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: videosUpdateManyWithoutVideos_thumbnailsNestedInput
  }

  export type videos_thumbnailsUncheckedUpdateInput = {
    video_thumbnail_id?: StringFieldUpdateOperationsInput | string
    video_thumbnail_data?: BytesFieldUpdateOperationsInput | Buffer
    video_thumbnail_filename?: StringFieldUpdateOperationsInput | string
    video_thumbnail_description?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: videosUncheckedUpdateManyWithoutVideos_thumbnailsNestedInput
  }

  export type videos_thumbnailsCreateManyInput = {
    video_thumbnail_id: string
    video_thumbnail_data: Buffer
    video_thumbnail_filename: string
    video_thumbnail_description?: string | null
  }

  export type videos_thumbnailsUpdateManyMutationInput = {
    video_thumbnail_id?: StringFieldUpdateOperationsInput | string
    video_thumbnail_data?: BytesFieldUpdateOperationsInput | Buffer
    video_thumbnail_filename?: StringFieldUpdateOperationsInput | string
    video_thumbnail_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type videos_thumbnailsUncheckedUpdateManyInput = {
    video_thumbnail_id?: StringFieldUpdateOperationsInput | string
    video_thumbnail_data?: BytesFieldUpdateOperationsInput | Buffer
    video_thumbnail_filename?: StringFieldUpdateOperationsInput | string
    video_thumbnail_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type affiliates_relationsAffiliate_id_rootAffiliate_id_targetCompoundUniqueInput = {
    affiliate_id_root: string
    affiliate_id_target: string
  }

  export type affiliates_relationsCountOrderByAggregateInput = {
    affiliate_relation_id?: SortOrder
    affiliate_id_root?: SortOrder
    affiliate_id_target?: SortOrder
    affiliate_relation_date?: SortOrder
  }

  export type affiliates_relationsMaxOrderByAggregateInput = {
    affiliate_relation_id?: SortOrder
    affiliate_id_root?: SortOrder
    affiliate_id_target?: SortOrder
    affiliate_relation_date?: SortOrder
  }

  export type affiliates_relationsMinOrderByAggregateInput = {
    affiliate_relation_id?: SortOrder
    affiliate_id_root?: SortOrder
    affiliate_id_target?: SortOrder
    affiliate_relation_date?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EntitiesRelationFilter = {
    is?: entitiesWhereInput
    isNot?: entitiesWhereInput
  }

  export type Collections_contentListRelationFilter = {
    every?: collections_contentWhereInput
    some?: collections_contentWhereInput
    none?: collections_contentWhereInput
  }

  export type collections_contentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type collectionsCountOrderByAggregateInput = {
    collection_id?: SortOrder
    collection_name?: SortOrder
    entity_id?: SortOrder
  }

  export type collectionsMaxOrderByAggregateInput = {
    collection_id?: SortOrder
    collection_name?: SortOrder
    entity_id?: SortOrder
  }

  export type collectionsMinOrderByAggregateInput = {
    collection_id?: SortOrder
    collection_name?: SortOrder
    entity_id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CollectionsRelationFilter = {
    is?: collectionsWhereInput
    isNot?: collectionsWhereInput
  }

  export type ContentRelationFilter = {
    is?: contentWhereInput
    isNot?: contentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type collections_contentCountOrderByAggregateInput = {
    collections_content_id?: SortOrder
    collection_id?: SortOrder
    content_id?: SortOrder
    date_added?: SortOrder
    pinned?: SortOrder
    date_pinned?: SortOrder
  }

  export type collections_contentMaxOrderByAggregateInput = {
    collections_content_id?: SortOrder
    collection_id?: SortOrder
    content_id?: SortOrder
    date_added?: SortOrder
    pinned?: SortOrder
    date_pinned?: SortOrder
  }

  export type collections_contentMinOrderByAggregateInput = {
    collections_content_id?: SortOrder
    collection_id?: SortOrder
    content_id?: SortOrder
    date_added?: SortOrder
    pinned?: SortOrder
    date_pinned?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type Contacts_picturesNullableRelationFilter = {
    is?: contacts_picturesWhereInput | null
    isNot?: contacts_picturesWhereInput | null
  }

  export type contactsContact_idConversation_idCompoundUniqueInput = {
    contact_id: string
    conversation_id: string
  }

  export type contactsContact_id_rootContact_id_targetCompoundUniqueInput = {
    contact_id_root: string
    contact_id_target: string
  }

  export type contactsCountOrderByAggregateInput = {
    contact_id?: SortOrder
    conversation_id?: SortOrder
    contact_id_root?: SortOrder
    contact_id_target?: SortOrder
    contact_creation_date?: SortOrder
    last_message?: SortOrder
    last_contact_date?: SortOrder
    contacts_pictures_id?: SortOrder
  }

  export type contactsMaxOrderByAggregateInput = {
    contact_id?: SortOrder
    conversation_id?: SortOrder
    contact_id_root?: SortOrder
    contact_id_target?: SortOrder
    contact_creation_date?: SortOrder
    last_message?: SortOrder
    last_contact_date?: SortOrder
    contacts_pictures_id?: SortOrder
  }

  export type contactsMinOrderByAggregateInput = {
    contact_id?: SortOrder
    conversation_id?: SortOrder
    contact_id_root?: SortOrder
    contact_id_target?: SortOrder
    contact_creation_date?: SortOrder
    last_message?: SortOrder
    last_contact_date?: SortOrder
    contacts_pictures_id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[]
    notIn?: Buffer[]
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type ContactsListRelationFilter = {
    every?: contactsWhereInput
    some?: contactsWhereInput
    none?: contactsWhereInput
  }

  export type contactsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type contacts_picturesCountOrderByAggregateInput = {
    contacts_pictures_id?: SortOrder
    contact_picture_data?: SortOrder
    contact_picture_filename?: SortOrder
  }

  export type contacts_picturesMaxOrderByAggregateInput = {
    contacts_pictures_id?: SortOrder
    contact_picture_data?: SortOrder
    contact_picture_filename?: SortOrder
  }

  export type contacts_picturesMinOrderByAggregateInput = {
    contacts_pictures_id?: SortOrder
    contact_picture_data?: SortOrder
    contact_picture_filename?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[]
    notIn?: Buffer[]
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type Entities_contentListRelationFilter = {
    every?: entities_contentWhereInput
    some?: entities_contentWhereInput
    none?: entities_contentWhereInput
  }

  export type Entities_dislikesListRelationFilter = {
    every?: entities_dislikesWhereInput
    some?: entities_dislikesWhereInput
    none?: entities_dislikesWhereInput
  }

  export type Entities_likesListRelationFilter = {
    every?: entities_likesWhereInput
    some?: entities_likesWhereInput
    none?: entities_likesWhereInput
  }

  export type entities_contentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type entities_dislikesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type entities_likesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type contentCountOrderByAggregateInput = {
    content_id?: SortOrder
    content_type?: SortOrder
  }

  export type contentAvgOrderByAggregateInput = {
    content_type?: SortOrder
  }

  export type contentMaxOrderByAggregateInput = {
    content_id?: SortOrder
    content_type?: SortOrder
  }

  export type contentMinOrderByAggregateInput = {
    content_id?: SortOrder
    content_type?: SortOrder
  }

  export type contentSumOrderByAggregateInput = {
    content_type?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type Conversations_picturesNullableRelationFilter = {
    is?: conversations_picturesWhereInput | null
    isNot?: conversations_picturesWhereInput | null
  }

  export type Conversations_membersListRelationFilter = {
    every?: conversations_membersWhereInput
    some?: conversations_membersWhereInput
    none?: conversations_membersWhereInput
  }

  export type Conversations_messages_logsListRelationFilter = {
    every?: conversations_messages_logsWhereInput
    some?: conversations_messages_logsWhereInput
    none?: conversations_messages_logsWhereInput
  }

  export type conversations_membersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type conversations_messages_logsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type conversationsCountOrderByAggregateInput = {
    conversation_id?: SortOrder
    conversation_name?: SortOrder
    conversation_creation_date?: SortOrder
    last_message?: SortOrder
    last_message_date?: SortOrder
    conversations_pictures_id?: SortOrder
  }

  export type conversationsMaxOrderByAggregateInput = {
    conversation_id?: SortOrder
    conversation_name?: SortOrder
    conversation_creation_date?: SortOrder
    last_message?: SortOrder
    last_message_date?: SortOrder
    conversations_pictures_id?: SortOrder
  }

  export type conversationsMinOrderByAggregateInput = {
    conversation_id?: SortOrder
    conversation_name?: SortOrder
    conversation_creation_date?: SortOrder
    last_message?: SortOrder
    last_message_date?: SortOrder
    conversations_pictures_id?: SortOrder
  }

  export type ConversationsRelationFilter = {
    is?: conversationsWhereInput
    isNot?: conversationsWhereInput
  }

  export type conversations_membersConversation_idMember_idCompoundUniqueInput = {
    conversation_id: string
    member_id: string
  }

  export type conversations_membersCountOrderByAggregateInput = {
    conversations_members_id?: SortOrder
    conversation_id?: SortOrder
    member_id?: SortOrder
  }

  export type conversations_membersMaxOrderByAggregateInput = {
    conversations_members_id?: SortOrder
    conversation_id?: SortOrder
    member_id?: SortOrder
  }

  export type conversations_membersMinOrderByAggregateInput = {
    conversations_members_id?: SortOrder
    conversation_id?: SortOrder
    member_id?: SortOrder
  }

  export type conversations_messages_logsCountOrderByAggregateInput = {
    conversations_messages_logs_id?: SortOrder
    conversation_id?: SortOrder
    entity_id?: SortOrder
    message?: SortOrder
    message_date?: SortOrder
  }

  export type conversations_messages_logsMaxOrderByAggregateInput = {
    conversations_messages_logs_id?: SortOrder
    conversation_id?: SortOrder
    entity_id?: SortOrder
    message?: SortOrder
    message_date?: SortOrder
  }

  export type conversations_messages_logsMinOrderByAggregateInput = {
    conversations_messages_logs_id?: SortOrder
    conversation_id?: SortOrder
    entity_id?: SortOrder
    message?: SortOrder
    message_date?: SortOrder
  }

  export type ConversationsListRelationFilter = {
    every?: conversationsWhereInput
    some?: conversationsWhereInput
    none?: conversationsWhereInput
  }

  export type conversationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type conversations_picturesCountOrderByAggregateInput = {
    conversations_pictures_id?: SortOrder
    conversation_picture_data?: SortOrder
    conversation_picture_filename?: SortOrder
  }

  export type conversations_picturesMaxOrderByAggregateInput = {
    conversations_pictures_id?: SortOrder
    conversation_picture_data?: SortOrder
    conversation_picture_filename?: SortOrder
  }

  export type conversations_picturesMinOrderByAggregateInput = {
    conversations_pictures_id?: SortOrder
    conversation_picture_data?: SortOrder
    conversation_picture_filename?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type CollectionsListRelationFilter = {
    every?: collectionsWhereInput
    some?: collectionsWhereInput
    none?: collectionsWhereInput
  }

  export type Entities_referencesListRelationFilter = {
    every?: entities_referencesWhereInput
    some?: entities_referencesWhereInput
    none?: entities_referencesWhereInput
  }

  export type Groups_membersListRelationFilter = {
    every?: groups_membersWhereInput
    some?: groups_membersWhereInput
    none?: groups_membersWhereInput
  }

  export type ImagesListRelationFilter = {
    every?: imagesWhereInput
    some?: imagesWhereInput
    none?: imagesWhereInput
  }

  export type Organizations_membersListRelationFilter = {
    every?: organizations_membersWhereInput
    some?: organizations_membersWhereInput
    none?: organizations_membersWhereInput
  }

  export type SheetsListRelationFilter = {
    every?: sheetsWhereInput
    some?: sheetsWhereInput
    none?: sheetsWhereInput
  }

  export type Tables_membersListRelationFilter = {
    every?: tables_membersWhereInput
    some?: tables_membersWhereInput
    none?: tables_membersWhereInput
  }

  export type Tables_messages_logsListRelationFilter = {
    every?: tables_messages_logsWhereInput
    some?: tables_messages_logsWhereInput
    none?: tables_messages_logsWhereInput
  }

  export type Tables_tabletopsListRelationFilter = {
    every?: tables_tabletopsWhereInput
    some?: tables_tabletopsWhereInput
    none?: tables_tabletopsWhereInput
  }

  export type VideosListRelationFilter = {
    every?: videosWhereInput
    some?: videosWhereInput
    none?: videosWhereInput
  }

  export type collectionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type entities_referencesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type groups_membersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type imagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type organizations_membersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sheetsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tables_membersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tables_messages_logsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tables_tabletopsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type videosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type entitiesCountOrderByAggregateInput = {
    entity_id?: SortOrder
    entity_username?: SortOrder
    entity_type?: SortOrder
  }

  export type entitiesAvgOrderByAggregateInput = {
    entity_type?: SortOrder
  }

  export type entitiesMaxOrderByAggregateInput = {
    entity_id?: SortOrder
    entity_username?: SortOrder
    entity_type?: SortOrder
  }

  export type entitiesMinOrderByAggregateInput = {
    entity_id?: SortOrder
    entity_username?: SortOrder
    entity_type?: SortOrder
  }

  export type entitiesSumOrderByAggregateInput = {
    entity_type?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type entities_contentCountOrderByAggregateInput = {
    entities_content_id?: SortOrder
    entity_id?: SortOrder
    content_id?: SortOrder
    date_added?: SortOrder
    pinned?: SortOrder
    date_pinned?: SortOrder
  }

  export type entities_contentMaxOrderByAggregateInput = {
    entities_content_id?: SortOrder
    entity_id?: SortOrder
    content_id?: SortOrder
    date_added?: SortOrder
    pinned?: SortOrder
    date_pinned?: SortOrder
  }

  export type entities_contentMinOrderByAggregateInput = {
    entities_content_id?: SortOrder
    entity_id?: SortOrder
    content_id?: SortOrder
    date_added?: SortOrder
    pinned?: SortOrder
    date_pinned?: SortOrder
  }

  export type entities_dislikesEntity_idContent_idCompoundUniqueInput = {
    entity_id: string
    content_id: string
  }

  export type entities_dislikesCountOrderByAggregateInput = {
    dislike_id?: SortOrder
    entity_id?: SortOrder
    content_id?: SortOrder
  }

  export type entities_dislikesMaxOrderByAggregateInput = {
    dislike_id?: SortOrder
    entity_id?: SortOrder
    content_id?: SortOrder
  }

  export type entities_dislikesMinOrderByAggregateInput = {
    dislike_id?: SortOrder
    entity_id?: SortOrder
    content_id?: SortOrder
  }

  export type entities_likesEntity_idContent_idCompoundUniqueInput = {
    entity_id: string
    content_id: string
  }

  export type entities_likesCountOrderByAggregateInput = {
    like_id?: SortOrder
    entity_id?: SortOrder
    content_id?: SortOrder
  }

  export type entities_likesMaxOrderByAggregateInput = {
    like_id?: SortOrder
    entity_id?: SortOrder
    content_id?: SortOrder
  }

  export type entities_likesMinOrderByAggregateInput = {
    like_id?: SortOrder
    entity_id?: SortOrder
    content_id?: SortOrder
  }

  export type entities_referencesCountOrderByAggregateInput = {
    reference_id?: SortOrder
    entity_id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    url?: SortOrder
  }

  export type entities_referencesMaxOrderByAggregateInput = {
    reference_id?: SortOrder
    entity_id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    url?: SortOrder
  }

  export type entities_referencesMinOrderByAggregateInput = {
    reference_id?: SortOrder
    entity_id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    url?: SortOrder
  }

  export type Profile_picturesNullableRelationFilter = {
    is?: profile_picturesWhereInput | null
    isNot?: profile_picturesWhereInput | null
  }

  export type groupsCountOrderByAggregateInput = {
    group_id?: SortOrder
    group_handle?: SortOrder
    group_name?: SortOrder
    group_current_issue?: SortOrder
    group_stances?: SortOrder
    group_description?: SortOrder
    profile_picture_id?: SortOrder
  }

  export type groupsMaxOrderByAggregateInput = {
    group_id?: SortOrder
    group_handle?: SortOrder
    group_name?: SortOrder
    group_current_issue?: SortOrder
    group_stances?: SortOrder
    group_description?: SortOrder
    profile_picture_id?: SortOrder
  }

  export type groupsMinOrderByAggregateInput = {
    group_id?: SortOrder
    group_handle?: SortOrder
    group_name?: SortOrder
    group_current_issue?: SortOrder
    group_stances?: SortOrder
    group_description?: SortOrder
    profile_picture_id?: SortOrder
  }

  export type GroupsRelationFilter = {
    is?: groupsWhereInput
    isNot?: groupsWhereInput
  }

  export type groups_membersGroup_idEntity_idCompoundUniqueInput = {
    group_id: string
    entity_id: string
  }

  export type groups_membersCountOrderByAggregateInput = {
    groups_members_id?: SortOrder
    group_id?: SortOrder
    entity_id?: SortOrder
  }

  export type groups_membersMaxOrderByAggregateInput = {
    groups_members_id?: SortOrder
    group_id?: SortOrder
    entity_id?: SortOrder
  }

  export type groups_membersMinOrderByAggregateInput = {
    groups_members_id?: SortOrder
    group_id?: SortOrder
    entity_id?: SortOrder
  }

  export type Images_dataRelationFilter = {
    is?: images_dataWhereInput
    isNot?: images_dataWhereInput
  }

  export type imagesCountOrderByAggregateInput = {
    image_id?: SortOrder
    image_creator_id?: SortOrder
    image_title?: SortOrder
    image_description?: SortOrder
    image_filename?: SortOrder
    image_data_id?: SortOrder
    image_likes?: SortOrder
    image_dislikes?: SortOrder
    image_views?: SortOrder
    image_date_posted?: SortOrder
  }

  export type imagesAvgOrderByAggregateInput = {
    image_likes?: SortOrder
    image_dislikes?: SortOrder
    image_views?: SortOrder
  }

  export type imagesMaxOrderByAggregateInput = {
    image_id?: SortOrder
    image_creator_id?: SortOrder
    image_title?: SortOrder
    image_description?: SortOrder
    image_filename?: SortOrder
    image_data_id?: SortOrder
    image_likes?: SortOrder
    image_dislikes?: SortOrder
    image_views?: SortOrder
    image_date_posted?: SortOrder
  }

  export type imagesMinOrderByAggregateInput = {
    image_id?: SortOrder
    image_creator_id?: SortOrder
    image_title?: SortOrder
    image_description?: SortOrder
    image_filename?: SortOrder
    image_data_id?: SortOrder
    image_likes?: SortOrder
    image_dislikes?: SortOrder
    image_views?: SortOrder
    image_date_posted?: SortOrder
  }

  export type imagesSumOrderByAggregateInput = {
    image_likes?: SortOrder
    image_dislikes?: SortOrder
    image_views?: SortOrder
  }

  export type images_dataCountOrderByAggregateInput = {
    image_data_id?: SortOrder
    image_data?: SortOrder
  }

  export type images_dataMaxOrderByAggregateInput = {
    image_data_id?: SortOrder
    image_data?: SortOrder
  }

  export type images_dataMinOrderByAggregateInput = {
    image_data_id?: SortOrder
    image_data?: SortOrder
  }

  export type User_credentialsRelationFilter = {
    is?: user_credentialsWhereInput
    isNot?: user_credentialsWhereInput
  }

  export type individualsCountOrderByAggregateInput = {
    individual_id?: SortOrder
    individual_username?: SortOrder
    individual_name?: SortOrder
    individual_current_issue?: SortOrder
    individual_roles?: SortOrder
    individual_description?: SortOrder
    profile_picture_id?: SortOrder
  }

  export type individualsMaxOrderByAggregateInput = {
    individual_id?: SortOrder
    individual_username?: SortOrder
    individual_name?: SortOrder
    individual_current_issue?: SortOrder
    individual_roles?: SortOrder
    individual_description?: SortOrder
    profile_picture_id?: SortOrder
  }

  export type individualsMinOrderByAggregateInput = {
    individual_id?: SortOrder
    individual_username?: SortOrder
    individual_name?: SortOrder
    individual_current_issue?: SortOrder
    individual_roles?: SortOrder
    individual_description?: SortOrder
    profile_picture_id?: SortOrder
  }

  export type organizationsCountOrderByAggregateInput = {
    organization_id?: SortOrder
    organization_handle?: SortOrder
    organization_name?: SortOrder
    organization_current_issue?: SortOrder
    organization_stances?: SortOrder
    organization_description?: SortOrder
    profile_picture_id?: SortOrder
  }

  export type organizationsMaxOrderByAggregateInput = {
    organization_id?: SortOrder
    organization_handle?: SortOrder
    organization_name?: SortOrder
    organization_current_issue?: SortOrder
    organization_stances?: SortOrder
    organization_description?: SortOrder
    profile_picture_id?: SortOrder
  }

  export type organizationsMinOrderByAggregateInput = {
    organization_id?: SortOrder
    organization_handle?: SortOrder
    organization_name?: SortOrder
    organization_current_issue?: SortOrder
    organization_stances?: SortOrder
    organization_description?: SortOrder
    profile_picture_id?: SortOrder
  }

  export type OrganizationsRelationFilter = {
    is?: organizationsWhereInput
    isNot?: organizationsWhereInput
  }

  export type organizations_membersCountOrderByAggregateInput = {
    organizations_members_id?: SortOrder
    organization_id?: SortOrder
    entity_id?: SortOrder
  }

  export type organizations_membersMaxOrderByAggregateInput = {
    organizations_members_id?: SortOrder
    organization_id?: SortOrder
    entity_id?: SortOrder
  }

  export type organizations_membersMinOrderByAggregateInput = {
    organizations_members_id?: SortOrder
    organization_id?: SortOrder
    entity_id?: SortOrder
  }

  export type GroupsListRelationFilter = {
    every?: groupsWhereInput
    some?: groupsWhereInput
    none?: groupsWhereInput
  }

  export type IndividualsListRelationFilter = {
    every?: individualsWhereInput
    some?: individualsWhereInput
    none?: individualsWhereInput
  }

  export type OrganizationsListRelationFilter = {
    every?: organizationsWhereInput
    some?: organizationsWhereInput
    none?: organizationsWhereInput
  }

  export type groupsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type individualsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type organizationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type profile_picturesCountOrderByAggregateInput = {
    profile_picture_id?: SortOrder
    profile_picture_data?: SortOrder
    profile_picture_filename?: SortOrder
  }

  export type profile_picturesMaxOrderByAggregateInput = {
    profile_picture_id?: SortOrder
    profile_picture_data?: SortOrder
    profile_picture_filename?: SortOrder
  }

  export type profile_picturesMinOrderByAggregateInput = {
    profile_picture_id?: SortOrder
    profile_picture_data?: SortOrder
    profile_picture_filename?: SortOrder
  }

  export type Sheets_dataRelationFilter = {
    is?: sheets_dataWhereInput
    isNot?: sheets_dataWhereInput
  }

  export type Sheets_thumbnailsNullableRelationFilter = {
    is?: sheets_thumbnailsWhereInput | null
    isNot?: sheets_thumbnailsWhereInput | null
  }

  export type sheetsCountOrderByAggregateInput = {
    sheet_id?: SortOrder
    sheet_author_id?: SortOrder
    sheet_title?: SortOrder
    sheet_subject?: SortOrder
    sheet_filename?: SortOrder
    sheet_data_id?: SortOrder
    sheet_thumbnail_id?: SortOrder
    sheet_likes?: SortOrder
    sheet_dislikes?: SortOrder
    sheet_views?: SortOrder
    sheet_date_posted?: SortOrder
  }

  export type sheetsAvgOrderByAggregateInput = {
    sheet_likes?: SortOrder
    sheet_dislikes?: SortOrder
    sheet_views?: SortOrder
  }

  export type sheetsMaxOrderByAggregateInput = {
    sheet_id?: SortOrder
    sheet_author_id?: SortOrder
    sheet_title?: SortOrder
    sheet_subject?: SortOrder
    sheet_filename?: SortOrder
    sheet_data_id?: SortOrder
    sheet_thumbnail_id?: SortOrder
    sheet_likes?: SortOrder
    sheet_dislikes?: SortOrder
    sheet_views?: SortOrder
    sheet_date_posted?: SortOrder
  }

  export type sheetsMinOrderByAggregateInput = {
    sheet_id?: SortOrder
    sheet_author_id?: SortOrder
    sheet_title?: SortOrder
    sheet_subject?: SortOrder
    sheet_filename?: SortOrder
    sheet_data_id?: SortOrder
    sheet_thumbnail_id?: SortOrder
    sheet_likes?: SortOrder
    sheet_dislikes?: SortOrder
    sheet_views?: SortOrder
    sheet_date_posted?: SortOrder
  }

  export type sheetsSumOrderByAggregateInput = {
    sheet_likes?: SortOrder
    sheet_dislikes?: SortOrder
    sheet_views?: SortOrder
  }

  export type sheets_dataCountOrderByAggregateInput = {
    sheet_data_id?: SortOrder
    sheet_data?: SortOrder
  }

  export type sheets_dataMaxOrderByAggregateInput = {
    sheet_data_id?: SortOrder
    sheet_data?: SortOrder
  }

  export type sheets_dataMinOrderByAggregateInput = {
    sheet_data_id?: SortOrder
    sheet_data?: SortOrder
  }

  export type sheets_thumbnailsCountOrderByAggregateInput = {
    sheet_thumbnail_id?: SortOrder
    sheet_thumbnail_data?: SortOrder
    sheet_thumbnail_filename?: SortOrder
    sheet_thumbnail_description?: SortOrder
  }

  export type sheets_thumbnailsMaxOrderByAggregateInput = {
    sheet_thumbnail_id?: SortOrder
    sheet_thumbnail_data?: SortOrder
    sheet_thumbnail_filename?: SortOrder
    sheet_thumbnail_description?: SortOrder
  }

  export type sheets_thumbnailsMinOrderByAggregateInput = {
    sheet_thumbnail_id?: SortOrder
    sheet_thumbnail_data?: SortOrder
    sheet_thumbnail_filename?: SortOrder
    sheet_thumbnail_description?: SortOrder
  }

  export type Tables_picturesNullableRelationFilter = {
    is?: tables_picturesWhereInput | null
    isNot?: tables_picturesWhereInput | null
  }

  export type tablesCountOrderByAggregateInput = {
    table_id?: SortOrder
    table_name?: SortOrder
    table_creation_date?: SortOrder
    last_message?: SortOrder
    last_message_date?: SortOrder
    tables_pictures_id?: SortOrder
  }

  export type tablesMaxOrderByAggregateInput = {
    table_id?: SortOrder
    table_name?: SortOrder
    table_creation_date?: SortOrder
    last_message?: SortOrder
    last_message_date?: SortOrder
    tables_pictures_id?: SortOrder
  }

  export type tablesMinOrderByAggregateInput = {
    table_id?: SortOrder
    table_name?: SortOrder
    table_creation_date?: SortOrder
    last_message?: SortOrder
    last_message_date?: SortOrder
    tables_pictures_id?: SortOrder
  }

  export type TablesRelationFilter = {
    is?: tablesWhereInput
    isNot?: tablesWhereInput
  }

  export type tables_membersTable_idMember_idCompoundUniqueInput = {
    table_id: string
    member_id: string
  }

  export type tables_membersCountOrderByAggregateInput = {
    tables_members_id?: SortOrder
    table_id?: SortOrder
    member_id?: SortOrder
    table_position?: SortOrder
    live?: SortOrder
  }

  export type tables_membersAvgOrderByAggregateInput = {
    table_position?: SortOrder
    live?: SortOrder
  }

  export type tables_membersMaxOrderByAggregateInput = {
    tables_members_id?: SortOrder
    table_id?: SortOrder
    member_id?: SortOrder
    table_position?: SortOrder
    live?: SortOrder
  }

  export type tables_membersMinOrderByAggregateInput = {
    tables_members_id?: SortOrder
    table_id?: SortOrder
    member_id?: SortOrder
    table_position?: SortOrder
    live?: SortOrder
  }

  export type tables_membersSumOrderByAggregateInput = {
    table_position?: SortOrder
    live?: SortOrder
  }

  export type tables_messages_logsCountOrderByAggregateInput = {
    tables_messages_logs_id?: SortOrder
    table_id?: SortOrder
    entity_id?: SortOrder
    message?: SortOrder
    message_date?: SortOrder
  }

  export type tables_messages_logsMaxOrderByAggregateInput = {
    tables_messages_logs_id?: SortOrder
    table_id?: SortOrder
    entity_id?: SortOrder
    message?: SortOrder
    message_date?: SortOrder
  }

  export type tables_messages_logsMinOrderByAggregateInput = {
    tables_messages_logs_id?: SortOrder
    table_id?: SortOrder
    entity_id?: SortOrder
    message?: SortOrder
    message_date?: SortOrder
  }

  export type TablesListRelationFilter = {
    every?: tablesWhereInput
    some?: tablesWhereInput
    none?: tablesWhereInput
  }

  export type tablesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tables_picturesCountOrderByAggregateInput = {
    tables_pictures_id?: SortOrder
    table_picture_data?: SortOrder
    table_picture_filename?: SortOrder
  }

  export type tables_picturesMaxOrderByAggregateInput = {
    tables_pictures_id?: SortOrder
    table_picture_data?: SortOrder
    table_picture_filename?: SortOrder
  }

  export type tables_picturesMinOrderByAggregateInput = {
    tables_pictures_id?: SortOrder
    table_picture_data?: SortOrder
    table_picture_filename?: SortOrder
  }

  export type Tables_tabletops_dataNullableRelationFilter = {
    is?: tables_tabletops_dataWhereInput | null
    isNot?: tables_tabletops_dataWhereInput | null
  }

  export type tables_tabletopsCountOrderByAggregateInput = {
    tables_tabletops_id?: SortOrder
    table_id?: SortOrder
    creator_id?: SortOrder
    tables_tabletops_data_id?: SortOrder
    type?: SortOrder
    content_date_posted?: SortOrder
    content_x_position?: SortOrder
    content_y_position?: SortOrder
    content_rotation?: SortOrder
    content_filename?: SortOrder
  }

  export type tables_tabletopsAvgOrderByAggregateInput = {
    type?: SortOrder
    content_x_position?: SortOrder
    content_y_position?: SortOrder
    content_rotation?: SortOrder
  }

  export type tables_tabletopsMaxOrderByAggregateInput = {
    tables_tabletops_id?: SortOrder
    table_id?: SortOrder
    creator_id?: SortOrder
    tables_tabletops_data_id?: SortOrder
    type?: SortOrder
    content_date_posted?: SortOrder
    content_x_position?: SortOrder
    content_y_position?: SortOrder
    content_rotation?: SortOrder
    content_filename?: SortOrder
  }

  export type tables_tabletopsMinOrderByAggregateInput = {
    tables_tabletops_id?: SortOrder
    table_id?: SortOrder
    creator_id?: SortOrder
    tables_tabletops_data_id?: SortOrder
    type?: SortOrder
    content_date_posted?: SortOrder
    content_x_position?: SortOrder
    content_y_position?: SortOrder
    content_rotation?: SortOrder
    content_filename?: SortOrder
  }

  export type tables_tabletopsSumOrderByAggregateInput = {
    type?: SortOrder
    content_x_position?: SortOrder
    content_y_position?: SortOrder
    content_rotation?: SortOrder
  }

  export type tables_tabletops_dataCountOrderByAggregateInput = {
    tables_tabletops_data_id?: SortOrder
    tables_tabletops_data?: SortOrder
  }

  export type tables_tabletops_dataMaxOrderByAggregateInput = {
    tables_tabletops_data_id?: SortOrder
    tables_tabletops_data?: SortOrder
  }

  export type tables_tabletops_dataMinOrderByAggregateInput = {
    tables_tabletops_data_id?: SortOrder
    tables_tabletops_data?: SortOrder
  }

  export type IndividualsNullableRelationFilter = {
    is?: individualsWhereInput | null
    isNot?: individualsWhereInput | null
  }

  export type user_credentialsCountOrderByAggregateInput = {
    user_id?: SortOrder
    username?: SortOrder
    user_password?: SortOrder
    user_first_name?: SortOrder
    user_last_name?: SortOrder
    user_email?: SortOrder
    user_phone_number?: SortOrder
  }

  export type user_credentialsMaxOrderByAggregateInput = {
    user_id?: SortOrder
    username?: SortOrder
    user_password?: SortOrder
    user_first_name?: SortOrder
    user_last_name?: SortOrder
    user_email?: SortOrder
    user_phone_number?: SortOrder
  }

  export type user_credentialsMinOrderByAggregateInput = {
    user_id?: SortOrder
    username?: SortOrder
    user_password?: SortOrder
    user_first_name?: SortOrder
    user_last_name?: SortOrder
    user_email?: SortOrder
    user_phone_number?: SortOrder
  }

  export type Videos_dataRelationFilter = {
    is?: videos_dataWhereInput
    isNot?: videos_dataWhereInput
  }

  export type Videos_thumbnailsNullableRelationFilter = {
    is?: videos_thumbnailsWhereInput | null
    isNot?: videos_thumbnailsWhereInput | null
  }

  export type videosCountOrderByAggregateInput = {
    video_id?: SortOrder
    video_creator_id?: SortOrder
    video_title?: SortOrder
    video_description?: SortOrder
    video_filename?: SortOrder
    video_data_id?: SortOrder
    video_thumbnail_id?: SortOrder
    video_likes?: SortOrder
    video_dislikes?: SortOrder
    video_views?: SortOrder
    video_date_posted?: SortOrder
  }

  export type videosAvgOrderByAggregateInput = {
    video_likes?: SortOrder
    video_dislikes?: SortOrder
    video_views?: SortOrder
  }

  export type videosMaxOrderByAggregateInput = {
    video_id?: SortOrder
    video_creator_id?: SortOrder
    video_title?: SortOrder
    video_description?: SortOrder
    video_filename?: SortOrder
    video_data_id?: SortOrder
    video_thumbnail_id?: SortOrder
    video_likes?: SortOrder
    video_dislikes?: SortOrder
    video_views?: SortOrder
    video_date_posted?: SortOrder
  }

  export type videosMinOrderByAggregateInput = {
    video_id?: SortOrder
    video_creator_id?: SortOrder
    video_title?: SortOrder
    video_description?: SortOrder
    video_filename?: SortOrder
    video_data_id?: SortOrder
    video_thumbnail_id?: SortOrder
    video_likes?: SortOrder
    video_dislikes?: SortOrder
    video_views?: SortOrder
    video_date_posted?: SortOrder
  }

  export type videosSumOrderByAggregateInput = {
    video_likes?: SortOrder
    video_dislikes?: SortOrder
    video_views?: SortOrder
  }

  export type videos_dataCountOrderByAggregateInput = {
    video_data_id?: SortOrder
    video_data?: SortOrder
  }

  export type videos_dataMaxOrderByAggregateInput = {
    video_data_id?: SortOrder
    video_data?: SortOrder
  }

  export type videos_dataMinOrderByAggregateInput = {
    video_data_id?: SortOrder
    video_data?: SortOrder
  }

  export type videos_thumbnailsCountOrderByAggregateInput = {
    video_thumbnail_id?: SortOrder
    video_thumbnail_data?: SortOrder
    video_thumbnail_filename?: SortOrder
    video_thumbnail_description?: SortOrder
  }

  export type videos_thumbnailsMaxOrderByAggregateInput = {
    video_thumbnail_id?: SortOrder
    video_thumbnail_data?: SortOrder
    video_thumbnail_filename?: SortOrder
    video_thumbnail_description?: SortOrder
  }

  export type videos_thumbnailsMinOrderByAggregateInput = {
    video_thumbnail_id?: SortOrder
    video_thumbnail_data?: SortOrder
    video_thumbnail_filename?: SortOrder
    video_thumbnail_description?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type entitiesCreateNestedOneWithoutCollectionsInput = {
    create?: XOR<entitiesCreateWithoutCollectionsInput, entitiesUncheckedCreateWithoutCollectionsInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutCollectionsInput
    connect?: entitiesWhereUniqueInput
  }

  export type collections_contentCreateNestedManyWithoutCollectionsInput = {
    create?: XOR<collections_contentCreateWithoutCollectionsInput, collections_contentUncheckedCreateWithoutCollectionsInput> | collections_contentCreateWithoutCollectionsInput[] | collections_contentUncheckedCreateWithoutCollectionsInput[]
    connectOrCreate?: collections_contentCreateOrConnectWithoutCollectionsInput | collections_contentCreateOrConnectWithoutCollectionsInput[]
    createMany?: collections_contentCreateManyCollectionsInputEnvelope
    connect?: collections_contentWhereUniqueInput | collections_contentWhereUniqueInput[]
  }

  export type collections_contentUncheckedCreateNestedManyWithoutCollectionsInput = {
    create?: XOR<collections_contentCreateWithoutCollectionsInput, collections_contentUncheckedCreateWithoutCollectionsInput> | collections_contentCreateWithoutCollectionsInput[] | collections_contentUncheckedCreateWithoutCollectionsInput[]
    connectOrCreate?: collections_contentCreateOrConnectWithoutCollectionsInput | collections_contentCreateOrConnectWithoutCollectionsInput[]
    createMany?: collections_contentCreateManyCollectionsInputEnvelope
    connect?: collections_contentWhereUniqueInput | collections_contentWhereUniqueInput[]
  }

  export type entitiesUpdateOneRequiredWithoutCollectionsNestedInput = {
    create?: XOR<entitiesCreateWithoutCollectionsInput, entitiesUncheckedCreateWithoutCollectionsInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutCollectionsInput
    upsert?: entitiesUpsertWithoutCollectionsInput
    connect?: entitiesWhereUniqueInput
    update?: XOR<XOR<entitiesUpdateToOneWithWhereWithoutCollectionsInput, entitiesUpdateWithoutCollectionsInput>, entitiesUncheckedUpdateWithoutCollectionsInput>
  }

  export type collections_contentUpdateManyWithoutCollectionsNestedInput = {
    create?: XOR<collections_contentCreateWithoutCollectionsInput, collections_contentUncheckedCreateWithoutCollectionsInput> | collections_contentCreateWithoutCollectionsInput[] | collections_contentUncheckedCreateWithoutCollectionsInput[]
    connectOrCreate?: collections_contentCreateOrConnectWithoutCollectionsInput | collections_contentCreateOrConnectWithoutCollectionsInput[]
    upsert?: collections_contentUpsertWithWhereUniqueWithoutCollectionsInput | collections_contentUpsertWithWhereUniqueWithoutCollectionsInput[]
    createMany?: collections_contentCreateManyCollectionsInputEnvelope
    set?: collections_contentWhereUniqueInput | collections_contentWhereUniqueInput[]
    disconnect?: collections_contentWhereUniqueInput | collections_contentWhereUniqueInput[]
    delete?: collections_contentWhereUniqueInput | collections_contentWhereUniqueInput[]
    connect?: collections_contentWhereUniqueInput | collections_contentWhereUniqueInput[]
    update?: collections_contentUpdateWithWhereUniqueWithoutCollectionsInput | collections_contentUpdateWithWhereUniqueWithoutCollectionsInput[]
    updateMany?: collections_contentUpdateManyWithWhereWithoutCollectionsInput | collections_contentUpdateManyWithWhereWithoutCollectionsInput[]
    deleteMany?: collections_contentScalarWhereInput | collections_contentScalarWhereInput[]
  }

  export type collections_contentUncheckedUpdateManyWithoutCollectionsNestedInput = {
    create?: XOR<collections_contentCreateWithoutCollectionsInput, collections_contentUncheckedCreateWithoutCollectionsInput> | collections_contentCreateWithoutCollectionsInput[] | collections_contentUncheckedCreateWithoutCollectionsInput[]
    connectOrCreate?: collections_contentCreateOrConnectWithoutCollectionsInput | collections_contentCreateOrConnectWithoutCollectionsInput[]
    upsert?: collections_contentUpsertWithWhereUniqueWithoutCollectionsInput | collections_contentUpsertWithWhereUniqueWithoutCollectionsInput[]
    createMany?: collections_contentCreateManyCollectionsInputEnvelope
    set?: collections_contentWhereUniqueInput | collections_contentWhereUniqueInput[]
    disconnect?: collections_contentWhereUniqueInput | collections_contentWhereUniqueInput[]
    delete?: collections_contentWhereUniqueInput | collections_contentWhereUniqueInput[]
    connect?: collections_contentWhereUniqueInput | collections_contentWhereUniqueInput[]
    update?: collections_contentUpdateWithWhereUniqueWithoutCollectionsInput | collections_contentUpdateWithWhereUniqueWithoutCollectionsInput[]
    updateMany?: collections_contentUpdateManyWithWhereWithoutCollectionsInput | collections_contentUpdateManyWithWhereWithoutCollectionsInput[]
    deleteMany?: collections_contentScalarWhereInput | collections_contentScalarWhereInput[]
  }

  export type collectionsCreateNestedOneWithoutCollections_contentInput = {
    create?: XOR<collectionsCreateWithoutCollections_contentInput, collectionsUncheckedCreateWithoutCollections_contentInput>
    connectOrCreate?: collectionsCreateOrConnectWithoutCollections_contentInput
    connect?: collectionsWhereUniqueInput
  }

  export type contentCreateNestedOneWithoutCollections_contentInput = {
    create?: XOR<contentCreateWithoutCollections_contentInput, contentUncheckedCreateWithoutCollections_contentInput>
    connectOrCreate?: contentCreateOrConnectWithoutCollections_contentInput
    connect?: contentWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type collectionsUpdateOneRequiredWithoutCollections_contentNestedInput = {
    create?: XOR<collectionsCreateWithoutCollections_contentInput, collectionsUncheckedCreateWithoutCollections_contentInput>
    connectOrCreate?: collectionsCreateOrConnectWithoutCollections_contentInput
    upsert?: collectionsUpsertWithoutCollections_contentInput
    connect?: collectionsWhereUniqueInput
    update?: XOR<XOR<collectionsUpdateToOneWithWhereWithoutCollections_contentInput, collectionsUpdateWithoutCollections_contentInput>, collectionsUncheckedUpdateWithoutCollections_contentInput>
  }

  export type contentUpdateOneRequiredWithoutCollections_contentNestedInput = {
    create?: XOR<contentCreateWithoutCollections_contentInput, contentUncheckedCreateWithoutCollections_contentInput>
    connectOrCreate?: contentCreateOrConnectWithoutCollections_contentInput
    upsert?: contentUpsertWithoutCollections_contentInput
    connect?: contentWhereUniqueInput
    update?: XOR<XOR<contentUpdateToOneWithWhereWithoutCollections_contentInput, contentUpdateWithoutCollections_contentInput>, contentUncheckedUpdateWithoutCollections_contentInput>
  }

  export type entitiesCreateNestedOneWithoutContacts_contacts_contact_id_rootToentitiesInput = {
    create?: XOR<entitiesCreateWithoutContacts_contacts_contact_id_rootToentitiesInput, entitiesUncheckedCreateWithoutContacts_contacts_contact_id_rootToentitiesInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutContacts_contacts_contact_id_rootToentitiesInput
    connect?: entitiesWhereUniqueInput
  }

  export type entitiesCreateNestedOneWithoutContacts_contacts_contact_id_targetToentitiesInput = {
    create?: XOR<entitiesCreateWithoutContacts_contacts_contact_id_targetToentitiesInput, entitiesUncheckedCreateWithoutContacts_contacts_contact_id_targetToentitiesInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutContacts_contacts_contact_id_targetToentitiesInput
    connect?: entitiesWhereUniqueInput
  }

  export type contacts_picturesCreateNestedOneWithoutContactsInput = {
    create?: XOR<contacts_picturesCreateWithoutContactsInput, contacts_picturesUncheckedCreateWithoutContactsInput>
    connectOrCreate?: contacts_picturesCreateOrConnectWithoutContactsInput
    connect?: contacts_picturesWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type entitiesUpdateOneRequiredWithoutContacts_contacts_contact_id_rootToentitiesNestedInput = {
    create?: XOR<entitiesCreateWithoutContacts_contacts_contact_id_rootToentitiesInput, entitiesUncheckedCreateWithoutContacts_contacts_contact_id_rootToentitiesInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutContacts_contacts_contact_id_rootToentitiesInput
    upsert?: entitiesUpsertWithoutContacts_contacts_contact_id_rootToentitiesInput
    connect?: entitiesWhereUniqueInput
    update?: XOR<XOR<entitiesUpdateToOneWithWhereWithoutContacts_contacts_contact_id_rootToentitiesInput, entitiesUpdateWithoutContacts_contacts_contact_id_rootToentitiesInput>, entitiesUncheckedUpdateWithoutContacts_contacts_contact_id_rootToentitiesInput>
  }

  export type entitiesUpdateOneRequiredWithoutContacts_contacts_contact_id_targetToentitiesNestedInput = {
    create?: XOR<entitiesCreateWithoutContacts_contacts_contact_id_targetToentitiesInput, entitiesUncheckedCreateWithoutContacts_contacts_contact_id_targetToentitiesInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutContacts_contacts_contact_id_targetToentitiesInput
    upsert?: entitiesUpsertWithoutContacts_contacts_contact_id_targetToentitiesInput
    connect?: entitiesWhereUniqueInput
    update?: XOR<XOR<entitiesUpdateToOneWithWhereWithoutContacts_contacts_contact_id_targetToentitiesInput, entitiesUpdateWithoutContacts_contacts_contact_id_targetToentitiesInput>, entitiesUncheckedUpdateWithoutContacts_contacts_contact_id_targetToentitiesInput>
  }

  export type contacts_picturesUpdateOneWithoutContactsNestedInput = {
    create?: XOR<contacts_picturesCreateWithoutContactsInput, contacts_picturesUncheckedCreateWithoutContactsInput>
    connectOrCreate?: contacts_picturesCreateOrConnectWithoutContactsInput
    upsert?: contacts_picturesUpsertWithoutContactsInput
    disconnect?: contacts_picturesWhereInput | boolean
    delete?: contacts_picturesWhereInput | boolean
    connect?: contacts_picturesWhereUniqueInput
    update?: XOR<XOR<contacts_picturesUpdateToOneWithWhereWithoutContactsInput, contacts_picturesUpdateWithoutContactsInput>, contacts_picturesUncheckedUpdateWithoutContactsInput>
  }

  export type contactsCreateNestedManyWithoutContacts_picturesInput = {
    create?: XOR<contactsCreateWithoutContacts_picturesInput, contactsUncheckedCreateWithoutContacts_picturesInput> | contactsCreateWithoutContacts_picturesInput[] | contactsUncheckedCreateWithoutContacts_picturesInput[]
    connectOrCreate?: contactsCreateOrConnectWithoutContacts_picturesInput | contactsCreateOrConnectWithoutContacts_picturesInput[]
    createMany?: contactsCreateManyContacts_picturesInputEnvelope
    connect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
  }

  export type contactsUncheckedCreateNestedManyWithoutContacts_picturesInput = {
    create?: XOR<contactsCreateWithoutContacts_picturesInput, contactsUncheckedCreateWithoutContacts_picturesInput> | contactsCreateWithoutContacts_picturesInput[] | contactsUncheckedCreateWithoutContacts_picturesInput[]
    connectOrCreate?: contactsCreateOrConnectWithoutContacts_picturesInput | contactsCreateOrConnectWithoutContacts_picturesInput[]
    createMany?: contactsCreateManyContacts_picturesInputEnvelope
    connect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Buffer
  }

  export type contactsUpdateManyWithoutContacts_picturesNestedInput = {
    create?: XOR<contactsCreateWithoutContacts_picturesInput, contactsUncheckedCreateWithoutContacts_picturesInput> | contactsCreateWithoutContacts_picturesInput[] | contactsUncheckedCreateWithoutContacts_picturesInput[]
    connectOrCreate?: contactsCreateOrConnectWithoutContacts_picturesInput | contactsCreateOrConnectWithoutContacts_picturesInput[]
    upsert?: contactsUpsertWithWhereUniqueWithoutContacts_picturesInput | contactsUpsertWithWhereUniqueWithoutContacts_picturesInput[]
    createMany?: contactsCreateManyContacts_picturesInputEnvelope
    set?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    disconnect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    delete?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    connect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    update?: contactsUpdateWithWhereUniqueWithoutContacts_picturesInput | contactsUpdateWithWhereUniqueWithoutContacts_picturesInput[]
    updateMany?: contactsUpdateManyWithWhereWithoutContacts_picturesInput | contactsUpdateManyWithWhereWithoutContacts_picturesInput[]
    deleteMany?: contactsScalarWhereInput | contactsScalarWhereInput[]
  }

  export type contactsUncheckedUpdateManyWithoutContacts_picturesNestedInput = {
    create?: XOR<contactsCreateWithoutContacts_picturesInput, contactsUncheckedCreateWithoutContacts_picturesInput> | contactsCreateWithoutContacts_picturesInput[] | contactsUncheckedCreateWithoutContacts_picturesInput[]
    connectOrCreate?: contactsCreateOrConnectWithoutContacts_picturesInput | contactsCreateOrConnectWithoutContacts_picturesInput[]
    upsert?: contactsUpsertWithWhereUniqueWithoutContacts_picturesInput | contactsUpsertWithWhereUniqueWithoutContacts_picturesInput[]
    createMany?: contactsCreateManyContacts_picturesInputEnvelope
    set?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    disconnect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    delete?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    connect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    update?: contactsUpdateWithWhereUniqueWithoutContacts_picturesInput | contactsUpdateWithWhereUniqueWithoutContacts_picturesInput[]
    updateMany?: contactsUpdateManyWithWhereWithoutContacts_picturesInput | contactsUpdateManyWithWhereWithoutContacts_picturesInput[]
    deleteMany?: contactsScalarWhereInput | contactsScalarWhereInput[]
  }

  export type collections_contentCreateNestedManyWithoutContentInput = {
    create?: XOR<collections_contentCreateWithoutContentInput, collections_contentUncheckedCreateWithoutContentInput> | collections_contentCreateWithoutContentInput[] | collections_contentUncheckedCreateWithoutContentInput[]
    connectOrCreate?: collections_contentCreateOrConnectWithoutContentInput | collections_contentCreateOrConnectWithoutContentInput[]
    createMany?: collections_contentCreateManyContentInputEnvelope
    connect?: collections_contentWhereUniqueInput | collections_contentWhereUniqueInput[]
  }

  export type entities_contentCreateNestedManyWithoutContentInput = {
    create?: XOR<entities_contentCreateWithoutContentInput, entities_contentUncheckedCreateWithoutContentInput> | entities_contentCreateWithoutContentInput[] | entities_contentUncheckedCreateWithoutContentInput[]
    connectOrCreate?: entities_contentCreateOrConnectWithoutContentInput | entities_contentCreateOrConnectWithoutContentInput[]
    createMany?: entities_contentCreateManyContentInputEnvelope
    connect?: entities_contentWhereUniqueInput | entities_contentWhereUniqueInput[]
  }

  export type entities_dislikesCreateNestedManyWithoutContentInput = {
    create?: XOR<entities_dislikesCreateWithoutContentInput, entities_dislikesUncheckedCreateWithoutContentInput> | entities_dislikesCreateWithoutContentInput[] | entities_dislikesUncheckedCreateWithoutContentInput[]
    connectOrCreate?: entities_dislikesCreateOrConnectWithoutContentInput | entities_dislikesCreateOrConnectWithoutContentInput[]
    createMany?: entities_dislikesCreateManyContentInputEnvelope
    connect?: entities_dislikesWhereUniqueInput | entities_dislikesWhereUniqueInput[]
  }

  export type entities_likesCreateNestedManyWithoutContentInput = {
    create?: XOR<entities_likesCreateWithoutContentInput, entities_likesUncheckedCreateWithoutContentInput> | entities_likesCreateWithoutContentInput[] | entities_likesUncheckedCreateWithoutContentInput[]
    connectOrCreate?: entities_likesCreateOrConnectWithoutContentInput | entities_likesCreateOrConnectWithoutContentInput[]
    createMany?: entities_likesCreateManyContentInputEnvelope
    connect?: entities_likesWhereUniqueInput | entities_likesWhereUniqueInput[]
  }

  export type collections_contentUncheckedCreateNestedManyWithoutContentInput = {
    create?: XOR<collections_contentCreateWithoutContentInput, collections_contentUncheckedCreateWithoutContentInput> | collections_contentCreateWithoutContentInput[] | collections_contentUncheckedCreateWithoutContentInput[]
    connectOrCreate?: collections_contentCreateOrConnectWithoutContentInput | collections_contentCreateOrConnectWithoutContentInput[]
    createMany?: collections_contentCreateManyContentInputEnvelope
    connect?: collections_contentWhereUniqueInput | collections_contentWhereUniqueInput[]
  }

  export type entities_contentUncheckedCreateNestedManyWithoutContentInput = {
    create?: XOR<entities_contentCreateWithoutContentInput, entities_contentUncheckedCreateWithoutContentInput> | entities_contentCreateWithoutContentInput[] | entities_contentUncheckedCreateWithoutContentInput[]
    connectOrCreate?: entities_contentCreateOrConnectWithoutContentInput | entities_contentCreateOrConnectWithoutContentInput[]
    createMany?: entities_contentCreateManyContentInputEnvelope
    connect?: entities_contentWhereUniqueInput | entities_contentWhereUniqueInput[]
  }

  export type entities_dislikesUncheckedCreateNestedManyWithoutContentInput = {
    create?: XOR<entities_dislikesCreateWithoutContentInput, entities_dislikesUncheckedCreateWithoutContentInput> | entities_dislikesCreateWithoutContentInput[] | entities_dislikesUncheckedCreateWithoutContentInput[]
    connectOrCreate?: entities_dislikesCreateOrConnectWithoutContentInput | entities_dislikesCreateOrConnectWithoutContentInput[]
    createMany?: entities_dislikesCreateManyContentInputEnvelope
    connect?: entities_dislikesWhereUniqueInput | entities_dislikesWhereUniqueInput[]
  }

  export type entities_likesUncheckedCreateNestedManyWithoutContentInput = {
    create?: XOR<entities_likesCreateWithoutContentInput, entities_likesUncheckedCreateWithoutContentInput> | entities_likesCreateWithoutContentInput[] | entities_likesUncheckedCreateWithoutContentInput[]
    connectOrCreate?: entities_likesCreateOrConnectWithoutContentInput | entities_likesCreateOrConnectWithoutContentInput[]
    createMany?: entities_likesCreateManyContentInputEnvelope
    connect?: entities_likesWhereUniqueInput | entities_likesWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type collections_contentUpdateManyWithoutContentNestedInput = {
    create?: XOR<collections_contentCreateWithoutContentInput, collections_contentUncheckedCreateWithoutContentInput> | collections_contentCreateWithoutContentInput[] | collections_contentUncheckedCreateWithoutContentInput[]
    connectOrCreate?: collections_contentCreateOrConnectWithoutContentInput | collections_contentCreateOrConnectWithoutContentInput[]
    upsert?: collections_contentUpsertWithWhereUniqueWithoutContentInput | collections_contentUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: collections_contentCreateManyContentInputEnvelope
    set?: collections_contentWhereUniqueInput | collections_contentWhereUniqueInput[]
    disconnect?: collections_contentWhereUniqueInput | collections_contentWhereUniqueInput[]
    delete?: collections_contentWhereUniqueInput | collections_contentWhereUniqueInput[]
    connect?: collections_contentWhereUniqueInput | collections_contentWhereUniqueInput[]
    update?: collections_contentUpdateWithWhereUniqueWithoutContentInput | collections_contentUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: collections_contentUpdateManyWithWhereWithoutContentInput | collections_contentUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: collections_contentScalarWhereInput | collections_contentScalarWhereInput[]
  }

  export type entities_contentUpdateManyWithoutContentNestedInput = {
    create?: XOR<entities_contentCreateWithoutContentInput, entities_contentUncheckedCreateWithoutContentInput> | entities_contentCreateWithoutContentInput[] | entities_contentUncheckedCreateWithoutContentInput[]
    connectOrCreate?: entities_contentCreateOrConnectWithoutContentInput | entities_contentCreateOrConnectWithoutContentInput[]
    upsert?: entities_contentUpsertWithWhereUniqueWithoutContentInput | entities_contentUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: entities_contentCreateManyContentInputEnvelope
    set?: entities_contentWhereUniqueInput | entities_contentWhereUniqueInput[]
    disconnect?: entities_contentWhereUniqueInput | entities_contentWhereUniqueInput[]
    delete?: entities_contentWhereUniqueInput | entities_contentWhereUniqueInput[]
    connect?: entities_contentWhereUniqueInput | entities_contentWhereUniqueInput[]
    update?: entities_contentUpdateWithWhereUniqueWithoutContentInput | entities_contentUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: entities_contentUpdateManyWithWhereWithoutContentInput | entities_contentUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: entities_contentScalarWhereInput | entities_contentScalarWhereInput[]
  }

  export type entities_dislikesUpdateManyWithoutContentNestedInput = {
    create?: XOR<entities_dislikesCreateWithoutContentInput, entities_dislikesUncheckedCreateWithoutContentInput> | entities_dislikesCreateWithoutContentInput[] | entities_dislikesUncheckedCreateWithoutContentInput[]
    connectOrCreate?: entities_dislikesCreateOrConnectWithoutContentInput | entities_dislikesCreateOrConnectWithoutContentInput[]
    upsert?: entities_dislikesUpsertWithWhereUniqueWithoutContentInput | entities_dislikesUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: entities_dislikesCreateManyContentInputEnvelope
    set?: entities_dislikesWhereUniqueInput | entities_dislikesWhereUniqueInput[]
    disconnect?: entities_dislikesWhereUniqueInput | entities_dislikesWhereUniqueInput[]
    delete?: entities_dislikesWhereUniqueInput | entities_dislikesWhereUniqueInput[]
    connect?: entities_dislikesWhereUniqueInput | entities_dislikesWhereUniqueInput[]
    update?: entities_dislikesUpdateWithWhereUniqueWithoutContentInput | entities_dislikesUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: entities_dislikesUpdateManyWithWhereWithoutContentInput | entities_dislikesUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: entities_dislikesScalarWhereInput | entities_dislikesScalarWhereInput[]
  }

  export type entities_likesUpdateManyWithoutContentNestedInput = {
    create?: XOR<entities_likesCreateWithoutContentInput, entities_likesUncheckedCreateWithoutContentInput> | entities_likesCreateWithoutContentInput[] | entities_likesUncheckedCreateWithoutContentInput[]
    connectOrCreate?: entities_likesCreateOrConnectWithoutContentInput | entities_likesCreateOrConnectWithoutContentInput[]
    upsert?: entities_likesUpsertWithWhereUniqueWithoutContentInput | entities_likesUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: entities_likesCreateManyContentInputEnvelope
    set?: entities_likesWhereUniqueInput | entities_likesWhereUniqueInput[]
    disconnect?: entities_likesWhereUniqueInput | entities_likesWhereUniqueInput[]
    delete?: entities_likesWhereUniqueInput | entities_likesWhereUniqueInput[]
    connect?: entities_likesWhereUniqueInput | entities_likesWhereUniqueInput[]
    update?: entities_likesUpdateWithWhereUniqueWithoutContentInput | entities_likesUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: entities_likesUpdateManyWithWhereWithoutContentInput | entities_likesUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: entities_likesScalarWhereInput | entities_likesScalarWhereInput[]
  }

  export type collections_contentUncheckedUpdateManyWithoutContentNestedInput = {
    create?: XOR<collections_contentCreateWithoutContentInput, collections_contentUncheckedCreateWithoutContentInput> | collections_contentCreateWithoutContentInput[] | collections_contentUncheckedCreateWithoutContentInput[]
    connectOrCreate?: collections_contentCreateOrConnectWithoutContentInput | collections_contentCreateOrConnectWithoutContentInput[]
    upsert?: collections_contentUpsertWithWhereUniqueWithoutContentInput | collections_contentUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: collections_contentCreateManyContentInputEnvelope
    set?: collections_contentWhereUniqueInput | collections_contentWhereUniqueInput[]
    disconnect?: collections_contentWhereUniqueInput | collections_contentWhereUniqueInput[]
    delete?: collections_contentWhereUniqueInput | collections_contentWhereUniqueInput[]
    connect?: collections_contentWhereUniqueInput | collections_contentWhereUniqueInput[]
    update?: collections_contentUpdateWithWhereUniqueWithoutContentInput | collections_contentUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: collections_contentUpdateManyWithWhereWithoutContentInput | collections_contentUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: collections_contentScalarWhereInput | collections_contentScalarWhereInput[]
  }

  export type entities_contentUncheckedUpdateManyWithoutContentNestedInput = {
    create?: XOR<entities_contentCreateWithoutContentInput, entities_contentUncheckedCreateWithoutContentInput> | entities_contentCreateWithoutContentInput[] | entities_contentUncheckedCreateWithoutContentInput[]
    connectOrCreate?: entities_contentCreateOrConnectWithoutContentInput | entities_contentCreateOrConnectWithoutContentInput[]
    upsert?: entities_contentUpsertWithWhereUniqueWithoutContentInput | entities_contentUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: entities_contentCreateManyContentInputEnvelope
    set?: entities_contentWhereUniqueInput | entities_contentWhereUniqueInput[]
    disconnect?: entities_contentWhereUniqueInput | entities_contentWhereUniqueInput[]
    delete?: entities_contentWhereUniqueInput | entities_contentWhereUniqueInput[]
    connect?: entities_contentWhereUniqueInput | entities_contentWhereUniqueInput[]
    update?: entities_contentUpdateWithWhereUniqueWithoutContentInput | entities_contentUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: entities_contentUpdateManyWithWhereWithoutContentInput | entities_contentUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: entities_contentScalarWhereInput | entities_contentScalarWhereInput[]
  }

  export type entities_dislikesUncheckedUpdateManyWithoutContentNestedInput = {
    create?: XOR<entities_dislikesCreateWithoutContentInput, entities_dislikesUncheckedCreateWithoutContentInput> | entities_dislikesCreateWithoutContentInput[] | entities_dislikesUncheckedCreateWithoutContentInput[]
    connectOrCreate?: entities_dislikesCreateOrConnectWithoutContentInput | entities_dislikesCreateOrConnectWithoutContentInput[]
    upsert?: entities_dislikesUpsertWithWhereUniqueWithoutContentInput | entities_dislikesUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: entities_dislikesCreateManyContentInputEnvelope
    set?: entities_dislikesWhereUniqueInput | entities_dislikesWhereUniqueInput[]
    disconnect?: entities_dislikesWhereUniqueInput | entities_dislikesWhereUniqueInput[]
    delete?: entities_dislikesWhereUniqueInput | entities_dislikesWhereUniqueInput[]
    connect?: entities_dislikesWhereUniqueInput | entities_dislikesWhereUniqueInput[]
    update?: entities_dislikesUpdateWithWhereUniqueWithoutContentInput | entities_dislikesUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: entities_dislikesUpdateManyWithWhereWithoutContentInput | entities_dislikesUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: entities_dislikesScalarWhereInput | entities_dislikesScalarWhereInput[]
  }

  export type entities_likesUncheckedUpdateManyWithoutContentNestedInput = {
    create?: XOR<entities_likesCreateWithoutContentInput, entities_likesUncheckedCreateWithoutContentInput> | entities_likesCreateWithoutContentInput[] | entities_likesUncheckedCreateWithoutContentInput[]
    connectOrCreate?: entities_likesCreateOrConnectWithoutContentInput | entities_likesCreateOrConnectWithoutContentInput[]
    upsert?: entities_likesUpsertWithWhereUniqueWithoutContentInput | entities_likesUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: entities_likesCreateManyContentInputEnvelope
    set?: entities_likesWhereUniqueInput | entities_likesWhereUniqueInput[]
    disconnect?: entities_likesWhereUniqueInput | entities_likesWhereUniqueInput[]
    delete?: entities_likesWhereUniqueInput | entities_likesWhereUniqueInput[]
    connect?: entities_likesWhereUniqueInput | entities_likesWhereUniqueInput[]
    update?: entities_likesUpdateWithWhereUniqueWithoutContentInput | entities_likesUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: entities_likesUpdateManyWithWhereWithoutContentInput | entities_likesUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: entities_likesScalarWhereInput | entities_likesScalarWhereInput[]
  }

  export type conversations_picturesCreateNestedOneWithoutConversationsInput = {
    create?: XOR<conversations_picturesCreateWithoutConversationsInput, conversations_picturesUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: conversations_picturesCreateOrConnectWithoutConversationsInput
    connect?: conversations_picturesWhereUniqueInput
  }

  export type conversations_membersCreateNestedManyWithoutConversationsInput = {
    create?: XOR<conversations_membersCreateWithoutConversationsInput, conversations_membersUncheckedCreateWithoutConversationsInput> | conversations_membersCreateWithoutConversationsInput[] | conversations_membersUncheckedCreateWithoutConversationsInput[]
    connectOrCreate?: conversations_membersCreateOrConnectWithoutConversationsInput | conversations_membersCreateOrConnectWithoutConversationsInput[]
    createMany?: conversations_membersCreateManyConversationsInputEnvelope
    connect?: conversations_membersWhereUniqueInput | conversations_membersWhereUniqueInput[]
  }

  export type conversations_messages_logsCreateNestedManyWithoutConversationsInput = {
    create?: XOR<conversations_messages_logsCreateWithoutConversationsInput, conversations_messages_logsUncheckedCreateWithoutConversationsInput> | conversations_messages_logsCreateWithoutConversationsInput[] | conversations_messages_logsUncheckedCreateWithoutConversationsInput[]
    connectOrCreate?: conversations_messages_logsCreateOrConnectWithoutConversationsInput | conversations_messages_logsCreateOrConnectWithoutConversationsInput[]
    createMany?: conversations_messages_logsCreateManyConversationsInputEnvelope
    connect?: conversations_messages_logsWhereUniqueInput | conversations_messages_logsWhereUniqueInput[]
  }

  export type conversations_membersUncheckedCreateNestedManyWithoutConversationsInput = {
    create?: XOR<conversations_membersCreateWithoutConversationsInput, conversations_membersUncheckedCreateWithoutConversationsInput> | conversations_membersCreateWithoutConversationsInput[] | conversations_membersUncheckedCreateWithoutConversationsInput[]
    connectOrCreate?: conversations_membersCreateOrConnectWithoutConversationsInput | conversations_membersCreateOrConnectWithoutConversationsInput[]
    createMany?: conversations_membersCreateManyConversationsInputEnvelope
    connect?: conversations_membersWhereUniqueInput | conversations_membersWhereUniqueInput[]
  }

  export type conversations_messages_logsUncheckedCreateNestedManyWithoutConversationsInput = {
    create?: XOR<conversations_messages_logsCreateWithoutConversationsInput, conversations_messages_logsUncheckedCreateWithoutConversationsInput> | conversations_messages_logsCreateWithoutConversationsInput[] | conversations_messages_logsUncheckedCreateWithoutConversationsInput[]
    connectOrCreate?: conversations_messages_logsCreateOrConnectWithoutConversationsInput | conversations_messages_logsCreateOrConnectWithoutConversationsInput[]
    createMany?: conversations_messages_logsCreateManyConversationsInputEnvelope
    connect?: conversations_messages_logsWhereUniqueInput | conversations_messages_logsWhereUniqueInput[]
  }

  export type conversations_picturesUpdateOneWithoutConversationsNestedInput = {
    create?: XOR<conversations_picturesCreateWithoutConversationsInput, conversations_picturesUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: conversations_picturesCreateOrConnectWithoutConversationsInput
    upsert?: conversations_picturesUpsertWithoutConversationsInput
    disconnect?: conversations_picturesWhereInput | boolean
    delete?: conversations_picturesWhereInput | boolean
    connect?: conversations_picturesWhereUniqueInput
    update?: XOR<XOR<conversations_picturesUpdateToOneWithWhereWithoutConversationsInput, conversations_picturesUpdateWithoutConversationsInput>, conversations_picturesUncheckedUpdateWithoutConversationsInput>
  }

  export type conversations_membersUpdateManyWithoutConversationsNestedInput = {
    create?: XOR<conversations_membersCreateWithoutConversationsInput, conversations_membersUncheckedCreateWithoutConversationsInput> | conversations_membersCreateWithoutConversationsInput[] | conversations_membersUncheckedCreateWithoutConversationsInput[]
    connectOrCreate?: conversations_membersCreateOrConnectWithoutConversationsInput | conversations_membersCreateOrConnectWithoutConversationsInput[]
    upsert?: conversations_membersUpsertWithWhereUniqueWithoutConversationsInput | conversations_membersUpsertWithWhereUniqueWithoutConversationsInput[]
    createMany?: conversations_membersCreateManyConversationsInputEnvelope
    set?: conversations_membersWhereUniqueInput | conversations_membersWhereUniqueInput[]
    disconnect?: conversations_membersWhereUniqueInput | conversations_membersWhereUniqueInput[]
    delete?: conversations_membersWhereUniqueInput | conversations_membersWhereUniqueInput[]
    connect?: conversations_membersWhereUniqueInput | conversations_membersWhereUniqueInput[]
    update?: conversations_membersUpdateWithWhereUniqueWithoutConversationsInput | conversations_membersUpdateWithWhereUniqueWithoutConversationsInput[]
    updateMany?: conversations_membersUpdateManyWithWhereWithoutConversationsInput | conversations_membersUpdateManyWithWhereWithoutConversationsInput[]
    deleteMany?: conversations_membersScalarWhereInput | conversations_membersScalarWhereInput[]
  }

  export type conversations_messages_logsUpdateManyWithoutConversationsNestedInput = {
    create?: XOR<conversations_messages_logsCreateWithoutConversationsInput, conversations_messages_logsUncheckedCreateWithoutConversationsInput> | conversations_messages_logsCreateWithoutConversationsInput[] | conversations_messages_logsUncheckedCreateWithoutConversationsInput[]
    connectOrCreate?: conversations_messages_logsCreateOrConnectWithoutConversationsInput | conversations_messages_logsCreateOrConnectWithoutConversationsInput[]
    upsert?: conversations_messages_logsUpsertWithWhereUniqueWithoutConversationsInput | conversations_messages_logsUpsertWithWhereUniqueWithoutConversationsInput[]
    createMany?: conversations_messages_logsCreateManyConversationsInputEnvelope
    set?: conversations_messages_logsWhereUniqueInput | conversations_messages_logsWhereUniqueInput[]
    disconnect?: conversations_messages_logsWhereUniqueInput | conversations_messages_logsWhereUniqueInput[]
    delete?: conversations_messages_logsWhereUniqueInput | conversations_messages_logsWhereUniqueInput[]
    connect?: conversations_messages_logsWhereUniqueInput | conversations_messages_logsWhereUniqueInput[]
    update?: conversations_messages_logsUpdateWithWhereUniqueWithoutConversationsInput | conversations_messages_logsUpdateWithWhereUniqueWithoutConversationsInput[]
    updateMany?: conversations_messages_logsUpdateManyWithWhereWithoutConversationsInput | conversations_messages_logsUpdateManyWithWhereWithoutConversationsInput[]
    deleteMany?: conversations_messages_logsScalarWhereInput | conversations_messages_logsScalarWhereInput[]
  }

  export type conversations_membersUncheckedUpdateManyWithoutConversationsNestedInput = {
    create?: XOR<conversations_membersCreateWithoutConversationsInput, conversations_membersUncheckedCreateWithoutConversationsInput> | conversations_membersCreateWithoutConversationsInput[] | conversations_membersUncheckedCreateWithoutConversationsInput[]
    connectOrCreate?: conversations_membersCreateOrConnectWithoutConversationsInput | conversations_membersCreateOrConnectWithoutConversationsInput[]
    upsert?: conversations_membersUpsertWithWhereUniqueWithoutConversationsInput | conversations_membersUpsertWithWhereUniqueWithoutConversationsInput[]
    createMany?: conversations_membersCreateManyConversationsInputEnvelope
    set?: conversations_membersWhereUniqueInput | conversations_membersWhereUniqueInput[]
    disconnect?: conversations_membersWhereUniqueInput | conversations_membersWhereUniqueInput[]
    delete?: conversations_membersWhereUniqueInput | conversations_membersWhereUniqueInput[]
    connect?: conversations_membersWhereUniqueInput | conversations_membersWhereUniqueInput[]
    update?: conversations_membersUpdateWithWhereUniqueWithoutConversationsInput | conversations_membersUpdateWithWhereUniqueWithoutConversationsInput[]
    updateMany?: conversations_membersUpdateManyWithWhereWithoutConversationsInput | conversations_membersUpdateManyWithWhereWithoutConversationsInput[]
    deleteMany?: conversations_membersScalarWhereInput | conversations_membersScalarWhereInput[]
  }

  export type conversations_messages_logsUncheckedUpdateManyWithoutConversationsNestedInput = {
    create?: XOR<conversations_messages_logsCreateWithoutConversationsInput, conversations_messages_logsUncheckedCreateWithoutConversationsInput> | conversations_messages_logsCreateWithoutConversationsInput[] | conversations_messages_logsUncheckedCreateWithoutConversationsInput[]
    connectOrCreate?: conversations_messages_logsCreateOrConnectWithoutConversationsInput | conversations_messages_logsCreateOrConnectWithoutConversationsInput[]
    upsert?: conversations_messages_logsUpsertWithWhereUniqueWithoutConversationsInput | conversations_messages_logsUpsertWithWhereUniqueWithoutConversationsInput[]
    createMany?: conversations_messages_logsCreateManyConversationsInputEnvelope
    set?: conversations_messages_logsWhereUniqueInput | conversations_messages_logsWhereUniqueInput[]
    disconnect?: conversations_messages_logsWhereUniqueInput | conversations_messages_logsWhereUniqueInput[]
    delete?: conversations_messages_logsWhereUniqueInput | conversations_messages_logsWhereUniqueInput[]
    connect?: conversations_messages_logsWhereUniqueInput | conversations_messages_logsWhereUniqueInput[]
    update?: conversations_messages_logsUpdateWithWhereUniqueWithoutConversationsInput | conversations_messages_logsUpdateWithWhereUniqueWithoutConversationsInput[]
    updateMany?: conversations_messages_logsUpdateManyWithWhereWithoutConversationsInput | conversations_messages_logsUpdateManyWithWhereWithoutConversationsInput[]
    deleteMany?: conversations_messages_logsScalarWhereInput | conversations_messages_logsScalarWhereInput[]
  }

  export type conversationsCreateNestedOneWithoutConversations_membersInput = {
    create?: XOR<conversationsCreateWithoutConversations_membersInput, conversationsUncheckedCreateWithoutConversations_membersInput>
    connectOrCreate?: conversationsCreateOrConnectWithoutConversations_membersInput
    connect?: conversationsWhereUniqueInput
  }

  export type entitiesCreateNestedOneWithoutConversations_membersInput = {
    create?: XOR<entitiesCreateWithoutConversations_membersInput, entitiesUncheckedCreateWithoutConversations_membersInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutConversations_membersInput
    connect?: entitiesWhereUniqueInput
  }

  export type conversationsUpdateOneRequiredWithoutConversations_membersNestedInput = {
    create?: XOR<conversationsCreateWithoutConversations_membersInput, conversationsUncheckedCreateWithoutConversations_membersInput>
    connectOrCreate?: conversationsCreateOrConnectWithoutConversations_membersInput
    upsert?: conversationsUpsertWithoutConversations_membersInput
    connect?: conversationsWhereUniqueInput
    update?: XOR<XOR<conversationsUpdateToOneWithWhereWithoutConversations_membersInput, conversationsUpdateWithoutConversations_membersInput>, conversationsUncheckedUpdateWithoutConversations_membersInput>
  }

  export type entitiesUpdateOneRequiredWithoutConversations_membersNestedInput = {
    create?: XOR<entitiesCreateWithoutConversations_membersInput, entitiesUncheckedCreateWithoutConversations_membersInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutConversations_membersInput
    upsert?: entitiesUpsertWithoutConversations_membersInput
    connect?: entitiesWhereUniqueInput
    update?: XOR<XOR<entitiesUpdateToOneWithWhereWithoutConversations_membersInput, entitiesUpdateWithoutConversations_membersInput>, entitiesUncheckedUpdateWithoutConversations_membersInput>
  }

  export type conversationsCreateNestedOneWithoutConversations_messages_logsInput = {
    create?: XOR<conversationsCreateWithoutConversations_messages_logsInput, conversationsUncheckedCreateWithoutConversations_messages_logsInput>
    connectOrCreate?: conversationsCreateOrConnectWithoutConversations_messages_logsInput
    connect?: conversationsWhereUniqueInput
  }

  export type entitiesCreateNestedOneWithoutConversations_messages_logsInput = {
    create?: XOR<entitiesCreateWithoutConversations_messages_logsInput, entitiesUncheckedCreateWithoutConversations_messages_logsInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutConversations_messages_logsInput
    connect?: entitiesWhereUniqueInput
  }

  export type conversationsUpdateOneRequiredWithoutConversations_messages_logsNestedInput = {
    create?: XOR<conversationsCreateWithoutConversations_messages_logsInput, conversationsUncheckedCreateWithoutConversations_messages_logsInput>
    connectOrCreate?: conversationsCreateOrConnectWithoutConversations_messages_logsInput
    upsert?: conversationsUpsertWithoutConversations_messages_logsInput
    connect?: conversationsWhereUniqueInput
    update?: XOR<XOR<conversationsUpdateToOneWithWhereWithoutConversations_messages_logsInput, conversationsUpdateWithoutConversations_messages_logsInput>, conversationsUncheckedUpdateWithoutConversations_messages_logsInput>
  }

  export type entitiesUpdateOneRequiredWithoutConversations_messages_logsNestedInput = {
    create?: XOR<entitiesCreateWithoutConversations_messages_logsInput, entitiesUncheckedCreateWithoutConversations_messages_logsInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutConversations_messages_logsInput
    upsert?: entitiesUpsertWithoutConversations_messages_logsInput
    connect?: entitiesWhereUniqueInput
    update?: XOR<XOR<entitiesUpdateToOneWithWhereWithoutConversations_messages_logsInput, entitiesUpdateWithoutConversations_messages_logsInput>, entitiesUncheckedUpdateWithoutConversations_messages_logsInput>
  }

  export type conversationsCreateNestedManyWithoutConversations_picturesInput = {
    create?: XOR<conversationsCreateWithoutConversations_picturesInput, conversationsUncheckedCreateWithoutConversations_picturesInput> | conversationsCreateWithoutConversations_picturesInput[] | conversationsUncheckedCreateWithoutConversations_picturesInput[]
    connectOrCreate?: conversationsCreateOrConnectWithoutConversations_picturesInput | conversationsCreateOrConnectWithoutConversations_picturesInput[]
    createMany?: conversationsCreateManyConversations_picturesInputEnvelope
    connect?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
  }

  export type conversationsUncheckedCreateNestedManyWithoutConversations_picturesInput = {
    create?: XOR<conversationsCreateWithoutConversations_picturesInput, conversationsUncheckedCreateWithoutConversations_picturesInput> | conversationsCreateWithoutConversations_picturesInput[] | conversationsUncheckedCreateWithoutConversations_picturesInput[]
    connectOrCreate?: conversationsCreateOrConnectWithoutConversations_picturesInput | conversationsCreateOrConnectWithoutConversations_picturesInput[]
    createMany?: conversationsCreateManyConversations_picturesInputEnvelope
    connect?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
  }

  export type conversationsUpdateManyWithoutConversations_picturesNestedInput = {
    create?: XOR<conversationsCreateWithoutConversations_picturesInput, conversationsUncheckedCreateWithoutConversations_picturesInput> | conversationsCreateWithoutConversations_picturesInput[] | conversationsUncheckedCreateWithoutConversations_picturesInput[]
    connectOrCreate?: conversationsCreateOrConnectWithoutConversations_picturesInput | conversationsCreateOrConnectWithoutConversations_picturesInput[]
    upsert?: conversationsUpsertWithWhereUniqueWithoutConversations_picturesInput | conversationsUpsertWithWhereUniqueWithoutConversations_picturesInput[]
    createMany?: conversationsCreateManyConversations_picturesInputEnvelope
    set?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    disconnect?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    delete?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    connect?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    update?: conversationsUpdateWithWhereUniqueWithoutConversations_picturesInput | conversationsUpdateWithWhereUniqueWithoutConversations_picturesInput[]
    updateMany?: conversationsUpdateManyWithWhereWithoutConversations_picturesInput | conversationsUpdateManyWithWhereWithoutConversations_picturesInput[]
    deleteMany?: conversationsScalarWhereInput | conversationsScalarWhereInput[]
  }

  export type conversationsUncheckedUpdateManyWithoutConversations_picturesNestedInput = {
    create?: XOR<conversationsCreateWithoutConversations_picturesInput, conversationsUncheckedCreateWithoutConversations_picturesInput> | conversationsCreateWithoutConversations_picturesInput[] | conversationsUncheckedCreateWithoutConversations_picturesInput[]
    connectOrCreate?: conversationsCreateOrConnectWithoutConversations_picturesInput | conversationsCreateOrConnectWithoutConversations_picturesInput[]
    upsert?: conversationsUpsertWithWhereUniqueWithoutConversations_picturesInput | conversationsUpsertWithWhereUniqueWithoutConversations_picturesInput[]
    createMany?: conversationsCreateManyConversations_picturesInputEnvelope
    set?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    disconnect?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    delete?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    connect?: conversationsWhereUniqueInput | conversationsWhereUniqueInput[]
    update?: conversationsUpdateWithWhereUniqueWithoutConversations_picturesInput | conversationsUpdateWithWhereUniqueWithoutConversations_picturesInput[]
    updateMany?: conversationsUpdateManyWithWhereWithoutConversations_picturesInput | conversationsUpdateManyWithWhereWithoutConversations_picturesInput[]
    deleteMany?: conversationsScalarWhereInput | conversationsScalarWhereInput[]
  }

  export type collectionsCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<collectionsCreateWithoutEntitiesInput, collectionsUncheckedCreateWithoutEntitiesInput> | collectionsCreateWithoutEntitiesInput[] | collectionsUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: collectionsCreateOrConnectWithoutEntitiesInput | collectionsCreateOrConnectWithoutEntitiesInput[]
    createMany?: collectionsCreateManyEntitiesInputEnvelope
    connect?: collectionsWhereUniqueInput | collectionsWhereUniqueInput[]
  }

  export type contactsCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput = {
    create?: XOR<contactsCreateWithoutEntities_contacts_contact_id_rootToentitiesInput, contactsUncheckedCreateWithoutEntities_contacts_contact_id_rootToentitiesInput> | contactsCreateWithoutEntities_contacts_contact_id_rootToentitiesInput[] | contactsUncheckedCreateWithoutEntities_contacts_contact_id_rootToentitiesInput[]
    connectOrCreate?: contactsCreateOrConnectWithoutEntities_contacts_contact_id_rootToentitiesInput | contactsCreateOrConnectWithoutEntities_contacts_contact_id_rootToentitiesInput[]
    createMany?: contactsCreateManyEntities_contacts_contact_id_rootToentitiesInputEnvelope
    connect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
  }

  export type contactsCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput = {
    create?: XOR<contactsCreateWithoutEntities_contacts_contact_id_targetToentitiesInput, contactsUncheckedCreateWithoutEntities_contacts_contact_id_targetToentitiesInput> | contactsCreateWithoutEntities_contacts_contact_id_targetToentitiesInput[] | contactsUncheckedCreateWithoutEntities_contacts_contact_id_targetToentitiesInput[]
    connectOrCreate?: contactsCreateOrConnectWithoutEntities_contacts_contact_id_targetToentitiesInput | contactsCreateOrConnectWithoutEntities_contacts_contact_id_targetToentitiesInput[]
    createMany?: contactsCreateManyEntities_contacts_contact_id_targetToentitiesInputEnvelope
    connect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
  }

  export type conversations_membersCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<conversations_membersCreateWithoutEntitiesInput, conversations_membersUncheckedCreateWithoutEntitiesInput> | conversations_membersCreateWithoutEntitiesInput[] | conversations_membersUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: conversations_membersCreateOrConnectWithoutEntitiesInput | conversations_membersCreateOrConnectWithoutEntitiesInput[]
    createMany?: conversations_membersCreateManyEntitiesInputEnvelope
    connect?: conversations_membersWhereUniqueInput | conversations_membersWhereUniqueInput[]
  }

  export type conversations_messages_logsCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<conversations_messages_logsCreateWithoutEntitiesInput, conversations_messages_logsUncheckedCreateWithoutEntitiesInput> | conversations_messages_logsCreateWithoutEntitiesInput[] | conversations_messages_logsUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: conversations_messages_logsCreateOrConnectWithoutEntitiesInput | conversations_messages_logsCreateOrConnectWithoutEntitiesInput[]
    createMany?: conversations_messages_logsCreateManyEntitiesInputEnvelope
    connect?: conversations_messages_logsWhereUniqueInput | conversations_messages_logsWhereUniqueInput[]
  }

  export type entities_contentCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<entities_contentCreateWithoutEntitiesInput, entities_contentUncheckedCreateWithoutEntitiesInput> | entities_contentCreateWithoutEntitiesInput[] | entities_contentUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: entities_contentCreateOrConnectWithoutEntitiesInput | entities_contentCreateOrConnectWithoutEntitiesInput[]
    createMany?: entities_contentCreateManyEntitiesInputEnvelope
    connect?: entities_contentWhereUniqueInput | entities_contentWhereUniqueInput[]
  }

  export type entities_dislikesCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<entities_dislikesCreateWithoutEntitiesInput, entities_dislikesUncheckedCreateWithoutEntitiesInput> | entities_dislikesCreateWithoutEntitiesInput[] | entities_dislikesUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: entities_dislikesCreateOrConnectWithoutEntitiesInput | entities_dislikesCreateOrConnectWithoutEntitiesInput[]
    createMany?: entities_dislikesCreateManyEntitiesInputEnvelope
    connect?: entities_dislikesWhereUniqueInput | entities_dislikesWhereUniqueInput[]
  }

  export type entities_likesCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<entities_likesCreateWithoutEntitiesInput, entities_likesUncheckedCreateWithoutEntitiesInput> | entities_likesCreateWithoutEntitiesInput[] | entities_likesUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: entities_likesCreateOrConnectWithoutEntitiesInput | entities_likesCreateOrConnectWithoutEntitiesInput[]
    createMany?: entities_likesCreateManyEntitiesInputEnvelope
    connect?: entities_likesWhereUniqueInput | entities_likesWhereUniqueInput[]
  }

  export type entities_referencesCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<entities_referencesCreateWithoutEntitiesInput, entities_referencesUncheckedCreateWithoutEntitiesInput> | entities_referencesCreateWithoutEntitiesInput[] | entities_referencesUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: entities_referencesCreateOrConnectWithoutEntitiesInput | entities_referencesCreateOrConnectWithoutEntitiesInput[]
    createMany?: entities_referencesCreateManyEntitiesInputEnvelope
    connect?: entities_referencesWhereUniqueInput | entities_referencesWhereUniqueInput[]
  }

  export type groups_membersCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<groups_membersCreateWithoutEntitiesInput, groups_membersUncheckedCreateWithoutEntitiesInput> | groups_membersCreateWithoutEntitiesInput[] | groups_membersUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: groups_membersCreateOrConnectWithoutEntitiesInput | groups_membersCreateOrConnectWithoutEntitiesInput[]
    createMany?: groups_membersCreateManyEntitiesInputEnvelope
    connect?: groups_membersWhereUniqueInput | groups_membersWhereUniqueInput[]
  }

  export type imagesCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<imagesCreateWithoutEntitiesInput, imagesUncheckedCreateWithoutEntitiesInput> | imagesCreateWithoutEntitiesInput[] | imagesUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: imagesCreateOrConnectWithoutEntitiesInput | imagesCreateOrConnectWithoutEntitiesInput[]
    createMany?: imagesCreateManyEntitiesInputEnvelope
    connect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
  }

  export type organizations_membersCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<organizations_membersCreateWithoutEntitiesInput, organizations_membersUncheckedCreateWithoutEntitiesInput> | organizations_membersCreateWithoutEntitiesInput[] | organizations_membersUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: organizations_membersCreateOrConnectWithoutEntitiesInput | organizations_membersCreateOrConnectWithoutEntitiesInput[]
    createMany?: organizations_membersCreateManyEntitiesInputEnvelope
    connect?: organizations_membersWhereUniqueInput | organizations_membersWhereUniqueInput[]
  }

  export type sheetsCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<sheetsCreateWithoutEntitiesInput, sheetsUncheckedCreateWithoutEntitiesInput> | sheetsCreateWithoutEntitiesInput[] | sheetsUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: sheetsCreateOrConnectWithoutEntitiesInput | sheetsCreateOrConnectWithoutEntitiesInput[]
    createMany?: sheetsCreateManyEntitiesInputEnvelope
    connect?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
  }

  export type tables_membersCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<tables_membersCreateWithoutEntitiesInput, tables_membersUncheckedCreateWithoutEntitiesInput> | tables_membersCreateWithoutEntitiesInput[] | tables_membersUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: tables_membersCreateOrConnectWithoutEntitiesInput | tables_membersCreateOrConnectWithoutEntitiesInput[]
    createMany?: tables_membersCreateManyEntitiesInputEnvelope
    connect?: tables_membersWhereUniqueInput | tables_membersWhereUniqueInput[]
  }

  export type tables_messages_logsCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<tables_messages_logsCreateWithoutEntitiesInput, tables_messages_logsUncheckedCreateWithoutEntitiesInput> | tables_messages_logsCreateWithoutEntitiesInput[] | tables_messages_logsUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: tables_messages_logsCreateOrConnectWithoutEntitiesInput | tables_messages_logsCreateOrConnectWithoutEntitiesInput[]
    createMany?: tables_messages_logsCreateManyEntitiesInputEnvelope
    connect?: tables_messages_logsWhereUniqueInput | tables_messages_logsWhereUniqueInput[]
  }

  export type tables_tabletopsCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<tables_tabletopsCreateWithoutEntitiesInput, tables_tabletopsUncheckedCreateWithoutEntitiesInput> | tables_tabletopsCreateWithoutEntitiesInput[] | tables_tabletopsUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: tables_tabletopsCreateOrConnectWithoutEntitiesInput | tables_tabletopsCreateOrConnectWithoutEntitiesInput[]
    createMany?: tables_tabletopsCreateManyEntitiesInputEnvelope
    connect?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
  }

  export type videosCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<videosCreateWithoutEntitiesInput, videosUncheckedCreateWithoutEntitiesInput> | videosCreateWithoutEntitiesInput[] | videosUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: videosCreateOrConnectWithoutEntitiesInput | videosCreateOrConnectWithoutEntitiesInput[]
    createMany?: videosCreateManyEntitiesInputEnvelope
    connect?: videosWhereUniqueInput | videosWhereUniqueInput[]
  }

  export type collectionsUncheckedCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<collectionsCreateWithoutEntitiesInput, collectionsUncheckedCreateWithoutEntitiesInput> | collectionsCreateWithoutEntitiesInput[] | collectionsUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: collectionsCreateOrConnectWithoutEntitiesInput | collectionsCreateOrConnectWithoutEntitiesInput[]
    createMany?: collectionsCreateManyEntitiesInputEnvelope
    connect?: collectionsWhereUniqueInput | collectionsWhereUniqueInput[]
  }

  export type contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput = {
    create?: XOR<contactsCreateWithoutEntities_contacts_contact_id_rootToentitiesInput, contactsUncheckedCreateWithoutEntities_contacts_contact_id_rootToentitiesInput> | contactsCreateWithoutEntities_contacts_contact_id_rootToentitiesInput[] | contactsUncheckedCreateWithoutEntities_contacts_contact_id_rootToentitiesInput[]
    connectOrCreate?: contactsCreateOrConnectWithoutEntities_contacts_contact_id_rootToentitiesInput | contactsCreateOrConnectWithoutEntities_contacts_contact_id_rootToentitiesInput[]
    createMany?: contactsCreateManyEntities_contacts_contact_id_rootToentitiesInputEnvelope
    connect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
  }

  export type contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput = {
    create?: XOR<contactsCreateWithoutEntities_contacts_contact_id_targetToentitiesInput, contactsUncheckedCreateWithoutEntities_contacts_contact_id_targetToentitiesInput> | contactsCreateWithoutEntities_contacts_contact_id_targetToentitiesInput[] | contactsUncheckedCreateWithoutEntities_contacts_contact_id_targetToentitiesInput[]
    connectOrCreate?: contactsCreateOrConnectWithoutEntities_contacts_contact_id_targetToentitiesInput | contactsCreateOrConnectWithoutEntities_contacts_contact_id_targetToentitiesInput[]
    createMany?: contactsCreateManyEntities_contacts_contact_id_targetToentitiesInputEnvelope
    connect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
  }

  export type conversations_membersUncheckedCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<conversations_membersCreateWithoutEntitiesInput, conversations_membersUncheckedCreateWithoutEntitiesInput> | conversations_membersCreateWithoutEntitiesInput[] | conversations_membersUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: conversations_membersCreateOrConnectWithoutEntitiesInput | conversations_membersCreateOrConnectWithoutEntitiesInput[]
    createMany?: conversations_membersCreateManyEntitiesInputEnvelope
    connect?: conversations_membersWhereUniqueInput | conversations_membersWhereUniqueInput[]
  }

  export type conversations_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<conversations_messages_logsCreateWithoutEntitiesInput, conversations_messages_logsUncheckedCreateWithoutEntitiesInput> | conversations_messages_logsCreateWithoutEntitiesInput[] | conversations_messages_logsUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: conversations_messages_logsCreateOrConnectWithoutEntitiesInput | conversations_messages_logsCreateOrConnectWithoutEntitiesInput[]
    createMany?: conversations_messages_logsCreateManyEntitiesInputEnvelope
    connect?: conversations_messages_logsWhereUniqueInput | conversations_messages_logsWhereUniqueInput[]
  }

  export type entities_contentUncheckedCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<entities_contentCreateWithoutEntitiesInput, entities_contentUncheckedCreateWithoutEntitiesInput> | entities_contentCreateWithoutEntitiesInput[] | entities_contentUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: entities_contentCreateOrConnectWithoutEntitiesInput | entities_contentCreateOrConnectWithoutEntitiesInput[]
    createMany?: entities_contentCreateManyEntitiesInputEnvelope
    connect?: entities_contentWhereUniqueInput | entities_contentWhereUniqueInput[]
  }

  export type entities_dislikesUncheckedCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<entities_dislikesCreateWithoutEntitiesInput, entities_dislikesUncheckedCreateWithoutEntitiesInput> | entities_dislikesCreateWithoutEntitiesInput[] | entities_dislikesUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: entities_dislikesCreateOrConnectWithoutEntitiesInput | entities_dislikesCreateOrConnectWithoutEntitiesInput[]
    createMany?: entities_dislikesCreateManyEntitiesInputEnvelope
    connect?: entities_dislikesWhereUniqueInput | entities_dislikesWhereUniqueInput[]
  }

  export type entities_likesUncheckedCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<entities_likesCreateWithoutEntitiesInput, entities_likesUncheckedCreateWithoutEntitiesInput> | entities_likesCreateWithoutEntitiesInput[] | entities_likesUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: entities_likesCreateOrConnectWithoutEntitiesInput | entities_likesCreateOrConnectWithoutEntitiesInput[]
    createMany?: entities_likesCreateManyEntitiesInputEnvelope
    connect?: entities_likesWhereUniqueInput | entities_likesWhereUniqueInput[]
  }

  export type entities_referencesUncheckedCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<entities_referencesCreateWithoutEntitiesInput, entities_referencesUncheckedCreateWithoutEntitiesInput> | entities_referencesCreateWithoutEntitiesInput[] | entities_referencesUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: entities_referencesCreateOrConnectWithoutEntitiesInput | entities_referencesCreateOrConnectWithoutEntitiesInput[]
    createMany?: entities_referencesCreateManyEntitiesInputEnvelope
    connect?: entities_referencesWhereUniqueInput | entities_referencesWhereUniqueInput[]
  }

  export type groups_membersUncheckedCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<groups_membersCreateWithoutEntitiesInput, groups_membersUncheckedCreateWithoutEntitiesInput> | groups_membersCreateWithoutEntitiesInput[] | groups_membersUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: groups_membersCreateOrConnectWithoutEntitiesInput | groups_membersCreateOrConnectWithoutEntitiesInput[]
    createMany?: groups_membersCreateManyEntitiesInputEnvelope
    connect?: groups_membersWhereUniqueInput | groups_membersWhereUniqueInput[]
  }

  export type imagesUncheckedCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<imagesCreateWithoutEntitiesInput, imagesUncheckedCreateWithoutEntitiesInput> | imagesCreateWithoutEntitiesInput[] | imagesUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: imagesCreateOrConnectWithoutEntitiesInput | imagesCreateOrConnectWithoutEntitiesInput[]
    createMany?: imagesCreateManyEntitiesInputEnvelope
    connect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
  }

  export type organizations_membersUncheckedCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<organizations_membersCreateWithoutEntitiesInput, organizations_membersUncheckedCreateWithoutEntitiesInput> | organizations_membersCreateWithoutEntitiesInput[] | organizations_membersUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: organizations_membersCreateOrConnectWithoutEntitiesInput | organizations_membersCreateOrConnectWithoutEntitiesInput[]
    createMany?: organizations_membersCreateManyEntitiesInputEnvelope
    connect?: organizations_membersWhereUniqueInput | organizations_membersWhereUniqueInput[]
  }

  export type sheetsUncheckedCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<sheetsCreateWithoutEntitiesInput, sheetsUncheckedCreateWithoutEntitiesInput> | sheetsCreateWithoutEntitiesInput[] | sheetsUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: sheetsCreateOrConnectWithoutEntitiesInput | sheetsCreateOrConnectWithoutEntitiesInput[]
    createMany?: sheetsCreateManyEntitiesInputEnvelope
    connect?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
  }

  export type tables_membersUncheckedCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<tables_membersCreateWithoutEntitiesInput, tables_membersUncheckedCreateWithoutEntitiesInput> | tables_membersCreateWithoutEntitiesInput[] | tables_membersUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: tables_membersCreateOrConnectWithoutEntitiesInput | tables_membersCreateOrConnectWithoutEntitiesInput[]
    createMany?: tables_membersCreateManyEntitiesInputEnvelope
    connect?: tables_membersWhereUniqueInput | tables_membersWhereUniqueInput[]
  }

  export type tables_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<tables_messages_logsCreateWithoutEntitiesInput, tables_messages_logsUncheckedCreateWithoutEntitiesInput> | tables_messages_logsCreateWithoutEntitiesInput[] | tables_messages_logsUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: tables_messages_logsCreateOrConnectWithoutEntitiesInput | tables_messages_logsCreateOrConnectWithoutEntitiesInput[]
    createMany?: tables_messages_logsCreateManyEntitiesInputEnvelope
    connect?: tables_messages_logsWhereUniqueInput | tables_messages_logsWhereUniqueInput[]
  }

  export type tables_tabletopsUncheckedCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<tables_tabletopsCreateWithoutEntitiesInput, tables_tabletopsUncheckedCreateWithoutEntitiesInput> | tables_tabletopsCreateWithoutEntitiesInput[] | tables_tabletopsUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: tables_tabletopsCreateOrConnectWithoutEntitiesInput | tables_tabletopsCreateOrConnectWithoutEntitiesInput[]
    createMany?: tables_tabletopsCreateManyEntitiesInputEnvelope
    connect?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
  }

  export type videosUncheckedCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<videosCreateWithoutEntitiesInput, videosUncheckedCreateWithoutEntitiesInput> | videosCreateWithoutEntitiesInput[] | videosUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: videosCreateOrConnectWithoutEntitiesInput | videosCreateOrConnectWithoutEntitiesInput[]
    createMany?: videosCreateManyEntitiesInputEnvelope
    connect?: videosWhereUniqueInput | videosWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type collectionsUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<collectionsCreateWithoutEntitiesInput, collectionsUncheckedCreateWithoutEntitiesInput> | collectionsCreateWithoutEntitiesInput[] | collectionsUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: collectionsCreateOrConnectWithoutEntitiesInput | collectionsCreateOrConnectWithoutEntitiesInput[]
    upsert?: collectionsUpsertWithWhereUniqueWithoutEntitiesInput | collectionsUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: collectionsCreateManyEntitiesInputEnvelope
    set?: collectionsWhereUniqueInput | collectionsWhereUniqueInput[]
    disconnect?: collectionsWhereUniqueInput | collectionsWhereUniqueInput[]
    delete?: collectionsWhereUniqueInput | collectionsWhereUniqueInput[]
    connect?: collectionsWhereUniqueInput | collectionsWhereUniqueInput[]
    update?: collectionsUpdateWithWhereUniqueWithoutEntitiesInput | collectionsUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: collectionsUpdateManyWithWhereWithoutEntitiesInput | collectionsUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: collectionsScalarWhereInput | collectionsScalarWhereInput[]
  }

  export type contactsUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput = {
    create?: XOR<contactsCreateWithoutEntities_contacts_contact_id_rootToentitiesInput, contactsUncheckedCreateWithoutEntities_contacts_contact_id_rootToentitiesInput> | contactsCreateWithoutEntities_contacts_contact_id_rootToentitiesInput[] | contactsUncheckedCreateWithoutEntities_contacts_contact_id_rootToentitiesInput[]
    connectOrCreate?: contactsCreateOrConnectWithoutEntities_contacts_contact_id_rootToentitiesInput | contactsCreateOrConnectWithoutEntities_contacts_contact_id_rootToentitiesInput[]
    upsert?: contactsUpsertWithWhereUniqueWithoutEntities_contacts_contact_id_rootToentitiesInput | contactsUpsertWithWhereUniqueWithoutEntities_contacts_contact_id_rootToentitiesInput[]
    createMany?: contactsCreateManyEntities_contacts_contact_id_rootToentitiesInputEnvelope
    set?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    disconnect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    delete?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    connect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    update?: contactsUpdateWithWhereUniqueWithoutEntities_contacts_contact_id_rootToentitiesInput | contactsUpdateWithWhereUniqueWithoutEntities_contacts_contact_id_rootToentitiesInput[]
    updateMany?: contactsUpdateManyWithWhereWithoutEntities_contacts_contact_id_rootToentitiesInput | contactsUpdateManyWithWhereWithoutEntities_contacts_contact_id_rootToentitiesInput[]
    deleteMany?: contactsScalarWhereInput | contactsScalarWhereInput[]
  }

  export type contactsUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput = {
    create?: XOR<contactsCreateWithoutEntities_contacts_contact_id_targetToentitiesInput, contactsUncheckedCreateWithoutEntities_contacts_contact_id_targetToentitiesInput> | contactsCreateWithoutEntities_contacts_contact_id_targetToentitiesInput[] | contactsUncheckedCreateWithoutEntities_contacts_contact_id_targetToentitiesInput[]
    connectOrCreate?: contactsCreateOrConnectWithoutEntities_contacts_contact_id_targetToentitiesInput | contactsCreateOrConnectWithoutEntities_contacts_contact_id_targetToentitiesInput[]
    upsert?: contactsUpsertWithWhereUniqueWithoutEntities_contacts_contact_id_targetToentitiesInput | contactsUpsertWithWhereUniqueWithoutEntities_contacts_contact_id_targetToentitiesInput[]
    createMany?: contactsCreateManyEntities_contacts_contact_id_targetToentitiesInputEnvelope
    set?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    disconnect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    delete?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    connect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    update?: contactsUpdateWithWhereUniqueWithoutEntities_contacts_contact_id_targetToentitiesInput | contactsUpdateWithWhereUniqueWithoutEntities_contacts_contact_id_targetToentitiesInput[]
    updateMany?: contactsUpdateManyWithWhereWithoutEntities_contacts_contact_id_targetToentitiesInput | contactsUpdateManyWithWhereWithoutEntities_contacts_contact_id_targetToentitiesInput[]
    deleteMany?: contactsScalarWhereInput | contactsScalarWhereInput[]
  }

  export type conversations_membersUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<conversations_membersCreateWithoutEntitiesInput, conversations_membersUncheckedCreateWithoutEntitiesInput> | conversations_membersCreateWithoutEntitiesInput[] | conversations_membersUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: conversations_membersCreateOrConnectWithoutEntitiesInput | conversations_membersCreateOrConnectWithoutEntitiesInput[]
    upsert?: conversations_membersUpsertWithWhereUniqueWithoutEntitiesInput | conversations_membersUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: conversations_membersCreateManyEntitiesInputEnvelope
    set?: conversations_membersWhereUniqueInput | conversations_membersWhereUniqueInput[]
    disconnect?: conversations_membersWhereUniqueInput | conversations_membersWhereUniqueInput[]
    delete?: conversations_membersWhereUniqueInput | conversations_membersWhereUniqueInput[]
    connect?: conversations_membersWhereUniqueInput | conversations_membersWhereUniqueInput[]
    update?: conversations_membersUpdateWithWhereUniqueWithoutEntitiesInput | conversations_membersUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: conversations_membersUpdateManyWithWhereWithoutEntitiesInput | conversations_membersUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: conversations_membersScalarWhereInput | conversations_membersScalarWhereInput[]
  }

  export type conversations_messages_logsUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<conversations_messages_logsCreateWithoutEntitiesInput, conversations_messages_logsUncheckedCreateWithoutEntitiesInput> | conversations_messages_logsCreateWithoutEntitiesInput[] | conversations_messages_logsUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: conversations_messages_logsCreateOrConnectWithoutEntitiesInput | conversations_messages_logsCreateOrConnectWithoutEntitiesInput[]
    upsert?: conversations_messages_logsUpsertWithWhereUniqueWithoutEntitiesInput | conversations_messages_logsUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: conversations_messages_logsCreateManyEntitiesInputEnvelope
    set?: conversations_messages_logsWhereUniqueInput | conversations_messages_logsWhereUniqueInput[]
    disconnect?: conversations_messages_logsWhereUniqueInput | conversations_messages_logsWhereUniqueInput[]
    delete?: conversations_messages_logsWhereUniqueInput | conversations_messages_logsWhereUniqueInput[]
    connect?: conversations_messages_logsWhereUniqueInput | conversations_messages_logsWhereUniqueInput[]
    update?: conversations_messages_logsUpdateWithWhereUniqueWithoutEntitiesInput | conversations_messages_logsUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: conversations_messages_logsUpdateManyWithWhereWithoutEntitiesInput | conversations_messages_logsUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: conversations_messages_logsScalarWhereInput | conversations_messages_logsScalarWhereInput[]
  }

  export type entities_contentUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<entities_contentCreateWithoutEntitiesInput, entities_contentUncheckedCreateWithoutEntitiesInput> | entities_contentCreateWithoutEntitiesInput[] | entities_contentUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: entities_contentCreateOrConnectWithoutEntitiesInput | entities_contentCreateOrConnectWithoutEntitiesInput[]
    upsert?: entities_contentUpsertWithWhereUniqueWithoutEntitiesInput | entities_contentUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: entities_contentCreateManyEntitiesInputEnvelope
    set?: entities_contentWhereUniqueInput | entities_contentWhereUniqueInput[]
    disconnect?: entities_contentWhereUniqueInput | entities_contentWhereUniqueInput[]
    delete?: entities_contentWhereUniqueInput | entities_contentWhereUniqueInput[]
    connect?: entities_contentWhereUniqueInput | entities_contentWhereUniqueInput[]
    update?: entities_contentUpdateWithWhereUniqueWithoutEntitiesInput | entities_contentUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: entities_contentUpdateManyWithWhereWithoutEntitiesInput | entities_contentUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: entities_contentScalarWhereInput | entities_contentScalarWhereInput[]
  }

  export type entities_dislikesUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<entities_dislikesCreateWithoutEntitiesInput, entities_dislikesUncheckedCreateWithoutEntitiesInput> | entities_dislikesCreateWithoutEntitiesInput[] | entities_dislikesUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: entities_dislikesCreateOrConnectWithoutEntitiesInput | entities_dislikesCreateOrConnectWithoutEntitiesInput[]
    upsert?: entities_dislikesUpsertWithWhereUniqueWithoutEntitiesInput | entities_dislikesUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: entities_dislikesCreateManyEntitiesInputEnvelope
    set?: entities_dislikesWhereUniqueInput | entities_dislikesWhereUniqueInput[]
    disconnect?: entities_dislikesWhereUniqueInput | entities_dislikesWhereUniqueInput[]
    delete?: entities_dislikesWhereUniqueInput | entities_dislikesWhereUniqueInput[]
    connect?: entities_dislikesWhereUniqueInput | entities_dislikesWhereUniqueInput[]
    update?: entities_dislikesUpdateWithWhereUniqueWithoutEntitiesInput | entities_dislikesUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: entities_dislikesUpdateManyWithWhereWithoutEntitiesInput | entities_dislikesUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: entities_dislikesScalarWhereInput | entities_dislikesScalarWhereInput[]
  }

  export type entities_likesUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<entities_likesCreateWithoutEntitiesInput, entities_likesUncheckedCreateWithoutEntitiesInput> | entities_likesCreateWithoutEntitiesInput[] | entities_likesUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: entities_likesCreateOrConnectWithoutEntitiesInput | entities_likesCreateOrConnectWithoutEntitiesInput[]
    upsert?: entities_likesUpsertWithWhereUniqueWithoutEntitiesInput | entities_likesUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: entities_likesCreateManyEntitiesInputEnvelope
    set?: entities_likesWhereUniqueInput | entities_likesWhereUniqueInput[]
    disconnect?: entities_likesWhereUniqueInput | entities_likesWhereUniqueInput[]
    delete?: entities_likesWhereUniqueInput | entities_likesWhereUniqueInput[]
    connect?: entities_likesWhereUniqueInput | entities_likesWhereUniqueInput[]
    update?: entities_likesUpdateWithWhereUniqueWithoutEntitiesInput | entities_likesUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: entities_likesUpdateManyWithWhereWithoutEntitiesInput | entities_likesUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: entities_likesScalarWhereInput | entities_likesScalarWhereInput[]
  }

  export type entities_referencesUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<entities_referencesCreateWithoutEntitiesInput, entities_referencesUncheckedCreateWithoutEntitiesInput> | entities_referencesCreateWithoutEntitiesInput[] | entities_referencesUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: entities_referencesCreateOrConnectWithoutEntitiesInput | entities_referencesCreateOrConnectWithoutEntitiesInput[]
    upsert?: entities_referencesUpsertWithWhereUniqueWithoutEntitiesInput | entities_referencesUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: entities_referencesCreateManyEntitiesInputEnvelope
    set?: entities_referencesWhereUniqueInput | entities_referencesWhereUniqueInput[]
    disconnect?: entities_referencesWhereUniqueInput | entities_referencesWhereUniqueInput[]
    delete?: entities_referencesWhereUniqueInput | entities_referencesWhereUniqueInput[]
    connect?: entities_referencesWhereUniqueInput | entities_referencesWhereUniqueInput[]
    update?: entities_referencesUpdateWithWhereUniqueWithoutEntitiesInput | entities_referencesUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: entities_referencesUpdateManyWithWhereWithoutEntitiesInput | entities_referencesUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: entities_referencesScalarWhereInput | entities_referencesScalarWhereInput[]
  }

  export type groups_membersUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<groups_membersCreateWithoutEntitiesInput, groups_membersUncheckedCreateWithoutEntitiesInput> | groups_membersCreateWithoutEntitiesInput[] | groups_membersUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: groups_membersCreateOrConnectWithoutEntitiesInput | groups_membersCreateOrConnectWithoutEntitiesInput[]
    upsert?: groups_membersUpsertWithWhereUniqueWithoutEntitiesInput | groups_membersUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: groups_membersCreateManyEntitiesInputEnvelope
    set?: groups_membersWhereUniqueInput | groups_membersWhereUniqueInput[]
    disconnect?: groups_membersWhereUniqueInput | groups_membersWhereUniqueInput[]
    delete?: groups_membersWhereUniqueInput | groups_membersWhereUniqueInput[]
    connect?: groups_membersWhereUniqueInput | groups_membersWhereUniqueInput[]
    update?: groups_membersUpdateWithWhereUniqueWithoutEntitiesInput | groups_membersUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: groups_membersUpdateManyWithWhereWithoutEntitiesInput | groups_membersUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: groups_membersScalarWhereInput | groups_membersScalarWhereInput[]
  }

  export type imagesUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<imagesCreateWithoutEntitiesInput, imagesUncheckedCreateWithoutEntitiesInput> | imagesCreateWithoutEntitiesInput[] | imagesUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: imagesCreateOrConnectWithoutEntitiesInput | imagesCreateOrConnectWithoutEntitiesInput[]
    upsert?: imagesUpsertWithWhereUniqueWithoutEntitiesInput | imagesUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: imagesCreateManyEntitiesInputEnvelope
    set?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    disconnect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    delete?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    connect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    update?: imagesUpdateWithWhereUniqueWithoutEntitiesInput | imagesUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: imagesUpdateManyWithWhereWithoutEntitiesInput | imagesUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: imagesScalarWhereInput | imagesScalarWhereInput[]
  }

  export type organizations_membersUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<organizations_membersCreateWithoutEntitiesInput, organizations_membersUncheckedCreateWithoutEntitiesInput> | organizations_membersCreateWithoutEntitiesInput[] | organizations_membersUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: organizations_membersCreateOrConnectWithoutEntitiesInput | organizations_membersCreateOrConnectWithoutEntitiesInput[]
    upsert?: organizations_membersUpsertWithWhereUniqueWithoutEntitiesInput | organizations_membersUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: organizations_membersCreateManyEntitiesInputEnvelope
    set?: organizations_membersWhereUniqueInput | organizations_membersWhereUniqueInput[]
    disconnect?: organizations_membersWhereUniqueInput | organizations_membersWhereUniqueInput[]
    delete?: organizations_membersWhereUniqueInput | organizations_membersWhereUniqueInput[]
    connect?: organizations_membersWhereUniqueInput | organizations_membersWhereUniqueInput[]
    update?: organizations_membersUpdateWithWhereUniqueWithoutEntitiesInput | organizations_membersUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: organizations_membersUpdateManyWithWhereWithoutEntitiesInput | organizations_membersUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: organizations_membersScalarWhereInput | organizations_membersScalarWhereInput[]
  }

  export type sheetsUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<sheetsCreateWithoutEntitiesInput, sheetsUncheckedCreateWithoutEntitiesInput> | sheetsCreateWithoutEntitiesInput[] | sheetsUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: sheetsCreateOrConnectWithoutEntitiesInput | sheetsCreateOrConnectWithoutEntitiesInput[]
    upsert?: sheetsUpsertWithWhereUniqueWithoutEntitiesInput | sheetsUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: sheetsCreateManyEntitiesInputEnvelope
    set?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
    disconnect?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
    delete?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
    connect?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
    update?: sheetsUpdateWithWhereUniqueWithoutEntitiesInput | sheetsUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: sheetsUpdateManyWithWhereWithoutEntitiesInput | sheetsUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: sheetsScalarWhereInput | sheetsScalarWhereInput[]
  }

  export type tables_membersUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<tables_membersCreateWithoutEntitiesInput, tables_membersUncheckedCreateWithoutEntitiesInput> | tables_membersCreateWithoutEntitiesInput[] | tables_membersUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: tables_membersCreateOrConnectWithoutEntitiesInput | tables_membersCreateOrConnectWithoutEntitiesInput[]
    upsert?: tables_membersUpsertWithWhereUniqueWithoutEntitiesInput | tables_membersUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: tables_membersCreateManyEntitiesInputEnvelope
    set?: tables_membersWhereUniqueInput | tables_membersWhereUniqueInput[]
    disconnect?: tables_membersWhereUniqueInput | tables_membersWhereUniqueInput[]
    delete?: tables_membersWhereUniqueInput | tables_membersWhereUniqueInput[]
    connect?: tables_membersWhereUniqueInput | tables_membersWhereUniqueInput[]
    update?: tables_membersUpdateWithWhereUniqueWithoutEntitiesInput | tables_membersUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: tables_membersUpdateManyWithWhereWithoutEntitiesInput | tables_membersUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: tables_membersScalarWhereInput | tables_membersScalarWhereInput[]
  }

  export type tables_messages_logsUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<tables_messages_logsCreateWithoutEntitiesInput, tables_messages_logsUncheckedCreateWithoutEntitiesInput> | tables_messages_logsCreateWithoutEntitiesInput[] | tables_messages_logsUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: tables_messages_logsCreateOrConnectWithoutEntitiesInput | tables_messages_logsCreateOrConnectWithoutEntitiesInput[]
    upsert?: tables_messages_logsUpsertWithWhereUniqueWithoutEntitiesInput | tables_messages_logsUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: tables_messages_logsCreateManyEntitiesInputEnvelope
    set?: tables_messages_logsWhereUniqueInput | tables_messages_logsWhereUniqueInput[]
    disconnect?: tables_messages_logsWhereUniqueInput | tables_messages_logsWhereUniqueInput[]
    delete?: tables_messages_logsWhereUniqueInput | tables_messages_logsWhereUniqueInput[]
    connect?: tables_messages_logsWhereUniqueInput | tables_messages_logsWhereUniqueInput[]
    update?: tables_messages_logsUpdateWithWhereUniqueWithoutEntitiesInput | tables_messages_logsUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: tables_messages_logsUpdateManyWithWhereWithoutEntitiesInput | tables_messages_logsUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: tables_messages_logsScalarWhereInput | tables_messages_logsScalarWhereInput[]
  }

  export type tables_tabletopsUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<tables_tabletopsCreateWithoutEntitiesInput, tables_tabletopsUncheckedCreateWithoutEntitiesInput> | tables_tabletopsCreateWithoutEntitiesInput[] | tables_tabletopsUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: tables_tabletopsCreateOrConnectWithoutEntitiesInput | tables_tabletopsCreateOrConnectWithoutEntitiesInput[]
    upsert?: tables_tabletopsUpsertWithWhereUniqueWithoutEntitiesInput | tables_tabletopsUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: tables_tabletopsCreateManyEntitiesInputEnvelope
    set?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
    disconnect?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
    delete?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
    connect?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
    update?: tables_tabletopsUpdateWithWhereUniqueWithoutEntitiesInput | tables_tabletopsUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: tables_tabletopsUpdateManyWithWhereWithoutEntitiesInput | tables_tabletopsUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: tables_tabletopsScalarWhereInput | tables_tabletopsScalarWhereInput[]
  }

  export type videosUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<videosCreateWithoutEntitiesInput, videosUncheckedCreateWithoutEntitiesInput> | videosCreateWithoutEntitiesInput[] | videosUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: videosCreateOrConnectWithoutEntitiesInput | videosCreateOrConnectWithoutEntitiesInput[]
    upsert?: videosUpsertWithWhereUniqueWithoutEntitiesInput | videosUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: videosCreateManyEntitiesInputEnvelope
    set?: videosWhereUniqueInput | videosWhereUniqueInput[]
    disconnect?: videosWhereUniqueInput | videosWhereUniqueInput[]
    delete?: videosWhereUniqueInput | videosWhereUniqueInput[]
    connect?: videosWhereUniqueInput | videosWhereUniqueInput[]
    update?: videosUpdateWithWhereUniqueWithoutEntitiesInput | videosUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: videosUpdateManyWithWhereWithoutEntitiesInput | videosUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: videosScalarWhereInput | videosScalarWhereInput[]
  }

  export type collectionsUncheckedUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<collectionsCreateWithoutEntitiesInput, collectionsUncheckedCreateWithoutEntitiesInput> | collectionsCreateWithoutEntitiesInput[] | collectionsUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: collectionsCreateOrConnectWithoutEntitiesInput | collectionsCreateOrConnectWithoutEntitiesInput[]
    upsert?: collectionsUpsertWithWhereUniqueWithoutEntitiesInput | collectionsUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: collectionsCreateManyEntitiesInputEnvelope
    set?: collectionsWhereUniqueInput | collectionsWhereUniqueInput[]
    disconnect?: collectionsWhereUniqueInput | collectionsWhereUniqueInput[]
    delete?: collectionsWhereUniqueInput | collectionsWhereUniqueInput[]
    connect?: collectionsWhereUniqueInput | collectionsWhereUniqueInput[]
    update?: collectionsUpdateWithWhereUniqueWithoutEntitiesInput | collectionsUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: collectionsUpdateManyWithWhereWithoutEntitiesInput | collectionsUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: collectionsScalarWhereInput | collectionsScalarWhereInput[]
  }

  export type contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput = {
    create?: XOR<contactsCreateWithoutEntities_contacts_contact_id_rootToentitiesInput, contactsUncheckedCreateWithoutEntities_contacts_contact_id_rootToentitiesInput> | contactsCreateWithoutEntities_contacts_contact_id_rootToentitiesInput[] | contactsUncheckedCreateWithoutEntities_contacts_contact_id_rootToentitiesInput[]
    connectOrCreate?: contactsCreateOrConnectWithoutEntities_contacts_contact_id_rootToentitiesInput | contactsCreateOrConnectWithoutEntities_contacts_contact_id_rootToentitiesInput[]
    upsert?: contactsUpsertWithWhereUniqueWithoutEntities_contacts_contact_id_rootToentitiesInput | contactsUpsertWithWhereUniqueWithoutEntities_contacts_contact_id_rootToentitiesInput[]
    createMany?: contactsCreateManyEntities_contacts_contact_id_rootToentitiesInputEnvelope
    set?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    disconnect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    delete?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    connect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    update?: contactsUpdateWithWhereUniqueWithoutEntities_contacts_contact_id_rootToentitiesInput | contactsUpdateWithWhereUniqueWithoutEntities_contacts_contact_id_rootToentitiesInput[]
    updateMany?: contactsUpdateManyWithWhereWithoutEntities_contacts_contact_id_rootToentitiesInput | contactsUpdateManyWithWhereWithoutEntities_contacts_contact_id_rootToentitiesInput[]
    deleteMany?: contactsScalarWhereInput | contactsScalarWhereInput[]
  }

  export type contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput = {
    create?: XOR<contactsCreateWithoutEntities_contacts_contact_id_targetToentitiesInput, contactsUncheckedCreateWithoutEntities_contacts_contact_id_targetToentitiesInput> | contactsCreateWithoutEntities_contacts_contact_id_targetToentitiesInput[] | contactsUncheckedCreateWithoutEntities_contacts_contact_id_targetToentitiesInput[]
    connectOrCreate?: contactsCreateOrConnectWithoutEntities_contacts_contact_id_targetToentitiesInput | contactsCreateOrConnectWithoutEntities_contacts_contact_id_targetToentitiesInput[]
    upsert?: contactsUpsertWithWhereUniqueWithoutEntities_contacts_contact_id_targetToentitiesInput | contactsUpsertWithWhereUniqueWithoutEntities_contacts_contact_id_targetToentitiesInput[]
    createMany?: contactsCreateManyEntities_contacts_contact_id_targetToentitiesInputEnvelope
    set?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    disconnect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    delete?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    connect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    update?: contactsUpdateWithWhereUniqueWithoutEntities_contacts_contact_id_targetToentitiesInput | contactsUpdateWithWhereUniqueWithoutEntities_contacts_contact_id_targetToentitiesInput[]
    updateMany?: contactsUpdateManyWithWhereWithoutEntities_contacts_contact_id_targetToentitiesInput | contactsUpdateManyWithWhereWithoutEntities_contacts_contact_id_targetToentitiesInput[]
    deleteMany?: contactsScalarWhereInput | contactsScalarWhereInput[]
  }

  export type conversations_membersUncheckedUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<conversations_membersCreateWithoutEntitiesInput, conversations_membersUncheckedCreateWithoutEntitiesInput> | conversations_membersCreateWithoutEntitiesInput[] | conversations_membersUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: conversations_membersCreateOrConnectWithoutEntitiesInput | conversations_membersCreateOrConnectWithoutEntitiesInput[]
    upsert?: conversations_membersUpsertWithWhereUniqueWithoutEntitiesInput | conversations_membersUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: conversations_membersCreateManyEntitiesInputEnvelope
    set?: conversations_membersWhereUniqueInput | conversations_membersWhereUniqueInput[]
    disconnect?: conversations_membersWhereUniqueInput | conversations_membersWhereUniqueInput[]
    delete?: conversations_membersWhereUniqueInput | conversations_membersWhereUniqueInput[]
    connect?: conversations_membersWhereUniqueInput | conversations_membersWhereUniqueInput[]
    update?: conversations_membersUpdateWithWhereUniqueWithoutEntitiesInput | conversations_membersUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: conversations_membersUpdateManyWithWhereWithoutEntitiesInput | conversations_membersUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: conversations_membersScalarWhereInput | conversations_membersScalarWhereInput[]
  }

  export type conversations_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<conversations_messages_logsCreateWithoutEntitiesInput, conversations_messages_logsUncheckedCreateWithoutEntitiesInput> | conversations_messages_logsCreateWithoutEntitiesInput[] | conversations_messages_logsUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: conversations_messages_logsCreateOrConnectWithoutEntitiesInput | conversations_messages_logsCreateOrConnectWithoutEntitiesInput[]
    upsert?: conversations_messages_logsUpsertWithWhereUniqueWithoutEntitiesInput | conversations_messages_logsUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: conversations_messages_logsCreateManyEntitiesInputEnvelope
    set?: conversations_messages_logsWhereUniqueInput | conversations_messages_logsWhereUniqueInput[]
    disconnect?: conversations_messages_logsWhereUniqueInput | conversations_messages_logsWhereUniqueInput[]
    delete?: conversations_messages_logsWhereUniqueInput | conversations_messages_logsWhereUniqueInput[]
    connect?: conversations_messages_logsWhereUniqueInput | conversations_messages_logsWhereUniqueInput[]
    update?: conversations_messages_logsUpdateWithWhereUniqueWithoutEntitiesInput | conversations_messages_logsUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: conversations_messages_logsUpdateManyWithWhereWithoutEntitiesInput | conversations_messages_logsUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: conversations_messages_logsScalarWhereInput | conversations_messages_logsScalarWhereInput[]
  }

  export type entities_contentUncheckedUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<entities_contentCreateWithoutEntitiesInput, entities_contentUncheckedCreateWithoutEntitiesInput> | entities_contentCreateWithoutEntitiesInput[] | entities_contentUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: entities_contentCreateOrConnectWithoutEntitiesInput | entities_contentCreateOrConnectWithoutEntitiesInput[]
    upsert?: entities_contentUpsertWithWhereUniqueWithoutEntitiesInput | entities_contentUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: entities_contentCreateManyEntitiesInputEnvelope
    set?: entities_contentWhereUniqueInput | entities_contentWhereUniqueInput[]
    disconnect?: entities_contentWhereUniqueInput | entities_contentWhereUniqueInput[]
    delete?: entities_contentWhereUniqueInput | entities_contentWhereUniqueInput[]
    connect?: entities_contentWhereUniqueInput | entities_contentWhereUniqueInput[]
    update?: entities_contentUpdateWithWhereUniqueWithoutEntitiesInput | entities_contentUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: entities_contentUpdateManyWithWhereWithoutEntitiesInput | entities_contentUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: entities_contentScalarWhereInput | entities_contentScalarWhereInput[]
  }

  export type entities_dislikesUncheckedUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<entities_dislikesCreateWithoutEntitiesInput, entities_dislikesUncheckedCreateWithoutEntitiesInput> | entities_dislikesCreateWithoutEntitiesInput[] | entities_dislikesUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: entities_dislikesCreateOrConnectWithoutEntitiesInput | entities_dislikesCreateOrConnectWithoutEntitiesInput[]
    upsert?: entities_dislikesUpsertWithWhereUniqueWithoutEntitiesInput | entities_dislikesUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: entities_dislikesCreateManyEntitiesInputEnvelope
    set?: entities_dislikesWhereUniqueInput | entities_dislikesWhereUniqueInput[]
    disconnect?: entities_dislikesWhereUniqueInput | entities_dislikesWhereUniqueInput[]
    delete?: entities_dislikesWhereUniqueInput | entities_dislikesWhereUniqueInput[]
    connect?: entities_dislikesWhereUniqueInput | entities_dislikesWhereUniqueInput[]
    update?: entities_dislikesUpdateWithWhereUniqueWithoutEntitiesInput | entities_dislikesUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: entities_dislikesUpdateManyWithWhereWithoutEntitiesInput | entities_dislikesUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: entities_dislikesScalarWhereInput | entities_dislikesScalarWhereInput[]
  }

  export type entities_likesUncheckedUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<entities_likesCreateWithoutEntitiesInput, entities_likesUncheckedCreateWithoutEntitiesInput> | entities_likesCreateWithoutEntitiesInput[] | entities_likesUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: entities_likesCreateOrConnectWithoutEntitiesInput | entities_likesCreateOrConnectWithoutEntitiesInput[]
    upsert?: entities_likesUpsertWithWhereUniqueWithoutEntitiesInput | entities_likesUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: entities_likesCreateManyEntitiesInputEnvelope
    set?: entities_likesWhereUniqueInput | entities_likesWhereUniqueInput[]
    disconnect?: entities_likesWhereUniqueInput | entities_likesWhereUniqueInput[]
    delete?: entities_likesWhereUniqueInput | entities_likesWhereUniqueInput[]
    connect?: entities_likesWhereUniqueInput | entities_likesWhereUniqueInput[]
    update?: entities_likesUpdateWithWhereUniqueWithoutEntitiesInput | entities_likesUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: entities_likesUpdateManyWithWhereWithoutEntitiesInput | entities_likesUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: entities_likesScalarWhereInput | entities_likesScalarWhereInput[]
  }

  export type entities_referencesUncheckedUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<entities_referencesCreateWithoutEntitiesInput, entities_referencesUncheckedCreateWithoutEntitiesInput> | entities_referencesCreateWithoutEntitiesInput[] | entities_referencesUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: entities_referencesCreateOrConnectWithoutEntitiesInput | entities_referencesCreateOrConnectWithoutEntitiesInput[]
    upsert?: entities_referencesUpsertWithWhereUniqueWithoutEntitiesInput | entities_referencesUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: entities_referencesCreateManyEntitiesInputEnvelope
    set?: entities_referencesWhereUniqueInput | entities_referencesWhereUniqueInput[]
    disconnect?: entities_referencesWhereUniqueInput | entities_referencesWhereUniqueInput[]
    delete?: entities_referencesWhereUniqueInput | entities_referencesWhereUniqueInput[]
    connect?: entities_referencesWhereUniqueInput | entities_referencesWhereUniqueInput[]
    update?: entities_referencesUpdateWithWhereUniqueWithoutEntitiesInput | entities_referencesUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: entities_referencesUpdateManyWithWhereWithoutEntitiesInput | entities_referencesUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: entities_referencesScalarWhereInput | entities_referencesScalarWhereInput[]
  }

  export type groups_membersUncheckedUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<groups_membersCreateWithoutEntitiesInput, groups_membersUncheckedCreateWithoutEntitiesInput> | groups_membersCreateWithoutEntitiesInput[] | groups_membersUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: groups_membersCreateOrConnectWithoutEntitiesInput | groups_membersCreateOrConnectWithoutEntitiesInput[]
    upsert?: groups_membersUpsertWithWhereUniqueWithoutEntitiesInput | groups_membersUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: groups_membersCreateManyEntitiesInputEnvelope
    set?: groups_membersWhereUniqueInput | groups_membersWhereUniqueInput[]
    disconnect?: groups_membersWhereUniqueInput | groups_membersWhereUniqueInput[]
    delete?: groups_membersWhereUniqueInput | groups_membersWhereUniqueInput[]
    connect?: groups_membersWhereUniqueInput | groups_membersWhereUniqueInput[]
    update?: groups_membersUpdateWithWhereUniqueWithoutEntitiesInput | groups_membersUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: groups_membersUpdateManyWithWhereWithoutEntitiesInput | groups_membersUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: groups_membersScalarWhereInput | groups_membersScalarWhereInput[]
  }

  export type imagesUncheckedUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<imagesCreateWithoutEntitiesInput, imagesUncheckedCreateWithoutEntitiesInput> | imagesCreateWithoutEntitiesInput[] | imagesUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: imagesCreateOrConnectWithoutEntitiesInput | imagesCreateOrConnectWithoutEntitiesInput[]
    upsert?: imagesUpsertWithWhereUniqueWithoutEntitiesInput | imagesUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: imagesCreateManyEntitiesInputEnvelope
    set?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    disconnect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    delete?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    connect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    update?: imagesUpdateWithWhereUniqueWithoutEntitiesInput | imagesUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: imagesUpdateManyWithWhereWithoutEntitiesInput | imagesUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: imagesScalarWhereInput | imagesScalarWhereInput[]
  }

  export type organizations_membersUncheckedUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<organizations_membersCreateWithoutEntitiesInput, organizations_membersUncheckedCreateWithoutEntitiesInput> | organizations_membersCreateWithoutEntitiesInput[] | organizations_membersUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: organizations_membersCreateOrConnectWithoutEntitiesInput | organizations_membersCreateOrConnectWithoutEntitiesInput[]
    upsert?: organizations_membersUpsertWithWhereUniqueWithoutEntitiesInput | organizations_membersUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: organizations_membersCreateManyEntitiesInputEnvelope
    set?: organizations_membersWhereUniqueInput | organizations_membersWhereUniqueInput[]
    disconnect?: organizations_membersWhereUniqueInput | organizations_membersWhereUniqueInput[]
    delete?: organizations_membersWhereUniqueInput | organizations_membersWhereUniqueInput[]
    connect?: organizations_membersWhereUniqueInput | organizations_membersWhereUniqueInput[]
    update?: organizations_membersUpdateWithWhereUniqueWithoutEntitiesInput | organizations_membersUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: organizations_membersUpdateManyWithWhereWithoutEntitiesInput | organizations_membersUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: organizations_membersScalarWhereInput | organizations_membersScalarWhereInput[]
  }

  export type sheetsUncheckedUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<sheetsCreateWithoutEntitiesInput, sheetsUncheckedCreateWithoutEntitiesInput> | sheetsCreateWithoutEntitiesInput[] | sheetsUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: sheetsCreateOrConnectWithoutEntitiesInput | sheetsCreateOrConnectWithoutEntitiesInput[]
    upsert?: sheetsUpsertWithWhereUniqueWithoutEntitiesInput | sheetsUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: sheetsCreateManyEntitiesInputEnvelope
    set?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
    disconnect?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
    delete?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
    connect?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
    update?: sheetsUpdateWithWhereUniqueWithoutEntitiesInput | sheetsUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: sheetsUpdateManyWithWhereWithoutEntitiesInput | sheetsUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: sheetsScalarWhereInput | sheetsScalarWhereInput[]
  }

  export type tables_membersUncheckedUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<tables_membersCreateWithoutEntitiesInput, tables_membersUncheckedCreateWithoutEntitiesInput> | tables_membersCreateWithoutEntitiesInput[] | tables_membersUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: tables_membersCreateOrConnectWithoutEntitiesInput | tables_membersCreateOrConnectWithoutEntitiesInput[]
    upsert?: tables_membersUpsertWithWhereUniqueWithoutEntitiesInput | tables_membersUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: tables_membersCreateManyEntitiesInputEnvelope
    set?: tables_membersWhereUniqueInput | tables_membersWhereUniqueInput[]
    disconnect?: tables_membersWhereUniqueInput | tables_membersWhereUniqueInput[]
    delete?: tables_membersWhereUniqueInput | tables_membersWhereUniqueInput[]
    connect?: tables_membersWhereUniqueInput | tables_membersWhereUniqueInput[]
    update?: tables_membersUpdateWithWhereUniqueWithoutEntitiesInput | tables_membersUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: tables_membersUpdateManyWithWhereWithoutEntitiesInput | tables_membersUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: tables_membersScalarWhereInput | tables_membersScalarWhereInput[]
  }

  export type tables_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<tables_messages_logsCreateWithoutEntitiesInput, tables_messages_logsUncheckedCreateWithoutEntitiesInput> | tables_messages_logsCreateWithoutEntitiesInput[] | tables_messages_logsUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: tables_messages_logsCreateOrConnectWithoutEntitiesInput | tables_messages_logsCreateOrConnectWithoutEntitiesInput[]
    upsert?: tables_messages_logsUpsertWithWhereUniqueWithoutEntitiesInput | tables_messages_logsUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: tables_messages_logsCreateManyEntitiesInputEnvelope
    set?: tables_messages_logsWhereUniqueInput | tables_messages_logsWhereUniqueInput[]
    disconnect?: tables_messages_logsWhereUniqueInput | tables_messages_logsWhereUniqueInput[]
    delete?: tables_messages_logsWhereUniqueInput | tables_messages_logsWhereUniqueInput[]
    connect?: tables_messages_logsWhereUniqueInput | tables_messages_logsWhereUniqueInput[]
    update?: tables_messages_logsUpdateWithWhereUniqueWithoutEntitiesInput | tables_messages_logsUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: tables_messages_logsUpdateManyWithWhereWithoutEntitiesInput | tables_messages_logsUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: tables_messages_logsScalarWhereInput | tables_messages_logsScalarWhereInput[]
  }

  export type tables_tabletopsUncheckedUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<tables_tabletopsCreateWithoutEntitiesInput, tables_tabletopsUncheckedCreateWithoutEntitiesInput> | tables_tabletopsCreateWithoutEntitiesInput[] | tables_tabletopsUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: tables_tabletopsCreateOrConnectWithoutEntitiesInput | tables_tabletopsCreateOrConnectWithoutEntitiesInput[]
    upsert?: tables_tabletopsUpsertWithWhereUniqueWithoutEntitiesInput | tables_tabletopsUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: tables_tabletopsCreateManyEntitiesInputEnvelope
    set?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
    disconnect?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
    delete?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
    connect?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
    update?: tables_tabletopsUpdateWithWhereUniqueWithoutEntitiesInput | tables_tabletopsUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: tables_tabletopsUpdateManyWithWhereWithoutEntitiesInput | tables_tabletopsUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: tables_tabletopsScalarWhereInput | tables_tabletopsScalarWhereInput[]
  }

  export type videosUncheckedUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<videosCreateWithoutEntitiesInput, videosUncheckedCreateWithoutEntitiesInput> | videosCreateWithoutEntitiesInput[] | videosUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: videosCreateOrConnectWithoutEntitiesInput | videosCreateOrConnectWithoutEntitiesInput[]
    upsert?: videosUpsertWithWhereUniqueWithoutEntitiesInput | videosUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: videosCreateManyEntitiesInputEnvelope
    set?: videosWhereUniqueInput | videosWhereUniqueInput[]
    disconnect?: videosWhereUniqueInput | videosWhereUniqueInput[]
    delete?: videosWhereUniqueInput | videosWhereUniqueInput[]
    connect?: videosWhereUniqueInput | videosWhereUniqueInput[]
    update?: videosUpdateWithWhereUniqueWithoutEntitiesInput | videosUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: videosUpdateManyWithWhereWithoutEntitiesInput | videosUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: videosScalarWhereInput | videosScalarWhereInput[]
  }

  export type contentCreateNestedOneWithoutEntities_contentInput = {
    create?: XOR<contentCreateWithoutEntities_contentInput, contentUncheckedCreateWithoutEntities_contentInput>
    connectOrCreate?: contentCreateOrConnectWithoutEntities_contentInput
    connect?: contentWhereUniqueInput
  }

  export type entitiesCreateNestedOneWithoutEntities_contentInput = {
    create?: XOR<entitiesCreateWithoutEntities_contentInput, entitiesUncheckedCreateWithoutEntities_contentInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutEntities_contentInput
    connect?: entitiesWhereUniqueInput
  }

  export type contentUpdateOneRequiredWithoutEntities_contentNestedInput = {
    create?: XOR<contentCreateWithoutEntities_contentInput, contentUncheckedCreateWithoutEntities_contentInput>
    connectOrCreate?: contentCreateOrConnectWithoutEntities_contentInput
    upsert?: contentUpsertWithoutEntities_contentInput
    connect?: contentWhereUniqueInput
    update?: XOR<XOR<contentUpdateToOneWithWhereWithoutEntities_contentInput, contentUpdateWithoutEntities_contentInput>, contentUncheckedUpdateWithoutEntities_contentInput>
  }

  export type entitiesUpdateOneRequiredWithoutEntities_contentNestedInput = {
    create?: XOR<entitiesCreateWithoutEntities_contentInput, entitiesUncheckedCreateWithoutEntities_contentInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutEntities_contentInput
    upsert?: entitiesUpsertWithoutEntities_contentInput
    connect?: entitiesWhereUniqueInput
    update?: XOR<XOR<entitiesUpdateToOneWithWhereWithoutEntities_contentInput, entitiesUpdateWithoutEntities_contentInput>, entitiesUncheckedUpdateWithoutEntities_contentInput>
  }

  export type contentCreateNestedOneWithoutEntities_dislikesInput = {
    create?: XOR<contentCreateWithoutEntities_dislikesInput, contentUncheckedCreateWithoutEntities_dislikesInput>
    connectOrCreate?: contentCreateOrConnectWithoutEntities_dislikesInput
    connect?: contentWhereUniqueInput
  }

  export type entitiesCreateNestedOneWithoutEntities_dislikesInput = {
    create?: XOR<entitiesCreateWithoutEntities_dislikesInput, entitiesUncheckedCreateWithoutEntities_dislikesInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutEntities_dislikesInput
    connect?: entitiesWhereUniqueInput
  }

  export type contentUpdateOneRequiredWithoutEntities_dislikesNestedInput = {
    create?: XOR<contentCreateWithoutEntities_dislikesInput, contentUncheckedCreateWithoutEntities_dislikesInput>
    connectOrCreate?: contentCreateOrConnectWithoutEntities_dislikesInput
    upsert?: contentUpsertWithoutEntities_dislikesInput
    connect?: contentWhereUniqueInput
    update?: XOR<XOR<contentUpdateToOneWithWhereWithoutEntities_dislikesInput, contentUpdateWithoutEntities_dislikesInput>, contentUncheckedUpdateWithoutEntities_dislikesInput>
  }

  export type entitiesUpdateOneRequiredWithoutEntities_dislikesNestedInput = {
    create?: XOR<entitiesCreateWithoutEntities_dislikesInput, entitiesUncheckedCreateWithoutEntities_dislikesInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutEntities_dislikesInput
    upsert?: entitiesUpsertWithoutEntities_dislikesInput
    connect?: entitiesWhereUniqueInput
    update?: XOR<XOR<entitiesUpdateToOneWithWhereWithoutEntities_dislikesInput, entitiesUpdateWithoutEntities_dislikesInput>, entitiesUncheckedUpdateWithoutEntities_dislikesInput>
  }

  export type contentCreateNestedOneWithoutEntities_likesInput = {
    create?: XOR<contentCreateWithoutEntities_likesInput, contentUncheckedCreateWithoutEntities_likesInput>
    connectOrCreate?: contentCreateOrConnectWithoutEntities_likesInput
    connect?: contentWhereUniqueInput
  }

  export type entitiesCreateNestedOneWithoutEntities_likesInput = {
    create?: XOR<entitiesCreateWithoutEntities_likesInput, entitiesUncheckedCreateWithoutEntities_likesInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutEntities_likesInput
    connect?: entitiesWhereUniqueInput
  }

  export type contentUpdateOneRequiredWithoutEntities_likesNestedInput = {
    create?: XOR<contentCreateWithoutEntities_likesInput, contentUncheckedCreateWithoutEntities_likesInput>
    connectOrCreate?: contentCreateOrConnectWithoutEntities_likesInput
    upsert?: contentUpsertWithoutEntities_likesInput
    connect?: contentWhereUniqueInput
    update?: XOR<XOR<contentUpdateToOneWithWhereWithoutEntities_likesInput, contentUpdateWithoutEntities_likesInput>, contentUncheckedUpdateWithoutEntities_likesInput>
  }

  export type entitiesUpdateOneRequiredWithoutEntities_likesNestedInput = {
    create?: XOR<entitiesCreateWithoutEntities_likesInput, entitiesUncheckedCreateWithoutEntities_likesInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutEntities_likesInput
    upsert?: entitiesUpsertWithoutEntities_likesInput
    connect?: entitiesWhereUniqueInput
    update?: XOR<XOR<entitiesUpdateToOneWithWhereWithoutEntities_likesInput, entitiesUpdateWithoutEntities_likesInput>, entitiesUncheckedUpdateWithoutEntities_likesInput>
  }

  export type entitiesCreateNestedOneWithoutEntities_referencesInput = {
    create?: XOR<entitiesCreateWithoutEntities_referencesInput, entitiesUncheckedCreateWithoutEntities_referencesInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutEntities_referencesInput
    connect?: entitiesWhereUniqueInput
  }

  export type entitiesUpdateOneRequiredWithoutEntities_referencesNestedInput = {
    create?: XOR<entitiesCreateWithoutEntities_referencesInput, entitiesUncheckedCreateWithoutEntities_referencesInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutEntities_referencesInput
    upsert?: entitiesUpsertWithoutEntities_referencesInput
    connect?: entitiesWhereUniqueInput
    update?: XOR<XOR<entitiesUpdateToOneWithWhereWithoutEntities_referencesInput, entitiesUpdateWithoutEntities_referencesInput>, entitiesUncheckedUpdateWithoutEntities_referencesInput>
  }

  export type profile_picturesCreateNestedOneWithoutGroupsInput = {
    create?: XOR<profile_picturesCreateWithoutGroupsInput, profile_picturesUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: profile_picturesCreateOrConnectWithoutGroupsInput
    connect?: profile_picturesWhereUniqueInput
  }

  export type groups_membersCreateNestedManyWithoutGroupsInput = {
    create?: XOR<groups_membersCreateWithoutGroupsInput, groups_membersUncheckedCreateWithoutGroupsInput> | groups_membersCreateWithoutGroupsInput[] | groups_membersUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: groups_membersCreateOrConnectWithoutGroupsInput | groups_membersCreateOrConnectWithoutGroupsInput[]
    createMany?: groups_membersCreateManyGroupsInputEnvelope
    connect?: groups_membersWhereUniqueInput | groups_membersWhereUniqueInput[]
  }

  export type groups_membersUncheckedCreateNestedManyWithoutGroupsInput = {
    create?: XOR<groups_membersCreateWithoutGroupsInput, groups_membersUncheckedCreateWithoutGroupsInput> | groups_membersCreateWithoutGroupsInput[] | groups_membersUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: groups_membersCreateOrConnectWithoutGroupsInput | groups_membersCreateOrConnectWithoutGroupsInput[]
    createMany?: groups_membersCreateManyGroupsInputEnvelope
    connect?: groups_membersWhereUniqueInput | groups_membersWhereUniqueInput[]
  }

  export type profile_picturesUpdateOneWithoutGroupsNestedInput = {
    create?: XOR<profile_picturesCreateWithoutGroupsInput, profile_picturesUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: profile_picturesCreateOrConnectWithoutGroupsInput
    upsert?: profile_picturesUpsertWithoutGroupsInput
    disconnect?: profile_picturesWhereInput | boolean
    delete?: profile_picturesWhereInput | boolean
    connect?: profile_picturesWhereUniqueInput
    update?: XOR<XOR<profile_picturesUpdateToOneWithWhereWithoutGroupsInput, profile_picturesUpdateWithoutGroupsInput>, profile_picturesUncheckedUpdateWithoutGroupsInput>
  }

  export type groups_membersUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<groups_membersCreateWithoutGroupsInput, groups_membersUncheckedCreateWithoutGroupsInput> | groups_membersCreateWithoutGroupsInput[] | groups_membersUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: groups_membersCreateOrConnectWithoutGroupsInput | groups_membersCreateOrConnectWithoutGroupsInput[]
    upsert?: groups_membersUpsertWithWhereUniqueWithoutGroupsInput | groups_membersUpsertWithWhereUniqueWithoutGroupsInput[]
    createMany?: groups_membersCreateManyGroupsInputEnvelope
    set?: groups_membersWhereUniqueInput | groups_membersWhereUniqueInput[]
    disconnect?: groups_membersWhereUniqueInput | groups_membersWhereUniqueInput[]
    delete?: groups_membersWhereUniqueInput | groups_membersWhereUniqueInput[]
    connect?: groups_membersWhereUniqueInput | groups_membersWhereUniqueInput[]
    update?: groups_membersUpdateWithWhereUniqueWithoutGroupsInput | groups_membersUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: groups_membersUpdateManyWithWhereWithoutGroupsInput | groups_membersUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: groups_membersScalarWhereInput | groups_membersScalarWhereInput[]
  }

  export type groups_membersUncheckedUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<groups_membersCreateWithoutGroupsInput, groups_membersUncheckedCreateWithoutGroupsInput> | groups_membersCreateWithoutGroupsInput[] | groups_membersUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: groups_membersCreateOrConnectWithoutGroupsInput | groups_membersCreateOrConnectWithoutGroupsInput[]
    upsert?: groups_membersUpsertWithWhereUniqueWithoutGroupsInput | groups_membersUpsertWithWhereUniqueWithoutGroupsInput[]
    createMany?: groups_membersCreateManyGroupsInputEnvelope
    set?: groups_membersWhereUniqueInput | groups_membersWhereUniqueInput[]
    disconnect?: groups_membersWhereUniqueInput | groups_membersWhereUniqueInput[]
    delete?: groups_membersWhereUniqueInput | groups_membersWhereUniqueInput[]
    connect?: groups_membersWhereUniqueInput | groups_membersWhereUniqueInput[]
    update?: groups_membersUpdateWithWhereUniqueWithoutGroupsInput | groups_membersUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: groups_membersUpdateManyWithWhereWithoutGroupsInput | groups_membersUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: groups_membersScalarWhereInput | groups_membersScalarWhereInput[]
  }

  export type entitiesCreateNestedOneWithoutGroups_membersInput = {
    create?: XOR<entitiesCreateWithoutGroups_membersInput, entitiesUncheckedCreateWithoutGroups_membersInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutGroups_membersInput
    connect?: entitiesWhereUniqueInput
  }

  export type groupsCreateNestedOneWithoutGroups_membersInput = {
    create?: XOR<groupsCreateWithoutGroups_membersInput, groupsUncheckedCreateWithoutGroups_membersInput>
    connectOrCreate?: groupsCreateOrConnectWithoutGroups_membersInput
    connect?: groupsWhereUniqueInput
  }

  export type entitiesUpdateOneRequiredWithoutGroups_membersNestedInput = {
    create?: XOR<entitiesCreateWithoutGroups_membersInput, entitiesUncheckedCreateWithoutGroups_membersInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutGroups_membersInput
    upsert?: entitiesUpsertWithoutGroups_membersInput
    connect?: entitiesWhereUniqueInput
    update?: XOR<XOR<entitiesUpdateToOneWithWhereWithoutGroups_membersInput, entitiesUpdateWithoutGroups_membersInput>, entitiesUncheckedUpdateWithoutGroups_membersInput>
  }

  export type groupsUpdateOneRequiredWithoutGroups_membersNestedInput = {
    create?: XOR<groupsCreateWithoutGroups_membersInput, groupsUncheckedCreateWithoutGroups_membersInput>
    connectOrCreate?: groupsCreateOrConnectWithoutGroups_membersInput
    upsert?: groupsUpsertWithoutGroups_membersInput
    connect?: groupsWhereUniqueInput
    update?: XOR<XOR<groupsUpdateToOneWithWhereWithoutGroups_membersInput, groupsUpdateWithoutGroups_membersInput>, groupsUncheckedUpdateWithoutGroups_membersInput>
  }

  export type entitiesCreateNestedOneWithoutImagesInput = {
    create?: XOR<entitiesCreateWithoutImagesInput, entitiesUncheckedCreateWithoutImagesInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutImagesInput
    connect?: entitiesWhereUniqueInput
  }

  export type images_dataCreateNestedOneWithoutImagesInput = {
    create?: XOR<images_dataCreateWithoutImagesInput, images_dataUncheckedCreateWithoutImagesInput>
    connectOrCreate?: images_dataCreateOrConnectWithoutImagesInput
    connect?: images_dataWhereUniqueInput
  }

  export type entitiesUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<entitiesCreateWithoutImagesInput, entitiesUncheckedCreateWithoutImagesInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutImagesInput
    upsert?: entitiesUpsertWithoutImagesInput
    connect?: entitiesWhereUniqueInput
    update?: XOR<XOR<entitiesUpdateToOneWithWhereWithoutImagesInput, entitiesUpdateWithoutImagesInput>, entitiesUncheckedUpdateWithoutImagesInput>
  }

  export type images_dataUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<images_dataCreateWithoutImagesInput, images_dataUncheckedCreateWithoutImagesInput>
    connectOrCreate?: images_dataCreateOrConnectWithoutImagesInput
    upsert?: images_dataUpsertWithoutImagesInput
    connect?: images_dataWhereUniqueInput
    update?: XOR<XOR<images_dataUpdateToOneWithWhereWithoutImagesInput, images_dataUpdateWithoutImagesInput>, images_dataUncheckedUpdateWithoutImagesInput>
  }

  export type imagesCreateNestedManyWithoutImages_dataInput = {
    create?: XOR<imagesCreateWithoutImages_dataInput, imagesUncheckedCreateWithoutImages_dataInput> | imagesCreateWithoutImages_dataInput[] | imagesUncheckedCreateWithoutImages_dataInput[]
    connectOrCreate?: imagesCreateOrConnectWithoutImages_dataInput | imagesCreateOrConnectWithoutImages_dataInput[]
    createMany?: imagesCreateManyImages_dataInputEnvelope
    connect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
  }

  export type imagesUncheckedCreateNestedManyWithoutImages_dataInput = {
    create?: XOR<imagesCreateWithoutImages_dataInput, imagesUncheckedCreateWithoutImages_dataInput> | imagesCreateWithoutImages_dataInput[] | imagesUncheckedCreateWithoutImages_dataInput[]
    connectOrCreate?: imagesCreateOrConnectWithoutImages_dataInput | imagesCreateOrConnectWithoutImages_dataInput[]
    createMany?: imagesCreateManyImages_dataInputEnvelope
    connect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
  }

  export type imagesUpdateManyWithoutImages_dataNestedInput = {
    create?: XOR<imagesCreateWithoutImages_dataInput, imagesUncheckedCreateWithoutImages_dataInput> | imagesCreateWithoutImages_dataInput[] | imagesUncheckedCreateWithoutImages_dataInput[]
    connectOrCreate?: imagesCreateOrConnectWithoutImages_dataInput | imagesCreateOrConnectWithoutImages_dataInput[]
    upsert?: imagesUpsertWithWhereUniqueWithoutImages_dataInput | imagesUpsertWithWhereUniqueWithoutImages_dataInput[]
    createMany?: imagesCreateManyImages_dataInputEnvelope
    set?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    disconnect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    delete?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    connect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    update?: imagesUpdateWithWhereUniqueWithoutImages_dataInput | imagesUpdateWithWhereUniqueWithoutImages_dataInput[]
    updateMany?: imagesUpdateManyWithWhereWithoutImages_dataInput | imagesUpdateManyWithWhereWithoutImages_dataInput[]
    deleteMany?: imagesScalarWhereInput | imagesScalarWhereInput[]
  }

  export type imagesUncheckedUpdateManyWithoutImages_dataNestedInput = {
    create?: XOR<imagesCreateWithoutImages_dataInput, imagesUncheckedCreateWithoutImages_dataInput> | imagesCreateWithoutImages_dataInput[] | imagesUncheckedCreateWithoutImages_dataInput[]
    connectOrCreate?: imagesCreateOrConnectWithoutImages_dataInput | imagesCreateOrConnectWithoutImages_dataInput[]
    upsert?: imagesUpsertWithWhereUniqueWithoutImages_dataInput | imagesUpsertWithWhereUniqueWithoutImages_dataInput[]
    createMany?: imagesCreateManyImages_dataInputEnvelope
    set?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    disconnect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    delete?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    connect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    update?: imagesUpdateWithWhereUniqueWithoutImages_dataInput | imagesUpdateWithWhereUniqueWithoutImages_dataInput[]
    updateMany?: imagesUpdateManyWithWhereWithoutImages_dataInput | imagesUpdateManyWithWhereWithoutImages_dataInput[]
    deleteMany?: imagesScalarWhereInput | imagesScalarWhereInput[]
  }

  export type user_credentialsCreateNestedOneWithoutIndividualsInput = {
    create?: XOR<user_credentialsCreateWithoutIndividualsInput, user_credentialsUncheckedCreateWithoutIndividualsInput>
    connectOrCreate?: user_credentialsCreateOrConnectWithoutIndividualsInput
    connect?: user_credentialsWhereUniqueInput
  }

  export type profile_picturesCreateNestedOneWithoutIndividualsInput = {
    create?: XOR<profile_picturesCreateWithoutIndividualsInput, profile_picturesUncheckedCreateWithoutIndividualsInput>
    connectOrCreate?: profile_picturesCreateOrConnectWithoutIndividualsInput
    connect?: profile_picturesWhereUniqueInput
  }

  export type user_credentialsUpdateOneRequiredWithoutIndividualsNestedInput = {
    create?: XOR<user_credentialsCreateWithoutIndividualsInput, user_credentialsUncheckedCreateWithoutIndividualsInput>
    connectOrCreate?: user_credentialsCreateOrConnectWithoutIndividualsInput
    upsert?: user_credentialsUpsertWithoutIndividualsInput
    connect?: user_credentialsWhereUniqueInput
    update?: XOR<XOR<user_credentialsUpdateToOneWithWhereWithoutIndividualsInput, user_credentialsUpdateWithoutIndividualsInput>, user_credentialsUncheckedUpdateWithoutIndividualsInput>
  }

  export type profile_picturesUpdateOneWithoutIndividualsNestedInput = {
    create?: XOR<profile_picturesCreateWithoutIndividualsInput, profile_picturesUncheckedCreateWithoutIndividualsInput>
    connectOrCreate?: profile_picturesCreateOrConnectWithoutIndividualsInput
    upsert?: profile_picturesUpsertWithoutIndividualsInput
    disconnect?: profile_picturesWhereInput | boolean
    delete?: profile_picturesWhereInput | boolean
    connect?: profile_picturesWhereUniqueInput
    update?: XOR<XOR<profile_picturesUpdateToOneWithWhereWithoutIndividualsInput, profile_picturesUpdateWithoutIndividualsInput>, profile_picturesUncheckedUpdateWithoutIndividualsInput>
  }

  export type profile_picturesCreateNestedOneWithoutOrganizationsInput = {
    create?: XOR<profile_picturesCreateWithoutOrganizationsInput, profile_picturesUncheckedCreateWithoutOrganizationsInput>
    connectOrCreate?: profile_picturesCreateOrConnectWithoutOrganizationsInput
    connect?: profile_picturesWhereUniqueInput
  }

  export type organizations_membersCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<organizations_membersCreateWithoutOrganizationsInput, organizations_membersUncheckedCreateWithoutOrganizationsInput> | organizations_membersCreateWithoutOrganizationsInput[] | organizations_membersUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: organizations_membersCreateOrConnectWithoutOrganizationsInput | organizations_membersCreateOrConnectWithoutOrganizationsInput[]
    createMany?: organizations_membersCreateManyOrganizationsInputEnvelope
    connect?: organizations_membersWhereUniqueInput | organizations_membersWhereUniqueInput[]
  }

  export type organizations_membersUncheckedCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<organizations_membersCreateWithoutOrganizationsInput, organizations_membersUncheckedCreateWithoutOrganizationsInput> | organizations_membersCreateWithoutOrganizationsInput[] | organizations_membersUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: organizations_membersCreateOrConnectWithoutOrganizationsInput | organizations_membersCreateOrConnectWithoutOrganizationsInput[]
    createMany?: organizations_membersCreateManyOrganizationsInputEnvelope
    connect?: organizations_membersWhereUniqueInput | organizations_membersWhereUniqueInput[]
  }

  export type profile_picturesUpdateOneWithoutOrganizationsNestedInput = {
    create?: XOR<profile_picturesCreateWithoutOrganizationsInput, profile_picturesUncheckedCreateWithoutOrganizationsInput>
    connectOrCreate?: profile_picturesCreateOrConnectWithoutOrganizationsInput
    upsert?: profile_picturesUpsertWithoutOrganizationsInput
    disconnect?: profile_picturesWhereInput | boolean
    delete?: profile_picturesWhereInput | boolean
    connect?: profile_picturesWhereUniqueInput
    update?: XOR<XOR<profile_picturesUpdateToOneWithWhereWithoutOrganizationsInput, profile_picturesUpdateWithoutOrganizationsInput>, profile_picturesUncheckedUpdateWithoutOrganizationsInput>
  }

  export type organizations_membersUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<organizations_membersCreateWithoutOrganizationsInput, organizations_membersUncheckedCreateWithoutOrganizationsInput> | organizations_membersCreateWithoutOrganizationsInput[] | organizations_membersUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: organizations_membersCreateOrConnectWithoutOrganizationsInput | organizations_membersCreateOrConnectWithoutOrganizationsInput[]
    upsert?: organizations_membersUpsertWithWhereUniqueWithoutOrganizationsInput | organizations_membersUpsertWithWhereUniqueWithoutOrganizationsInput[]
    createMany?: organizations_membersCreateManyOrganizationsInputEnvelope
    set?: organizations_membersWhereUniqueInput | organizations_membersWhereUniqueInput[]
    disconnect?: organizations_membersWhereUniqueInput | organizations_membersWhereUniqueInput[]
    delete?: organizations_membersWhereUniqueInput | organizations_membersWhereUniqueInput[]
    connect?: organizations_membersWhereUniqueInput | organizations_membersWhereUniqueInput[]
    update?: organizations_membersUpdateWithWhereUniqueWithoutOrganizationsInput | organizations_membersUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: organizations_membersUpdateManyWithWhereWithoutOrganizationsInput | organizations_membersUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: organizations_membersScalarWhereInput | organizations_membersScalarWhereInput[]
  }

  export type organizations_membersUncheckedUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<organizations_membersCreateWithoutOrganizationsInput, organizations_membersUncheckedCreateWithoutOrganizationsInput> | organizations_membersCreateWithoutOrganizationsInput[] | organizations_membersUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: organizations_membersCreateOrConnectWithoutOrganizationsInput | organizations_membersCreateOrConnectWithoutOrganizationsInput[]
    upsert?: organizations_membersUpsertWithWhereUniqueWithoutOrganizationsInput | organizations_membersUpsertWithWhereUniqueWithoutOrganizationsInput[]
    createMany?: organizations_membersCreateManyOrganizationsInputEnvelope
    set?: organizations_membersWhereUniqueInput | organizations_membersWhereUniqueInput[]
    disconnect?: organizations_membersWhereUniqueInput | organizations_membersWhereUniqueInput[]
    delete?: organizations_membersWhereUniqueInput | organizations_membersWhereUniqueInput[]
    connect?: organizations_membersWhereUniqueInput | organizations_membersWhereUniqueInput[]
    update?: organizations_membersUpdateWithWhereUniqueWithoutOrganizationsInput | organizations_membersUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: organizations_membersUpdateManyWithWhereWithoutOrganizationsInput | organizations_membersUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: organizations_membersScalarWhereInput | organizations_membersScalarWhereInput[]
  }

  export type entitiesCreateNestedOneWithoutOrganizations_membersInput = {
    create?: XOR<entitiesCreateWithoutOrganizations_membersInput, entitiesUncheckedCreateWithoutOrganizations_membersInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutOrganizations_membersInput
    connect?: entitiesWhereUniqueInput
  }

  export type organizationsCreateNestedOneWithoutOrganizations_membersInput = {
    create?: XOR<organizationsCreateWithoutOrganizations_membersInput, organizationsUncheckedCreateWithoutOrganizations_membersInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutOrganizations_membersInput
    connect?: organizationsWhereUniqueInput
  }

  export type entitiesUpdateOneRequiredWithoutOrganizations_membersNestedInput = {
    create?: XOR<entitiesCreateWithoutOrganizations_membersInput, entitiesUncheckedCreateWithoutOrganizations_membersInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutOrganizations_membersInput
    upsert?: entitiesUpsertWithoutOrganizations_membersInput
    connect?: entitiesWhereUniqueInput
    update?: XOR<XOR<entitiesUpdateToOneWithWhereWithoutOrganizations_membersInput, entitiesUpdateWithoutOrganizations_membersInput>, entitiesUncheckedUpdateWithoutOrganizations_membersInput>
  }

  export type organizationsUpdateOneRequiredWithoutOrganizations_membersNestedInput = {
    create?: XOR<organizationsCreateWithoutOrganizations_membersInput, organizationsUncheckedCreateWithoutOrganizations_membersInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutOrganizations_membersInput
    upsert?: organizationsUpsertWithoutOrganizations_membersInput
    connect?: organizationsWhereUniqueInput
    update?: XOR<XOR<organizationsUpdateToOneWithWhereWithoutOrganizations_membersInput, organizationsUpdateWithoutOrganizations_membersInput>, organizationsUncheckedUpdateWithoutOrganizations_membersInput>
  }

  export type groupsCreateNestedManyWithoutProfile_picturesInput = {
    create?: XOR<groupsCreateWithoutProfile_picturesInput, groupsUncheckedCreateWithoutProfile_picturesInput> | groupsCreateWithoutProfile_picturesInput[] | groupsUncheckedCreateWithoutProfile_picturesInput[]
    connectOrCreate?: groupsCreateOrConnectWithoutProfile_picturesInput | groupsCreateOrConnectWithoutProfile_picturesInput[]
    createMany?: groupsCreateManyProfile_picturesInputEnvelope
    connect?: groupsWhereUniqueInput | groupsWhereUniqueInput[]
  }

  export type individualsCreateNestedManyWithoutProfile_picturesInput = {
    create?: XOR<individualsCreateWithoutProfile_picturesInput, individualsUncheckedCreateWithoutProfile_picturesInput> | individualsCreateWithoutProfile_picturesInput[] | individualsUncheckedCreateWithoutProfile_picturesInput[]
    connectOrCreate?: individualsCreateOrConnectWithoutProfile_picturesInput | individualsCreateOrConnectWithoutProfile_picturesInput[]
    createMany?: individualsCreateManyProfile_picturesInputEnvelope
    connect?: individualsWhereUniqueInput | individualsWhereUniqueInput[]
  }

  export type organizationsCreateNestedManyWithoutProfile_picturesInput = {
    create?: XOR<organizationsCreateWithoutProfile_picturesInput, organizationsUncheckedCreateWithoutProfile_picturesInput> | organizationsCreateWithoutProfile_picturesInput[] | organizationsUncheckedCreateWithoutProfile_picturesInput[]
    connectOrCreate?: organizationsCreateOrConnectWithoutProfile_picturesInput | organizationsCreateOrConnectWithoutProfile_picturesInput[]
    createMany?: organizationsCreateManyProfile_picturesInputEnvelope
    connect?: organizationsWhereUniqueInput | organizationsWhereUniqueInput[]
  }

  export type groupsUncheckedCreateNestedManyWithoutProfile_picturesInput = {
    create?: XOR<groupsCreateWithoutProfile_picturesInput, groupsUncheckedCreateWithoutProfile_picturesInput> | groupsCreateWithoutProfile_picturesInput[] | groupsUncheckedCreateWithoutProfile_picturesInput[]
    connectOrCreate?: groupsCreateOrConnectWithoutProfile_picturesInput | groupsCreateOrConnectWithoutProfile_picturesInput[]
    createMany?: groupsCreateManyProfile_picturesInputEnvelope
    connect?: groupsWhereUniqueInput | groupsWhereUniqueInput[]
  }

  export type individualsUncheckedCreateNestedManyWithoutProfile_picturesInput = {
    create?: XOR<individualsCreateWithoutProfile_picturesInput, individualsUncheckedCreateWithoutProfile_picturesInput> | individualsCreateWithoutProfile_picturesInput[] | individualsUncheckedCreateWithoutProfile_picturesInput[]
    connectOrCreate?: individualsCreateOrConnectWithoutProfile_picturesInput | individualsCreateOrConnectWithoutProfile_picturesInput[]
    createMany?: individualsCreateManyProfile_picturesInputEnvelope
    connect?: individualsWhereUniqueInput | individualsWhereUniqueInput[]
  }

  export type organizationsUncheckedCreateNestedManyWithoutProfile_picturesInput = {
    create?: XOR<organizationsCreateWithoutProfile_picturesInput, organizationsUncheckedCreateWithoutProfile_picturesInput> | organizationsCreateWithoutProfile_picturesInput[] | organizationsUncheckedCreateWithoutProfile_picturesInput[]
    connectOrCreate?: organizationsCreateOrConnectWithoutProfile_picturesInput | organizationsCreateOrConnectWithoutProfile_picturesInput[]
    createMany?: organizationsCreateManyProfile_picturesInputEnvelope
    connect?: organizationsWhereUniqueInput | organizationsWhereUniqueInput[]
  }

  export type groupsUpdateManyWithoutProfile_picturesNestedInput = {
    create?: XOR<groupsCreateWithoutProfile_picturesInput, groupsUncheckedCreateWithoutProfile_picturesInput> | groupsCreateWithoutProfile_picturesInput[] | groupsUncheckedCreateWithoutProfile_picturesInput[]
    connectOrCreate?: groupsCreateOrConnectWithoutProfile_picturesInput | groupsCreateOrConnectWithoutProfile_picturesInput[]
    upsert?: groupsUpsertWithWhereUniqueWithoutProfile_picturesInput | groupsUpsertWithWhereUniqueWithoutProfile_picturesInput[]
    createMany?: groupsCreateManyProfile_picturesInputEnvelope
    set?: groupsWhereUniqueInput | groupsWhereUniqueInput[]
    disconnect?: groupsWhereUniqueInput | groupsWhereUniqueInput[]
    delete?: groupsWhereUniqueInput | groupsWhereUniqueInput[]
    connect?: groupsWhereUniqueInput | groupsWhereUniqueInput[]
    update?: groupsUpdateWithWhereUniqueWithoutProfile_picturesInput | groupsUpdateWithWhereUniqueWithoutProfile_picturesInput[]
    updateMany?: groupsUpdateManyWithWhereWithoutProfile_picturesInput | groupsUpdateManyWithWhereWithoutProfile_picturesInput[]
    deleteMany?: groupsScalarWhereInput | groupsScalarWhereInput[]
  }

  export type individualsUpdateManyWithoutProfile_picturesNestedInput = {
    create?: XOR<individualsCreateWithoutProfile_picturesInput, individualsUncheckedCreateWithoutProfile_picturesInput> | individualsCreateWithoutProfile_picturesInput[] | individualsUncheckedCreateWithoutProfile_picturesInput[]
    connectOrCreate?: individualsCreateOrConnectWithoutProfile_picturesInput | individualsCreateOrConnectWithoutProfile_picturesInput[]
    upsert?: individualsUpsertWithWhereUniqueWithoutProfile_picturesInput | individualsUpsertWithWhereUniqueWithoutProfile_picturesInput[]
    createMany?: individualsCreateManyProfile_picturesInputEnvelope
    set?: individualsWhereUniqueInput | individualsWhereUniqueInput[]
    disconnect?: individualsWhereUniqueInput | individualsWhereUniqueInput[]
    delete?: individualsWhereUniqueInput | individualsWhereUniqueInput[]
    connect?: individualsWhereUniqueInput | individualsWhereUniqueInput[]
    update?: individualsUpdateWithWhereUniqueWithoutProfile_picturesInput | individualsUpdateWithWhereUniqueWithoutProfile_picturesInput[]
    updateMany?: individualsUpdateManyWithWhereWithoutProfile_picturesInput | individualsUpdateManyWithWhereWithoutProfile_picturesInput[]
    deleteMany?: individualsScalarWhereInput | individualsScalarWhereInput[]
  }

  export type organizationsUpdateManyWithoutProfile_picturesNestedInput = {
    create?: XOR<organizationsCreateWithoutProfile_picturesInput, organizationsUncheckedCreateWithoutProfile_picturesInput> | organizationsCreateWithoutProfile_picturesInput[] | organizationsUncheckedCreateWithoutProfile_picturesInput[]
    connectOrCreate?: organizationsCreateOrConnectWithoutProfile_picturesInput | organizationsCreateOrConnectWithoutProfile_picturesInput[]
    upsert?: organizationsUpsertWithWhereUniqueWithoutProfile_picturesInput | organizationsUpsertWithWhereUniqueWithoutProfile_picturesInput[]
    createMany?: organizationsCreateManyProfile_picturesInputEnvelope
    set?: organizationsWhereUniqueInput | organizationsWhereUniqueInput[]
    disconnect?: organizationsWhereUniqueInput | organizationsWhereUniqueInput[]
    delete?: organizationsWhereUniqueInput | organizationsWhereUniqueInput[]
    connect?: organizationsWhereUniqueInput | organizationsWhereUniqueInput[]
    update?: organizationsUpdateWithWhereUniqueWithoutProfile_picturesInput | organizationsUpdateWithWhereUniqueWithoutProfile_picturesInput[]
    updateMany?: organizationsUpdateManyWithWhereWithoutProfile_picturesInput | organizationsUpdateManyWithWhereWithoutProfile_picturesInput[]
    deleteMany?: organizationsScalarWhereInput | organizationsScalarWhereInput[]
  }

  export type groupsUncheckedUpdateManyWithoutProfile_picturesNestedInput = {
    create?: XOR<groupsCreateWithoutProfile_picturesInput, groupsUncheckedCreateWithoutProfile_picturesInput> | groupsCreateWithoutProfile_picturesInput[] | groupsUncheckedCreateWithoutProfile_picturesInput[]
    connectOrCreate?: groupsCreateOrConnectWithoutProfile_picturesInput | groupsCreateOrConnectWithoutProfile_picturesInput[]
    upsert?: groupsUpsertWithWhereUniqueWithoutProfile_picturesInput | groupsUpsertWithWhereUniqueWithoutProfile_picturesInput[]
    createMany?: groupsCreateManyProfile_picturesInputEnvelope
    set?: groupsWhereUniqueInput | groupsWhereUniqueInput[]
    disconnect?: groupsWhereUniqueInput | groupsWhereUniqueInput[]
    delete?: groupsWhereUniqueInput | groupsWhereUniqueInput[]
    connect?: groupsWhereUniqueInput | groupsWhereUniqueInput[]
    update?: groupsUpdateWithWhereUniqueWithoutProfile_picturesInput | groupsUpdateWithWhereUniqueWithoutProfile_picturesInput[]
    updateMany?: groupsUpdateManyWithWhereWithoutProfile_picturesInput | groupsUpdateManyWithWhereWithoutProfile_picturesInput[]
    deleteMany?: groupsScalarWhereInput | groupsScalarWhereInput[]
  }

  export type individualsUncheckedUpdateManyWithoutProfile_picturesNestedInput = {
    create?: XOR<individualsCreateWithoutProfile_picturesInput, individualsUncheckedCreateWithoutProfile_picturesInput> | individualsCreateWithoutProfile_picturesInput[] | individualsUncheckedCreateWithoutProfile_picturesInput[]
    connectOrCreate?: individualsCreateOrConnectWithoutProfile_picturesInput | individualsCreateOrConnectWithoutProfile_picturesInput[]
    upsert?: individualsUpsertWithWhereUniqueWithoutProfile_picturesInput | individualsUpsertWithWhereUniqueWithoutProfile_picturesInput[]
    createMany?: individualsCreateManyProfile_picturesInputEnvelope
    set?: individualsWhereUniqueInput | individualsWhereUniqueInput[]
    disconnect?: individualsWhereUniqueInput | individualsWhereUniqueInput[]
    delete?: individualsWhereUniqueInput | individualsWhereUniqueInput[]
    connect?: individualsWhereUniqueInput | individualsWhereUniqueInput[]
    update?: individualsUpdateWithWhereUniqueWithoutProfile_picturesInput | individualsUpdateWithWhereUniqueWithoutProfile_picturesInput[]
    updateMany?: individualsUpdateManyWithWhereWithoutProfile_picturesInput | individualsUpdateManyWithWhereWithoutProfile_picturesInput[]
    deleteMany?: individualsScalarWhereInput | individualsScalarWhereInput[]
  }

  export type organizationsUncheckedUpdateManyWithoutProfile_picturesNestedInput = {
    create?: XOR<organizationsCreateWithoutProfile_picturesInput, organizationsUncheckedCreateWithoutProfile_picturesInput> | organizationsCreateWithoutProfile_picturesInput[] | organizationsUncheckedCreateWithoutProfile_picturesInput[]
    connectOrCreate?: organizationsCreateOrConnectWithoutProfile_picturesInput | organizationsCreateOrConnectWithoutProfile_picturesInput[]
    upsert?: organizationsUpsertWithWhereUniqueWithoutProfile_picturesInput | organizationsUpsertWithWhereUniqueWithoutProfile_picturesInput[]
    createMany?: organizationsCreateManyProfile_picturesInputEnvelope
    set?: organizationsWhereUniqueInput | organizationsWhereUniqueInput[]
    disconnect?: organizationsWhereUniqueInput | organizationsWhereUniqueInput[]
    delete?: organizationsWhereUniqueInput | organizationsWhereUniqueInput[]
    connect?: organizationsWhereUniqueInput | organizationsWhereUniqueInput[]
    update?: organizationsUpdateWithWhereUniqueWithoutProfile_picturesInput | organizationsUpdateWithWhereUniqueWithoutProfile_picturesInput[]
    updateMany?: organizationsUpdateManyWithWhereWithoutProfile_picturesInput | organizationsUpdateManyWithWhereWithoutProfile_picturesInput[]
    deleteMany?: organizationsScalarWhereInput | organizationsScalarWhereInput[]
  }

  export type entitiesCreateNestedOneWithoutSheetsInput = {
    create?: XOR<entitiesCreateWithoutSheetsInput, entitiesUncheckedCreateWithoutSheetsInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutSheetsInput
    connect?: entitiesWhereUniqueInput
  }

  export type sheets_dataCreateNestedOneWithoutSheetsInput = {
    create?: XOR<sheets_dataCreateWithoutSheetsInput, sheets_dataUncheckedCreateWithoutSheetsInput>
    connectOrCreate?: sheets_dataCreateOrConnectWithoutSheetsInput
    connect?: sheets_dataWhereUniqueInput
  }

  export type sheets_thumbnailsCreateNestedOneWithoutSheetsInput = {
    create?: XOR<sheets_thumbnailsCreateWithoutSheetsInput, sheets_thumbnailsUncheckedCreateWithoutSheetsInput>
    connectOrCreate?: sheets_thumbnailsCreateOrConnectWithoutSheetsInput
    connect?: sheets_thumbnailsWhereUniqueInput
  }

  export type entitiesUpdateOneRequiredWithoutSheetsNestedInput = {
    create?: XOR<entitiesCreateWithoutSheetsInput, entitiesUncheckedCreateWithoutSheetsInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutSheetsInput
    upsert?: entitiesUpsertWithoutSheetsInput
    connect?: entitiesWhereUniqueInput
    update?: XOR<XOR<entitiesUpdateToOneWithWhereWithoutSheetsInput, entitiesUpdateWithoutSheetsInput>, entitiesUncheckedUpdateWithoutSheetsInput>
  }

  export type sheets_dataUpdateOneRequiredWithoutSheetsNestedInput = {
    create?: XOR<sheets_dataCreateWithoutSheetsInput, sheets_dataUncheckedCreateWithoutSheetsInput>
    connectOrCreate?: sheets_dataCreateOrConnectWithoutSheetsInput
    upsert?: sheets_dataUpsertWithoutSheetsInput
    connect?: sheets_dataWhereUniqueInput
    update?: XOR<XOR<sheets_dataUpdateToOneWithWhereWithoutSheetsInput, sheets_dataUpdateWithoutSheetsInput>, sheets_dataUncheckedUpdateWithoutSheetsInput>
  }

  export type sheets_thumbnailsUpdateOneWithoutSheetsNestedInput = {
    create?: XOR<sheets_thumbnailsCreateWithoutSheetsInput, sheets_thumbnailsUncheckedCreateWithoutSheetsInput>
    connectOrCreate?: sheets_thumbnailsCreateOrConnectWithoutSheetsInput
    upsert?: sheets_thumbnailsUpsertWithoutSheetsInput
    disconnect?: sheets_thumbnailsWhereInput | boolean
    delete?: sheets_thumbnailsWhereInput | boolean
    connect?: sheets_thumbnailsWhereUniqueInput
    update?: XOR<XOR<sheets_thumbnailsUpdateToOneWithWhereWithoutSheetsInput, sheets_thumbnailsUpdateWithoutSheetsInput>, sheets_thumbnailsUncheckedUpdateWithoutSheetsInput>
  }

  export type sheetsCreateNestedManyWithoutSheets_dataInput = {
    create?: XOR<sheetsCreateWithoutSheets_dataInput, sheetsUncheckedCreateWithoutSheets_dataInput> | sheetsCreateWithoutSheets_dataInput[] | sheetsUncheckedCreateWithoutSheets_dataInput[]
    connectOrCreate?: sheetsCreateOrConnectWithoutSheets_dataInput | sheetsCreateOrConnectWithoutSheets_dataInput[]
    createMany?: sheetsCreateManySheets_dataInputEnvelope
    connect?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
  }

  export type sheetsUncheckedCreateNestedManyWithoutSheets_dataInput = {
    create?: XOR<sheetsCreateWithoutSheets_dataInput, sheetsUncheckedCreateWithoutSheets_dataInput> | sheetsCreateWithoutSheets_dataInput[] | sheetsUncheckedCreateWithoutSheets_dataInput[]
    connectOrCreate?: sheetsCreateOrConnectWithoutSheets_dataInput | sheetsCreateOrConnectWithoutSheets_dataInput[]
    createMany?: sheetsCreateManySheets_dataInputEnvelope
    connect?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
  }

  export type sheetsUpdateManyWithoutSheets_dataNestedInput = {
    create?: XOR<sheetsCreateWithoutSheets_dataInput, sheetsUncheckedCreateWithoutSheets_dataInput> | sheetsCreateWithoutSheets_dataInput[] | sheetsUncheckedCreateWithoutSheets_dataInput[]
    connectOrCreate?: sheetsCreateOrConnectWithoutSheets_dataInput | sheetsCreateOrConnectWithoutSheets_dataInput[]
    upsert?: sheetsUpsertWithWhereUniqueWithoutSheets_dataInput | sheetsUpsertWithWhereUniqueWithoutSheets_dataInput[]
    createMany?: sheetsCreateManySheets_dataInputEnvelope
    set?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
    disconnect?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
    delete?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
    connect?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
    update?: sheetsUpdateWithWhereUniqueWithoutSheets_dataInput | sheetsUpdateWithWhereUniqueWithoutSheets_dataInput[]
    updateMany?: sheetsUpdateManyWithWhereWithoutSheets_dataInput | sheetsUpdateManyWithWhereWithoutSheets_dataInput[]
    deleteMany?: sheetsScalarWhereInput | sheetsScalarWhereInput[]
  }

  export type sheetsUncheckedUpdateManyWithoutSheets_dataNestedInput = {
    create?: XOR<sheetsCreateWithoutSheets_dataInput, sheetsUncheckedCreateWithoutSheets_dataInput> | sheetsCreateWithoutSheets_dataInput[] | sheetsUncheckedCreateWithoutSheets_dataInput[]
    connectOrCreate?: sheetsCreateOrConnectWithoutSheets_dataInput | sheetsCreateOrConnectWithoutSheets_dataInput[]
    upsert?: sheetsUpsertWithWhereUniqueWithoutSheets_dataInput | sheetsUpsertWithWhereUniqueWithoutSheets_dataInput[]
    createMany?: sheetsCreateManySheets_dataInputEnvelope
    set?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
    disconnect?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
    delete?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
    connect?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
    update?: sheetsUpdateWithWhereUniqueWithoutSheets_dataInput | sheetsUpdateWithWhereUniqueWithoutSheets_dataInput[]
    updateMany?: sheetsUpdateManyWithWhereWithoutSheets_dataInput | sheetsUpdateManyWithWhereWithoutSheets_dataInput[]
    deleteMany?: sheetsScalarWhereInput | sheetsScalarWhereInput[]
  }

  export type sheetsCreateNestedManyWithoutSheets_thumbnailsInput = {
    create?: XOR<sheetsCreateWithoutSheets_thumbnailsInput, sheetsUncheckedCreateWithoutSheets_thumbnailsInput> | sheetsCreateWithoutSheets_thumbnailsInput[] | sheetsUncheckedCreateWithoutSheets_thumbnailsInput[]
    connectOrCreate?: sheetsCreateOrConnectWithoutSheets_thumbnailsInput | sheetsCreateOrConnectWithoutSheets_thumbnailsInput[]
    createMany?: sheetsCreateManySheets_thumbnailsInputEnvelope
    connect?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
  }

  export type sheetsUncheckedCreateNestedManyWithoutSheets_thumbnailsInput = {
    create?: XOR<sheetsCreateWithoutSheets_thumbnailsInput, sheetsUncheckedCreateWithoutSheets_thumbnailsInput> | sheetsCreateWithoutSheets_thumbnailsInput[] | sheetsUncheckedCreateWithoutSheets_thumbnailsInput[]
    connectOrCreate?: sheetsCreateOrConnectWithoutSheets_thumbnailsInput | sheetsCreateOrConnectWithoutSheets_thumbnailsInput[]
    createMany?: sheetsCreateManySheets_thumbnailsInputEnvelope
    connect?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
  }

  export type sheetsUpdateManyWithoutSheets_thumbnailsNestedInput = {
    create?: XOR<sheetsCreateWithoutSheets_thumbnailsInput, sheetsUncheckedCreateWithoutSheets_thumbnailsInput> | sheetsCreateWithoutSheets_thumbnailsInput[] | sheetsUncheckedCreateWithoutSheets_thumbnailsInput[]
    connectOrCreate?: sheetsCreateOrConnectWithoutSheets_thumbnailsInput | sheetsCreateOrConnectWithoutSheets_thumbnailsInput[]
    upsert?: sheetsUpsertWithWhereUniqueWithoutSheets_thumbnailsInput | sheetsUpsertWithWhereUniqueWithoutSheets_thumbnailsInput[]
    createMany?: sheetsCreateManySheets_thumbnailsInputEnvelope
    set?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
    disconnect?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
    delete?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
    connect?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
    update?: sheetsUpdateWithWhereUniqueWithoutSheets_thumbnailsInput | sheetsUpdateWithWhereUniqueWithoutSheets_thumbnailsInput[]
    updateMany?: sheetsUpdateManyWithWhereWithoutSheets_thumbnailsInput | sheetsUpdateManyWithWhereWithoutSheets_thumbnailsInput[]
    deleteMany?: sheetsScalarWhereInput | sheetsScalarWhereInput[]
  }

  export type sheetsUncheckedUpdateManyWithoutSheets_thumbnailsNestedInput = {
    create?: XOR<sheetsCreateWithoutSheets_thumbnailsInput, sheetsUncheckedCreateWithoutSheets_thumbnailsInput> | sheetsCreateWithoutSheets_thumbnailsInput[] | sheetsUncheckedCreateWithoutSheets_thumbnailsInput[]
    connectOrCreate?: sheetsCreateOrConnectWithoutSheets_thumbnailsInput | sheetsCreateOrConnectWithoutSheets_thumbnailsInput[]
    upsert?: sheetsUpsertWithWhereUniqueWithoutSheets_thumbnailsInput | sheetsUpsertWithWhereUniqueWithoutSheets_thumbnailsInput[]
    createMany?: sheetsCreateManySheets_thumbnailsInputEnvelope
    set?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
    disconnect?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
    delete?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
    connect?: sheetsWhereUniqueInput | sheetsWhereUniqueInput[]
    update?: sheetsUpdateWithWhereUniqueWithoutSheets_thumbnailsInput | sheetsUpdateWithWhereUniqueWithoutSheets_thumbnailsInput[]
    updateMany?: sheetsUpdateManyWithWhereWithoutSheets_thumbnailsInput | sheetsUpdateManyWithWhereWithoutSheets_thumbnailsInput[]
    deleteMany?: sheetsScalarWhereInput | sheetsScalarWhereInput[]
  }

  export type tables_picturesCreateNestedOneWithoutTablesInput = {
    create?: XOR<tables_picturesCreateWithoutTablesInput, tables_picturesUncheckedCreateWithoutTablesInput>
    connectOrCreate?: tables_picturesCreateOrConnectWithoutTablesInput
    connect?: tables_picturesWhereUniqueInput
  }

  export type tables_membersCreateNestedManyWithoutTablesInput = {
    create?: XOR<tables_membersCreateWithoutTablesInput, tables_membersUncheckedCreateWithoutTablesInput> | tables_membersCreateWithoutTablesInput[] | tables_membersUncheckedCreateWithoutTablesInput[]
    connectOrCreate?: tables_membersCreateOrConnectWithoutTablesInput | tables_membersCreateOrConnectWithoutTablesInput[]
    createMany?: tables_membersCreateManyTablesInputEnvelope
    connect?: tables_membersWhereUniqueInput | tables_membersWhereUniqueInput[]
  }

  export type tables_messages_logsCreateNestedManyWithoutTablesInput = {
    create?: XOR<tables_messages_logsCreateWithoutTablesInput, tables_messages_logsUncheckedCreateWithoutTablesInput> | tables_messages_logsCreateWithoutTablesInput[] | tables_messages_logsUncheckedCreateWithoutTablesInput[]
    connectOrCreate?: tables_messages_logsCreateOrConnectWithoutTablesInput | tables_messages_logsCreateOrConnectWithoutTablesInput[]
    createMany?: tables_messages_logsCreateManyTablesInputEnvelope
    connect?: tables_messages_logsWhereUniqueInput | tables_messages_logsWhereUniqueInput[]
  }

  export type tables_tabletopsCreateNestedManyWithoutTablesInput = {
    create?: XOR<tables_tabletopsCreateWithoutTablesInput, tables_tabletopsUncheckedCreateWithoutTablesInput> | tables_tabletopsCreateWithoutTablesInput[] | tables_tabletopsUncheckedCreateWithoutTablesInput[]
    connectOrCreate?: tables_tabletopsCreateOrConnectWithoutTablesInput | tables_tabletopsCreateOrConnectWithoutTablesInput[]
    createMany?: tables_tabletopsCreateManyTablesInputEnvelope
    connect?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
  }

  export type tables_membersUncheckedCreateNestedManyWithoutTablesInput = {
    create?: XOR<tables_membersCreateWithoutTablesInput, tables_membersUncheckedCreateWithoutTablesInput> | tables_membersCreateWithoutTablesInput[] | tables_membersUncheckedCreateWithoutTablesInput[]
    connectOrCreate?: tables_membersCreateOrConnectWithoutTablesInput | tables_membersCreateOrConnectWithoutTablesInput[]
    createMany?: tables_membersCreateManyTablesInputEnvelope
    connect?: tables_membersWhereUniqueInput | tables_membersWhereUniqueInput[]
  }

  export type tables_messages_logsUncheckedCreateNestedManyWithoutTablesInput = {
    create?: XOR<tables_messages_logsCreateWithoutTablesInput, tables_messages_logsUncheckedCreateWithoutTablesInput> | tables_messages_logsCreateWithoutTablesInput[] | tables_messages_logsUncheckedCreateWithoutTablesInput[]
    connectOrCreate?: tables_messages_logsCreateOrConnectWithoutTablesInput | tables_messages_logsCreateOrConnectWithoutTablesInput[]
    createMany?: tables_messages_logsCreateManyTablesInputEnvelope
    connect?: tables_messages_logsWhereUniqueInput | tables_messages_logsWhereUniqueInput[]
  }

  export type tables_tabletopsUncheckedCreateNestedManyWithoutTablesInput = {
    create?: XOR<tables_tabletopsCreateWithoutTablesInput, tables_tabletopsUncheckedCreateWithoutTablesInput> | tables_tabletopsCreateWithoutTablesInput[] | tables_tabletopsUncheckedCreateWithoutTablesInput[]
    connectOrCreate?: tables_tabletopsCreateOrConnectWithoutTablesInput | tables_tabletopsCreateOrConnectWithoutTablesInput[]
    createMany?: tables_tabletopsCreateManyTablesInputEnvelope
    connect?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
  }

  export type tables_picturesUpdateOneWithoutTablesNestedInput = {
    create?: XOR<tables_picturesCreateWithoutTablesInput, tables_picturesUncheckedCreateWithoutTablesInput>
    connectOrCreate?: tables_picturesCreateOrConnectWithoutTablesInput
    upsert?: tables_picturesUpsertWithoutTablesInput
    disconnect?: tables_picturesWhereInput | boolean
    delete?: tables_picturesWhereInput | boolean
    connect?: tables_picturesWhereUniqueInput
    update?: XOR<XOR<tables_picturesUpdateToOneWithWhereWithoutTablesInput, tables_picturesUpdateWithoutTablesInput>, tables_picturesUncheckedUpdateWithoutTablesInput>
  }

  export type tables_membersUpdateManyWithoutTablesNestedInput = {
    create?: XOR<tables_membersCreateWithoutTablesInput, tables_membersUncheckedCreateWithoutTablesInput> | tables_membersCreateWithoutTablesInput[] | tables_membersUncheckedCreateWithoutTablesInput[]
    connectOrCreate?: tables_membersCreateOrConnectWithoutTablesInput | tables_membersCreateOrConnectWithoutTablesInput[]
    upsert?: tables_membersUpsertWithWhereUniqueWithoutTablesInput | tables_membersUpsertWithWhereUniqueWithoutTablesInput[]
    createMany?: tables_membersCreateManyTablesInputEnvelope
    set?: tables_membersWhereUniqueInput | tables_membersWhereUniqueInput[]
    disconnect?: tables_membersWhereUniqueInput | tables_membersWhereUniqueInput[]
    delete?: tables_membersWhereUniqueInput | tables_membersWhereUniqueInput[]
    connect?: tables_membersWhereUniqueInput | tables_membersWhereUniqueInput[]
    update?: tables_membersUpdateWithWhereUniqueWithoutTablesInput | tables_membersUpdateWithWhereUniqueWithoutTablesInput[]
    updateMany?: tables_membersUpdateManyWithWhereWithoutTablesInput | tables_membersUpdateManyWithWhereWithoutTablesInput[]
    deleteMany?: tables_membersScalarWhereInput | tables_membersScalarWhereInput[]
  }

  export type tables_messages_logsUpdateManyWithoutTablesNestedInput = {
    create?: XOR<tables_messages_logsCreateWithoutTablesInput, tables_messages_logsUncheckedCreateWithoutTablesInput> | tables_messages_logsCreateWithoutTablesInput[] | tables_messages_logsUncheckedCreateWithoutTablesInput[]
    connectOrCreate?: tables_messages_logsCreateOrConnectWithoutTablesInput | tables_messages_logsCreateOrConnectWithoutTablesInput[]
    upsert?: tables_messages_logsUpsertWithWhereUniqueWithoutTablesInput | tables_messages_logsUpsertWithWhereUniqueWithoutTablesInput[]
    createMany?: tables_messages_logsCreateManyTablesInputEnvelope
    set?: tables_messages_logsWhereUniqueInput | tables_messages_logsWhereUniqueInput[]
    disconnect?: tables_messages_logsWhereUniqueInput | tables_messages_logsWhereUniqueInput[]
    delete?: tables_messages_logsWhereUniqueInput | tables_messages_logsWhereUniqueInput[]
    connect?: tables_messages_logsWhereUniqueInput | tables_messages_logsWhereUniqueInput[]
    update?: tables_messages_logsUpdateWithWhereUniqueWithoutTablesInput | tables_messages_logsUpdateWithWhereUniqueWithoutTablesInput[]
    updateMany?: tables_messages_logsUpdateManyWithWhereWithoutTablesInput | tables_messages_logsUpdateManyWithWhereWithoutTablesInput[]
    deleteMany?: tables_messages_logsScalarWhereInput | tables_messages_logsScalarWhereInput[]
  }

  export type tables_tabletopsUpdateManyWithoutTablesNestedInput = {
    create?: XOR<tables_tabletopsCreateWithoutTablesInput, tables_tabletopsUncheckedCreateWithoutTablesInput> | tables_tabletopsCreateWithoutTablesInput[] | tables_tabletopsUncheckedCreateWithoutTablesInput[]
    connectOrCreate?: tables_tabletopsCreateOrConnectWithoutTablesInput | tables_tabletopsCreateOrConnectWithoutTablesInput[]
    upsert?: tables_tabletopsUpsertWithWhereUniqueWithoutTablesInput | tables_tabletopsUpsertWithWhereUniqueWithoutTablesInput[]
    createMany?: tables_tabletopsCreateManyTablesInputEnvelope
    set?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
    disconnect?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
    delete?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
    connect?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
    update?: tables_tabletopsUpdateWithWhereUniqueWithoutTablesInput | tables_tabletopsUpdateWithWhereUniqueWithoutTablesInput[]
    updateMany?: tables_tabletopsUpdateManyWithWhereWithoutTablesInput | tables_tabletopsUpdateManyWithWhereWithoutTablesInput[]
    deleteMany?: tables_tabletopsScalarWhereInput | tables_tabletopsScalarWhereInput[]
  }

  export type tables_membersUncheckedUpdateManyWithoutTablesNestedInput = {
    create?: XOR<tables_membersCreateWithoutTablesInput, tables_membersUncheckedCreateWithoutTablesInput> | tables_membersCreateWithoutTablesInput[] | tables_membersUncheckedCreateWithoutTablesInput[]
    connectOrCreate?: tables_membersCreateOrConnectWithoutTablesInput | tables_membersCreateOrConnectWithoutTablesInput[]
    upsert?: tables_membersUpsertWithWhereUniqueWithoutTablesInput | tables_membersUpsertWithWhereUniqueWithoutTablesInput[]
    createMany?: tables_membersCreateManyTablesInputEnvelope
    set?: tables_membersWhereUniqueInput | tables_membersWhereUniqueInput[]
    disconnect?: tables_membersWhereUniqueInput | tables_membersWhereUniqueInput[]
    delete?: tables_membersWhereUniqueInput | tables_membersWhereUniqueInput[]
    connect?: tables_membersWhereUniqueInput | tables_membersWhereUniqueInput[]
    update?: tables_membersUpdateWithWhereUniqueWithoutTablesInput | tables_membersUpdateWithWhereUniqueWithoutTablesInput[]
    updateMany?: tables_membersUpdateManyWithWhereWithoutTablesInput | tables_membersUpdateManyWithWhereWithoutTablesInput[]
    deleteMany?: tables_membersScalarWhereInput | tables_membersScalarWhereInput[]
  }

  export type tables_messages_logsUncheckedUpdateManyWithoutTablesNestedInput = {
    create?: XOR<tables_messages_logsCreateWithoutTablesInput, tables_messages_logsUncheckedCreateWithoutTablesInput> | tables_messages_logsCreateWithoutTablesInput[] | tables_messages_logsUncheckedCreateWithoutTablesInput[]
    connectOrCreate?: tables_messages_logsCreateOrConnectWithoutTablesInput | tables_messages_logsCreateOrConnectWithoutTablesInput[]
    upsert?: tables_messages_logsUpsertWithWhereUniqueWithoutTablesInput | tables_messages_logsUpsertWithWhereUniqueWithoutTablesInput[]
    createMany?: tables_messages_logsCreateManyTablesInputEnvelope
    set?: tables_messages_logsWhereUniqueInput | tables_messages_logsWhereUniqueInput[]
    disconnect?: tables_messages_logsWhereUniqueInput | tables_messages_logsWhereUniqueInput[]
    delete?: tables_messages_logsWhereUniqueInput | tables_messages_logsWhereUniqueInput[]
    connect?: tables_messages_logsWhereUniqueInput | tables_messages_logsWhereUniqueInput[]
    update?: tables_messages_logsUpdateWithWhereUniqueWithoutTablesInput | tables_messages_logsUpdateWithWhereUniqueWithoutTablesInput[]
    updateMany?: tables_messages_logsUpdateManyWithWhereWithoutTablesInput | tables_messages_logsUpdateManyWithWhereWithoutTablesInput[]
    deleteMany?: tables_messages_logsScalarWhereInput | tables_messages_logsScalarWhereInput[]
  }

  export type tables_tabletopsUncheckedUpdateManyWithoutTablesNestedInput = {
    create?: XOR<tables_tabletopsCreateWithoutTablesInput, tables_tabletopsUncheckedCreateWithoutTablesInput> | tables_tabletopsCreateWithoutTablesInput[] | tables_tabletopsUncheckedCreateWithoutTablesInput[]
    connectOrCreate?: tables_tabletopsCreateOrConnectWithoutTablesInput | tables_tabletopsCreateOrConnectWithoutTablesInput[]
    upsert?: tables_tabletopsUpsertWithWhereUniqueWithoutTablesInput | tables_tabletopsUpsertWithWhereUniqueWithoutTablesInput[]
    createMany?: tables_tabletopsCreateManyTablesInputEnvelope
    set?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
    disconnect?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
    delete?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
    connect?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
    update?: tables_tabletopsUpdateWithWhereUniqueWithoutTablesInput | tables_tabletopsUpdateWithWhereUniqueWithoutTablesInput[]
    updateMany?: tables_tabletopsUpdateManyWithWhereWithoutTablesInput | tables_tabletopsUpdateManyWithWhereWithoutTablesInput[]
    deleteMany?: tables_tabletopsScalarWhereInput | tables_tabletopsScalarWhereInput[]
  }

  export type entitiesCreateNestedOneWithoutTables_membersInput = {
    create?: XOR<entitiesCreateWithoutTables_membersInput, entitiesUncheckedCreateWithoutTables_membersInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutTables_membersInput
    connect?: entitiesWhereUniqueInput
  }

  export type tablesCreateNestedOneWithoutTables_membersInput = {
    create?: XOR<tablesCreateWithoutTables_membersInput, tablesUncheckedCreateWithoutTables_membersInput>
    connectOrCreate?: tablesCreateOrConnectWithoutTables_membersInput
    connect?: tablesWhereUniqueInput
  }

  export type entitiesUpdateOneRequiredWithoutTables_membersNestedInput = {
    create?: XOR<entitiesCreateWithoutTables_membersInput, entitiesUncheckedCreateWithoutTables_membersInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutTables_membersInput
    upsert?: entitiesUpsertWithoutTables_membersInput
    connect?: entitiesWhereUniqueInput
    update?: XOR<XOR<entitiesUpdateToOneWithWhereWithoutTables_membersInput, entitiesUpdateWithoutTables_membersInput>, entitiesUncheckedUpdateWithoutTables_membersInput>
  }

  export type tablesUpdateOneRequiredWithoutTables_membersNestedInput = {
    create?: XOR<tablesCreateWithoutTables_membersInput, tablesUncheckedCreateWithoutTables_membersInput>
    connectOrCreate?: tablesCreateOrConnectWithoutTables_membersInput
    upsert?: tablesUpsertWithoutTables_membersInput
    connect?: tablesWhereUniqueInput
    update?: XOR<XOR<tablesUpdateToOneWithWhereWithoutTables_membersInput, tablesUpdateWithoutTables_membersInput>, tablesUncheckedUpdateWithoutTables_membersInput>
  }

  export type entitiesCreateNestedOneWithoutTables_messages_logsInput = {
    create?: XOR<entitiesCreateWithoutTables_messages_logsInput, entitiesUncheckedCreateWithoutTables_messages_logsInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutTables_messages_logsInput
    connect?: entitiesWhereUniqueInput
  }

  export type tablesCreateNestedOneWithoutTables_messages_logsInput = {
    create?: XOR<tablesCreateWithoutTables_messages_logsInput, tablesUncheckedCreateWithoutTables_messages_logsInput>
    connectOrCreate?: tablesCreateOrConnectWithoutTables_messages_logsInput
    connect?: tablesWhereUniqueInput
  }

  export type entitiesUpdateOneRequiredWithoutTables_messages_logsNestedInput = {
    create?: XOR<entitiesCreateWithoutTables_messages_logsInput, entitiesUncheckedCreateWithoutTables_messages_logsInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutTables_messages_logsInput
    upsert?: entitiesUpsertWithoutTables_messages_logsInput
    connect?: entitiesWhereUniqueInput
    update?: XOR<XOR<entitiesUpdateToOneWithWhereWithoutTables_messages_logsInput, entitiesUpdateWithoutTables_messages_logsInput>, entitiesUncheckedUpdateWithoutTables_messages_logsInput>
  }

  export type tablesUpdateOneRequiredWithoutTables_messages_logsNestedInput = {
    create?: XOR<tablesCreateWithoutTables_messages_logsInput, tablesUncheckedCreateWithoutTables_messages_logsInput>
    connectOrCreate?: tablesCreateOrConnectWithoutTables_messages_logsInput
    upsert?: tablesUpsertWithoutTables_messages_logsInput
    connect?: tablesWhereUniqueInput
    update?: XOR<XOR<tablesUpdateToOneWithWhereWithoutTables_messages_logsInput, tablesUpdateWithoutTables_messages_logsInput>, tablesUncheckedUpdateWithoutTables_messages_logsInput>
  }

  export type tablesCreateNestedManyWithoutTables_picturesInput = {
    create?: XOR<tablesCreateWithoutTables_picturesInput, tablesUncheckedCreateWithoutTables_picturesInput> | tablesCreateWithoutTables_picturesInput[] | tablesUncheckedCreateWithoutTables_picturesInput[]
    connectOrCreate?: tablesCreateOrConnectWithoutTables_picturesInput | tablesCreateOrConnectWithoutTables_picturesInput[]
    createMany?: tablesCreateManyTables_picturesInputEnvelope
    connect?: tablesWhereUniqueInput | tablesWhereUniqueInput[]
  }

  export type tablesUncheckedCreateNestedManyWithoutTables_picturesInput = {
    create?: XOR<tablesCreateWithoutTables_picturesInput, tablesUncheckedCreateWithoutTables_picturesInput> | tablesCreateWithoutTables_picturesInput[] | tablesUncheckedCreateWithoutTables_picturesInput[]
    connectOrCreate?: tablesCreateOrConnectWithoutTables_picturesInput | tablesCreateOrConnectWithoutTables_picturesInput[]
    createMany?: tablesCreateManyTables_picturesInputEnvelope
    connect?: tablesWhereUniqueInput | tablesWhereUniqueInput[]
  }

  export type tablesUpdateManyWithoutTables_picturesNestedInput = {
    create?: XOR<tablesCreateWithoutTables_picturesInput, tablesUncheckedCreateWithoutTables_picturesInput> | tablesCreateWithoutTables_picturesInput[] | tablesUncheckedCreateWithoutTables_picturesInput[]
    connectOrCreate?: tablesCreateOrConnectWithoutTables_picturesInput | tablesCreateOrConnectWithoutTables_picturesInput[]
    upsert?: tablesUpsertWithWhereUniqueWithoutTables_picturesInput | tablesUpsertWithWhereUniqueWithoutTables_picturesInput[]
    createMany?: tablesCreateManyTables_picturesInputEnvelope
    set?: tablesWhereUniqueInput | tablesWhereUniqueInput[]
    disconnect?: tablesWhereUniqueInput | tablesWhereUniqueInput[]
    delete?: tablesWhereUniqueInput | tablesWhereUniqueInput[]
    connect?: tablesWhereUniqueInput | tablesWhereUniqueInput[]
    update?: tablesUpdateWithWhereUniqueWithoutTables_picturesInput | tablesUpdateWithWhereUniqueWithoutTables_picturesInput[]
    updateMany?: tablesUpdateManyWithWhereWithoutTables_picturesInput | tablesUpdateManyWithWhereWithoutTables_picturesInput[]
    deleteMany?: tablesScalarWhereInput | tablesScalarWhereInput[]
  }

  export type tablesUncheckedUpdateManyWithoutTables_picturesNestedInput = {
    create?: XOR<tablesCreateWithoutTables_picturesInput, tablesUncheckedCreateWithoutTables_picturesInput> | tablesCreateWithoutTables_picturesInput[] | tablesUncheckedCreateWithoutTables_picturesInput[]
    connectOrCreate?: tablesCreateOrConnectWithoutTables_picturesInput | tablesCreateOrConnectWithoutTables_picturesInput[]
    upsert?: tablesUpsertWithWhereUniqueWithoutTables_picturesInput | tablesUpsertWithWhereUniqueWithoutTables_picturesInput[]
    createMany?: tablesCreateManyTables_picturesInputEnvelope
    set?: tablesWhereUniqueInput | tablesWhereUniqueInput[]
    disconnect?: tablesWhereUniqueInput | tablesWhereUniqueInput[]
    delete?: tablesWhereUniqueInput | tablesWhereUniqueInput[]
    connect?: tablesWhereUniqueInput | tablesWhereUniqueInput[]
    update?: tablesUpdateWithWhereUniqueWithoutTables_picturesInput | tablesUpdateWithWhereUniqueWithoutTables_picturesInput[]
    updateMany?: tablesUpdateManyWithWhereWithoutTables_picturesInput | tablesUpdateManyWithWhereWithoutTables_picturesInput[]
    deleteMany?: tablesScalarWhereInput | tablesScalarWhereInput[]
  }

  export type entitiesCreateNestedOneWithoutTables_tabletopsInput = {
    create?: XOR<entitiesCreateWithoutTables_tabletopsInput, entitiesUncheckedCreateWithoutTables_tabletopsInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutTables_tabletopsInput
    connect?: entitiesWhereUniqueInput
  }

  export type tablesCreateNestedOneWithoutTables_tabletopsInput = {
    create?: XOR<tablesCreateWithoutTables_tabletopsInput, tablesUncheckedCreateWithoutTables_tabletopsInput>
    connectOrCreate?: tablesCreateOrConnectWithoutTables_tabletopsInput
    connect?: tablesWhereUniqueInput
  }

  export type tables_tabletops_dataCreateNestedOneWithoutTables_tabletopsInput = {
    create?: XOR<tables_tabletops_dataCreateWithoutTables_tabletopsInput, tables_tabletops_dataUncheckedCreateWithoutTables_tabletopsInput>
    connectOrCreate?: tables_tabletops_dataCreateOrConnectWithoutTables_tabletopsInput
    connect?: tables_tabletops_dataWhereUniqueInput
  }

  export type entitiesUpdateOneRequiredWithoutTables_tabletopsNestedInput = {
    create?: XOR<entitiesCreateWithoutTables_tabletopsInput, entitiesUncheckedCreateWithoutTables_tabletopsInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutTables_tabletopsInput
    upsert?: entitiesUpsertWithoutTables_tabletopsInput
    connect?: entitiesWhereUniqueInput
    update?: XOR<XOR<entitiesUpdateToOneWithWhereWithoutTables_tabletopsInput, entitiesUpdateWithoutTables_tabletopsInput>, entitiesUncheckedUpdateWithoutTables_tabletopsInput>
  }

  export type tablesUpdateOneRequiredWithoutTables_tabletopsNestedInput = {
    create?: XOR<tablesCreateWithoutTables_tabletopsInput, tablesUncheckedCreateWithoutTables_tabletopsInput>
    connectOrCreate?: tablesCreateOrConnectWithoutTables_tabletopsInput
    upsert?: tablesUpsertWithoutTables_tabletopsInput
    connect?: tablesWhereUniqueInput
    update?: XOR<XOR<tablesUpdateToOneWithWhereWithoutTables_tabletopsInput, tablesUpdateWithoutTables_tabletopsInput>, tablesUncheckedUpdateWithoutTables_tabletopsInput>
  }

  export type tables_tabletops_dataUpdateOneWithoutTables_tabletopsNestedInput = {
    create?: XOR<tables_tabletops_dataCreateWithoutTables_tabletopsInput, tables_tabletops_dataUncheckedCreateWithoutTables_tabletopsInput>
    connectOrCreate?: tables_tabletops_dataCreateOrConnectWithoutTables_tabletopsInput
    upsert?: tables_tabletops_dataUpsertWithoutTables_tabletopsInput
    disconnect?: tables_tabletops_dataWhereInput | boolean
    delete?: tables_tabletops_dataWhereInput | boolean
    connect?: tables_tabletops_dataWhereUniqueInput
    update?: XOR<XOR<tables_tabletops_dataUpdateToOneWithWhereWithoutTables_tabletopsInput, tables_tabletops_dataUpdateWithoutTables_tabletopsInput>, tables_tabletops_dataUncheckedUpdateWithoutTables_tabletopsInput>
  }

  export type tables_tabletopsCreateNestedManyWithoutTables_tabletops_dataInput = {
    create?: XOR<tables_tabletopsCreateWithoutTables_tabletops_dataInput, tables_tabletopsUncheckedCreateWithoutTables_tabletops_dataInput> | tables_tabletopsCreateWithoutTables_tabletops_dataInput[] | tables_tabletopsUncheckedCreateWithoutTables_tabletops_dataInput[]
    connectOrCreate?: tables_tabletopsCreateOrConnectWithoutTables_tabletops_dataInput | tables_tabletopsCreateOrConnectWithoutTables_tabletops_dataInput[]
    createMany?: tables_tabletopsCreateManyTables_tabletops_dataInputEnvelope
    connect?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
  }

  export type tables_tabletopsUncheckedCreateNestedManyWithoutTables_tabletops_dataInput = {
    create?: XOR<tables_tabletopsCreateWithoutTables_tabletops_dataInput, tables_tabletopsUncheckedCreateWithoutTables_tabletops_dataInput> | tables_tabletopsCreateWithoutTables_tabletops_dataInput[] | tables_tabletopsUncheckedCreateWithoutTables_tabletops_dataInput[]
    connectOrCreate?: tables_tabletopsCreateOrConnectWithoutTables_tabletops_dataInput | tables_tabletopsCreateOrConnectWithoutTables_tabletops_dataInput[]
    createMany?: tables_tabletopsCreateManyTables_tabletops_dataInputEnvelope
    connect?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
  }

  export type tables_tabletopsUpdateManyWithoutTables_tabletops_dataNestedInput = {
    create?: XOR<tables_tabletopsCreateWithoutTables_tabletops_dataInput, tables_tabletopsUncheckedCreateWithoutTables_tabletops_dataInput> | tables_tabletopsCreateWithoutTables_tabletops_dataInput[] | tables_tabletopsUncheckedCreateWithoutTables_tabletops_dataInput[]
    connectOrCreate?: tables_tabletopsCreateOrConnectWithoutTables_tabletops_dataInput | tables_tabletopsCreateOrConnectWithoutTables_tabletops_dataInput[]
    upsert?: tables_tabletopsUpsertWithWhereUniqueWithoutTables_tabletops_dataInput | tables_tabletopsUpsertWithWhereUniqueWithoutTables_tabletops_dataInput[]
    createMany?: tables_tabletopsCreateManyTables_tabletops_dataInputEnvelope
    set?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
    disconnect?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
    delete?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
    connect?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
    update?: tables_tabletopsUpdateWithWhereUniqueWithoutTables_tabletops_dataInput | tables_tabletopsUpdateWithWhereUniqueWithoutTables_tabletops_dataInput[]
    updateMany?: tables_tabletopsUpdateManyWithWhereWithoutTables_tabletops_dataInput | tables_tabletopsUpdateManyWithWhereWithoutTables_tabletops_dataInput[]
    deleteMany?: tables_tabletopsScalarWhereInput | tables_tabletopsScalarWhereInput[]
  }

  export type tables_tabletopsUncheckedUpdateManyWithoutTables_tabletops_dataNestedInput = {
    create?: XOR<tables_tabletopsCreateWithoutTables_tabletops_dataInput, tables_tabletopsUncheckedCreateWithoutTables_tabletops_dataInput> | tables_tabletopsCreateWithoutTables_tabletops_dataInput[] | tables_tabletopsUncheckedCreateWithoutTables_tabletops_dataInput[]
    connectOrCreate?: tables_tabletopsCreateOrConnectWithoutTables_tabletops_dataInput | tables_tabletopsCreateOrConnectWithoutTables_tabletops_dataInput[]
    upsert?: tables_tabletopsUpsertWithWhereUniqueWithoutTables_tabletops_dataInput | tables_tabletopsUpsertWithWhereUniqueWithoutTables_tabletops_dataInput[]
    createMany?: tables_tabletopsCreateManyTables_tabletops_dataInputEnvelope
    set?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
    disconnect?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
    delete?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
    connect?: tables_tabletopsWhereUniqueInput | tables_tabletopsWhereUniqueInput[]
    update?: tables_tabletopsUpdateWithWhereUniqueWithoutTables_tabletops_dataInput | tables_tabletopsUpdateWithWhereUniqueWithoutTables_tabletops_dataInput[]
    updateMany?: tables_tabletopsUpdateManyWithWhereWithoutTables_tabletops_dataInput | tables_tabletopsUpdateManyWithWhereWithoutTables_tabletops_dataInput[]
    deleteMany?: tables_tabletopsScalarWhereInput | tables_tabletopsScalarWhereInput[]
  }

  export type individualsCreateNestedOneWithoutUser_credentialsInput = {
    create?: XOR<individualsCreateWithoutUser_credentialsInput, individualsUncheckedCreateWithoutUser_credentialsInput>
    connectOrCreate?: individualsCreateOrConnectWithoutUser_credentialsInput
    connect?: individualsWhereUniqueInput
  }

  export type individualsUncheckedCreateNestedOneWithoutUser_credentialsInput = {
    create?: XOR<individualsCreateWithoutUser_credentialsInput, individualsUncheckedCreateWithoutUser_credentialsInput>
    connectOrCreate?: individualsCreateOrConnectWithoutUser_credentialsInput
    connect?: individualsWhereUniqueInput
  }

  export type individualsUpdateOneWithoutUser_credentialsNestedInput = {
    create?: XOR<individualsCreateWithoutUser_credentialsInput, individualsUncheckedCreateWithoutUser_credentialsInput>
    connectOrCreate?: individualsCreateOrConnectWithoutUser_credentialsInput
    upsert?: individualsUpsertWithoutUser_credentialsInput
    disconnect?: individualsWhereInput | boolean
    delete?: individualsWhereInput | boolean
    connect?: individualsWhereUniqueInput
    update?: XOR<XOR<individualsUpdateToOneWithWhereWithoutUser_credentialsInput, individualsUpdateWithoutUser_credentialsInput>, individualsUncheckedUpdateWithoutUser_credentialsInput>
  }

  export type individualsUncheckedUpdateOneWithoutUser_credentialsNestedInput = {
    create?: XOR<individualsCreateWithoutUser_credentialsInput, individualsUncheckedCreateWithoutUser_credentialsInput>
    connectOrCreate?: individualsCreateOrConnectWithoutUser_credentialsInput
    upsert?: individualsUpsertWithoutUser_credentialsInput
    disconnect?: individualsWhereInput | boolean
    delete?: individualsWhereInput | boolean
    connect?: individualsWhereUniqueInput
    update?: XOR<XOR<individualsUpdateToOneWithWhereWithoutUser_credentialsInput, individualsUpdateWithoutUser_credentialsInput>, individualsUncheckedUpdateWithoutUser_credentialsInput>
  }

  export type entitiesCreateNestedOneWithoutVideosInput = {
    create?: XOR<entitiesCreateWithoutVideosInput, entitiesUncheckedCreateWithoutVideosInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutVideosInput
    connect?: entitiesWhereUniqueInput
  }

  export type videos_dataCreateNestedOneWithoutVideosInput = {
    create?: XOR<videos_dataCreateWithoutVideosInput, videos_dataUncheckedCreateWithoutVideosInput>
    connectOrCreate?: videos_dataCreateOrConnectWithoutVideosInput
    connect?: videos_dataWhereUniqueInput
  }

  export type videos_thumbnailsCreateNestedOneWithoutVideosInput = {
    create?: XOR<videos_thumbnailsCreateWithoutVideosInput, videos_thumbnailsUncheckedCreateWithoutVideosInput>
    connectOrCreate?: videos_thumbnailsCreateOrConnectWithoutVideosInput
    connect?: videos_thumbnailsWhereUniqueInput
  }

  export type entitiesUpdateOneRequiredWithoutVideosNestedInput = {
    create?: XOR<entitiesCreateWithoutVideosInput, entitiesUncheckedCreateWithoutVideosInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutVideosInput
    upsert?: entitiesUpsertWithoutVideosInput
    connect?: entitiesWhereUniqueInput
    update?: XOR<XOR<entitiesUpdateToOneWithWhereWithoutVideosInput, entitiesUpdateWithoutVideosInput>, entitiesUncheckedUpdateWithoutVideosInput>
  }

  export type videos_dataUpdateOneRequiredWithoutVideosNestedInput = {
    create?: XOR<videos_dataCreateWithoutVideosInput, videos_dataUncheckedCreateWithoutVideosInput>
    connectOrCreate?: videos_dataCreateOrConnectWithoutVideosInput
    upsert?: videos_dataUpsertWithoutVideosInput
    connect?: videos_dataWhereUniqueInput
    update?: XOR<XOR<videos_dataUpdateToOneWithWhereWithoutVideosInput, videos_dataUpdateWithoutVideosInput>, videos_dataUncheckedUpdateWithoutVideosInput>
  }

  export type videos_thumbnailsUpdateOneWithoutVideosNestedInput = {
    create?: XOR<videos_thumbnailsCreateWithoutVideosInput, videos_thumbnailsUncheckedCreateWithoutVideosInput>
    connectOrCreate?: videos_thumbnailsCreateOrConnectWithoutVideosInput
    upsert?: videos_thumbnailsUpsertWithoutVideosInput
    disconnect?: videos_thumbnailsWhereInput | boolean
    delete?: videos_thumbnailsWhereInput | boolean
    connect?: videos_thumbnailsWhereUniqueInput
    update?: XOR<XOR<videos_thumbnailsUpdateToOneWithWhereWithoutVideosInput, videos_thumbnailsUpdateWithoutVideosInput>, videos_thumbnailsUncheckedUpdateWithoutVideosInput>
  }

  export type videosCreateNestedManyWithoutVideos_dataInput = {
    create?: XOR<videosCreateWithoutVideos_dataInput, videosUncheckedCreateWithoutVideos_dataInput> | videosCreateWithoutVideos_dataInput[] | videosUncheckedCreateWithoutVideos_dataInput[]
    connectOrCreate?: videosCreateOrConnectWithoutVideos_dataInput | videosCreateOrConnectWithoutVideos_dataInput[]
    createMany?: videosCreateManyVideos_dataInputEnvelope
    connect?: videosWhereUniqueInput | videosWhereUniqueInput[]
  }

  export type videosUncheckedCreateNestedManyWithoutVideos_dataInput = {
    create?: XOR<videosCreateWithoutVideos_dataInput, videosUncheckedCreateWithoutVideos_dataInput> | videosCreateWithoutVideos_dataInput[] | videosUncheckedCreateWithoutVideos_dataInput[]
    connectOrCreate?: videosCreateOrConnectWithoutVideos_dataInput | videosCreateOrConnectWithoutVideos_dataInput[]
    createMany?: videosCreateManyVideos_dataInputEnvelope
    connect?: videosWhereUniqueInput | videosWhereUniqueInput[]
  }

  export type videosUpdateManyWithoutVideos_dataNestedInput = {
    create?: XOR<videosCreateWithoutVideos_dataInput, videosUncheckedCreateWithoutVideos_dataInput> | videosCreateWithoutVideos_dataInput[] | videosUncheckedCreateWithoutVideos_dataInput[]
    connectOrCreate?: videosCreateOrConnectWithoutVideos_dataInput | videosCreateOrConnectWithoutVideos_dataInput[]
    upsert?: videosUpsertWithWhereUniqueWithoutVideos_dataInput | videosUpsertWithWhereUniqueWithoutVideos_dataInput[]
    createMany?: videosCreateManyVideos_dataInputEnvelope
    set?: videosWhereUniqueInput | videosWhereUniqueInput[]
    disconnect?: videosWhereUniqueInput | videosWhereUniqueInput[]
    delete?: videosWhereUniqueInput | videosWhereUniqueInput[]
    connect?: videosWhereUniqueInput | videosWhereUniqueInput[]
    update?: videosUpdateWithWhereUniqueWithoutVideos_dataInput | videosUpdateWithWhereUniqueWithoutVideos_dataInput[]
    updateMany?: videosUpdateManyWithWhereWithoutVideos_dataInput | videosUpdateManyWithWhereWithoutVideos_dataInput[]
    deleteMany?: videosScalarWhereInput | videosScalarWhereInput[]
  }

  export type videosUncheckedUpdateManyWithoutVideos_dataNestedInput = {
    create?: XOR<videosCreateWithoutVideos_dataInput, videosUncheckedCreateWithoutVideos_dataInput> | videosCreateWithoutVideos_dataInput[] | videosUncheckedCreateWithoutVideos_dataInput[]
    connectOrCreate?: videosCreateOrConnectWithoutVideos_dataInput | videosCreateOrConnectWithoutVideos_dataInput[]
    upsert?: videosUpsertWithWhereUniqueWithoutVideos_dataInput | videosUpsertWithWhereUniqueWithoutVideos_dataInput[]
    createMany?: videosCreateManyVideos_dataInputEnvelope
    set?: videosWhereUniqueInput | videosWhereUniqueInput[]
    disconnect?: videosWhereUniqueInput | videosWhereUniqueInput[]
    delete?: videosWhereUniqueInput | videosWhereUniqueInput[]
    connect?: videosWhereUniqueInput | videosWhereUniqueInput[]
    update?: videosUpdateWithWhereUniqueWithoutVideos_dataInput | videosUpdateWithWhereUniqueWithoutVideos_dataInput[]
    updateMany?: videosUpdateManyWithWhereWithoutVideos_dataInput | videosUpdateManyWithWhereWithoutVideos_dataInput[]
    deleteMany?: videosScalarWhereInput | videosScalarWhereInput[]
  }

  export type videosCreateNestedManyWithoutVideos_thumbnailsInput = {
    create?: XOR<videosCreateWithoutVideos_thumbnailsInput, videosUncheckedCreateWithoutVideos_thumbnailsInput> | videosCreateWithoutVideos_thumbnailsInput[] | videosUncheckedCreateWithoutVideos_thumbnailsInput[]
    connectOrCreate?: videosCreateOrConnectWithoutVideos_thumbnailsInput | videosCreateOrConnectWithoutVideos_thumbnailsInput[]
    createMany?: videosCreateManyVideos_thumbnailsInputEnvelope
    connect?: videosWhereUniqueInput | videosWhereUniqueInput[]
  }

  export type videosUncheckedCreateNestedManyWithoutVideos_thumbnailsInput = {
    create?: XOR<videosCreateWithoutVideos_thumbnailsInput, videosUncheckedCreateWithoutVideos_thumbnailsInput> | videosCreateWithoutVideos_thumbnailsInput[] | videosUncheckedCreateWithoutVideos_thumbnailsInput[]
    connectOrCreate?: videosCreateOrConnectWithoutVideos_thumbnailsInput | videosCreateOrConnectWithoutVideos_thumbnailsInput[]
    createMany?: videosCreateManyVideos_thumbnailsInputEnvelope
    connect?: videosWhereUniqueInput | videosWhereUniqueInput[]
  }

  export type videosUpdateManyWithoutVideos_thumbnailsNestedInput = {
    create?: XOR<videosCreateWithoutVideos_thumbnailsInput, videosUncheckedCreateWithoutVideos_thumbnailsInput> | videosCreateWithoutVideos_thumbnailsInput[] | videosUncheckedCreateWithoutVideos_thumbnailsInput[]
    connectOrCreate?: videosCreateOrConnectWithoutVideos_thumbnailsInput | videosCreateOrConnectWithoutVideos_thumbnailsInput[]
    upsert?: videosUpsertWithWhereUniqueWithoutVideos_thumbnailsInput | videosUpsertWithWhereUniqueWithoutVideos_thumbnailsInput[]
    createMany?: videosCreateManyVideos_thumbnailsInputEnvelope
    set?: videosWhereUniqueInput | videosWhereUniqueInput[]
    disconnect?: videosWhereUniqueInput | videosWhereUniqueInput[]
    delete?: videosWhereUniqueInput | videosWhereUniqueInput[]
    connect?: videosWhereUniqueInput | videosWhereUniqueInput[]
    update?: videosUpdateWithWhereUniqueWithoutVideos_thumbnailsInput | videosUpdateWithWhereUniqueWithoutVideos_thumbnailsInput[]
    updateMany?: videosUpdateManyWithWhereWithoutVideos_thumbnailsInput | videosUpdateManyWithWhereWithoutVideos_thumbnailsInput[]
    deleteMany?: videosScalarWhereInput | videosScalarWhereInput[]
  }

  export type videosUncheckedUpdateManyWithoutVideos_thumbnailsNestedInput = {
    create?: XOR<videosCreateWithoutVideos_thumbnailsInput, videosUncheckedCreateWithoutVideos_thumbnailsInput> | videosCreateWithoutVideos_thumbnailsInput[] | videosUncheckedCreateWithoutVideos_thumbnailsInput[]
    connectOrCreate?: videosCreateOrConnectWithoutVideos_thumbnailsInput | videosCreateOrConnectWithoutVideos_thumbnailsInput[]
    upsert?: videosUpsertWithWhereUniqueWithoutVideos_thumbnailsInput | videosUpsertWithWhereUniqueWithoutVideos_thumbnailsInput[]
    createMany?: videosCreateManyVideos_thumbnailsInputEnvelope
    set?: videosWhereUniqueInput | videosWhereUniqueInput[]
    disconnect?: videosWhereUniqueInput | videosWhereUniqueInput[]
    delete?: videosWhereUniqueInput | videosWhereUniqueInput[]
    connect?: videosWhereUniqueInput | videosWhereUniqueInput[]
    update?: videosUpdateWithWhereUniqueWithoutVideos_thumbnailsInput | videosUpdateWithWhereUniqueWithoutVideos_thumbnailsInput[]
    updateMany?: videosUpdateManyWithWhereWithoutVideos_thumbnailsInput | videosUpdateManyWithWhereWithoutVideos_thumbnailsInput[]
    deleteMany?: videosScalarWhereInput | videosScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[]
    notIn?: Buffer[]
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[]
    notIn?: Buffer[]
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type entitiesCreateWithoutCollectionsInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    contacts_contacts_contact_id_rootToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersCreateNestedManyWithoutEntitiesInput
    images?: imagesCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsCreateNestedManyWithoutEntitiesInput
    videos?: videosCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesUncheckedCreateWithoutCollectionsInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentUncheckedCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesUncheckedCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersUncheckedCreateNestedManyWithoutEntitiesInput
    images?: imagesUncheckedCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersUncheckedCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsUncheckedCreateNestedManyWithoutEntitiesInput
    videos?: videosUncheckedCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesCreateOrConnectWithoutCollectionsInput = {
    where: entitiesWhereUniqueInput
    create: XOR<entitiesCreateWithoutCollectionsInput, entitiesUncheckedCreateWithoutCollectionsInput>
  }

  export type collections_contentCreateWithoutCollectionsInput = {
    collections_content_id: string
    date_added: Date | string
    pinned: boolean
    date_pinned?: Date | string | null
    content: contentCreateNestedOneWithoutCollections_contentInput
  }

  export type collections_contentUncheckedCreateWithoutCollectionsInput = {
    collections_content_id: string
    content_id: string
    date_added: Date | string
    pinned: boolean
    date_pinned?: Date | string | null
  }

  export type collections_contentCreateOrConnectWithoutCollectionsInput = {
    where: collections_contentWhereUniqueInput
    create: XOR<collections_contentCreateWithoutCollectionsInput, collections_contentUncheckedCreateWithoutCollectionsInput>
  }

  export type collections_contentCreateManyCollectionsInputEnvelope = {
    data: collections_contentCreateManyCollectionsInput | collections_contentCreateManyCollectionsInput[]
    skipDuplicates?: boolean
  }

  export type entitiesUpsertWithoutCollectionsInput = {
    update: XOR<entitiesUpdateWithoutCollectionsInput, entitiesUncheckedUpdateWithoutCollectionsInput>
    create: XOR<entitiesCreateWithoutCollectionsInput, entitiesUncheckedCreateWithoutCollectionsInput>
    where?: entitiesWhereInput
  }

  export type entitiesUpdateToOneWithWhereWithoutCollectionsInput = {
    where?: entitiesWhereInput
    data: XOR<entitiesUpdateWithoutCollectionsInput, entitiesUncheckedUpdateWithoutCollectionsInput>
  }

  export type entitiesUpdateWithoutCollectionsInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    contacts_contacts_contact_id_rootToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUpdateManyWithoutEntitiesNestedInput
    images?: imagesUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUpdateManyWithoutEntitiesNestedInput
    videos?: videosUpdateManyWithoutEntitiesNestedInput
  }

  export type entitiesUncheckedUpdateWithoutCollectionsInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUncheckedUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    images?: imagesUncheckedUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUncheckedUpdateManyWithoutEntitiesNestedInput
    videos?: videosUncheckedUpdateManyWithoutEntitiesNestedInput
  }

  export type collections_contentUpsertWithWhereUniqueWithoutCollectionsInput = {
    where: collections_contentWhereUniqueInput
    update: XOR<collections_contentUpdateWithoutCollectionsInput, collections_contentUncheckedUpdateWithoutCollectionsInput>
    create: XOR<collections_contentCreateWithoutCollectionsInput, collections_contentUncheckedCreateWithoutCollectionsInput>
  }

  export type collections_contentUpdateWithWhereUniqueWithoutCollectionsInput = {
    where: collections_contentWhereUniqueInput
    data: XOR<collections_contentUpdateWithoutCollectionsInput, collections_contentUncheckedUpdateWithoutCollectionsInput>
  }

  export type collections_contentUpdateManyWithWhereWithoutCollectionsInput = {
    where: collections_contentScalarWhereInput
    data: XOR<collections_contentUpdateManyMutationInput, collections_contentUncheckedUpdateManyWithoutCollectionsInput>
  }

  export type collections_contentScalarWhereInput = {
    AND?: collections_contentScalarWhereInput | collections_contentScalarWhereInput[]
    OR?: collections_contentScalarWhereInput[]
    NOT?: collections_contentScalarWhereInput | collections_contentScalarWhereInput[]
    collections_content_id?: StringFilter<"collections_content"> | string
    collection_id?: StringFilter<"collections_content"> | string
    content_id?: StringFilter<"collections_content"> | string
    date_added?: DateTimeFilter<"collections_content"> | Date | string
    pinned?: BoolFilter<"collections_content"> | boolean
    date_pinned?: DateTimeNullableFilter<"collections_content"> | Date | string | null
  }

  export type collectionsCreateWithoutCollections_contentInput = {
    collection_id: string
    collection_name: string
    entities: entitiesCreateNestedOneWithoutCollectionsInput
  }

  export type collectionsUncheckedCreateWithoutCollections_contentInput = {
    collection_id: string
    collection_name: string
    entity_id: string
  }

  export type collectionsCreateOrConnectWithoutCollections_contentInput = {
    where: collectionsWhereUniqueInput
    create: XOR<collectionsCreateWithoutCollections_contentInput, collectionsUncheckedCreateWithoutCollections_contentInput>
  }

  export type contentCreateWithoutCollections_contentInput = {
    content_id: string
    content_type?: number | null
    entities_content?: entities_contentCreateNestedManyWithoutContentInput
    entities_dislikes?: entities_dislikesCreateNestedManyWithoutContentInput
    entities_likes?: entities_likesCreateNestedManyWithoutContentInput
  }

  export type contentUncheckedCreateWithoutCollections_contentInput = {
    content_id: string
    content_type?: number | null
    entities_content?: entities_contentUncheckedCreateNestedManyWithoutContentInput
    entities_dislikes?: entities_dislikesUncheckedCreateNestedManyWithoutContentInput
    entities_likes?: entities_likesUncheckedCreateNestedManyWithoutContentInput
  }

  export type contentCreateOrConnectWithoutCollections_contentInput = {
    where: contentWhereUniqueInput
    create: XOR<contentCreateWithoutCollections_contentInput, contentUncheckedCreateWithoutCollections_contentInput>
  }

  export type collectionsUpsertWithoutCollections_contentInput = {
    update: XOR<collectionsUpdateWithoutCollections_contentInput, collectionsUncheckedUpdateWithoutCollections_contentInput>
    create: XOR<collectionsCreateWithoutCollections_contentInput, collectionsUncheckedCreateWithoutCollections_contentInput>
    where?: collectionsWhereInput
  }

  export type collectionsUpdateToOneWithWhereWithoutCollections_contentInput = {
    where?: collectionsWhereInput
    data: XOR<collectionsUpdateWithoutCollections_contentInput, collectionsUncheckedUpdateWithoutCollections_contentInput>
  }

  export type collectionsUpdateWithoutCollections_contentInput = {
    collection_id?: StringFieldUpdateOperationsInput | string
    collection_name?: StringFieldUpdateOperationsInput | string
    entities?: entitiesUpdateOneRequiredWithoutCollectionsNestedInput
  }

  export type collectionsUncheckedUpdateWithoutCollections_contentInput = {
    collection_id?: StringFieldUpdateOperationsInput | string
    collection_name?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
  }

  export type contentUpsertWithoutCollections_contentInput = {
    update: XOR<contentUpdateWithoutCollections_contentInput, contentUncheckedUpdateWithoutCollections_contentInput>
    create: XOR<contentCreateWithoutCollections_contentInput, contentUncheckedCreateWithoutCollections_contentInput>
    where?: contentWhereInput
  }

  export type contentUpdateToOneWithWhereWithoutCollections_contentInput = {
    where?: contentWhereInput
    data: XOR<contentUpdateWithoutCollections_contentInput, contentUncheckedUpdateWithoutCollections_contentInput>
  }

  export type contentUpdateWithoutCollections_contentInput = {
    content_id?: StringFieldUpdateOperationsInput | string
    content_type?: NullableIntFieldUpdateOperationsInput | number | null
    entities_content?: entities_contentUpdateManyWithoutContentNestedInput
    entities_dislikes?: entities_dislikesUpdateManyWithoutContentNestedInput
    entities_likes?: entities_likesUpdateManyWithoutContentNestedInput
  }

  export type contentUncheckedUpdateWithoutCollections_contentInput = {
    content_id?: StringFieldUpdateOperationsInput | string
    content_type?: NullableIntFieldUpdateOperationsInput | number | null
    entities_content?: entities_contentUncheckedUpdateManyWithoutContentNestedInput
    entities_dislikes?: entities_dislikesUncheckedUpdateManyWithoutContentNestedInput
    entities_likes?: entities_likesUncheckedUpdateManyWithoutContentNestedInput
  }

  export type entitiesCreateWithoutContacts_contacts_contact_id_rootToentitiesInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersCreateNestedManyWithoutEntitiesInput
    images?: imagesCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsCreateNestedManyWithoutEntitiesInput
    videos?: videosCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesUncheckedCreateWithoutContacts_contacts_contact_id_rootToentitiesInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsUncheckedCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentUncheckedCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesUncheckedCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersUncheckedCreateNestedManyWithoutEntitiesInput
    images?: imagesUncheckedCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersUncheckedCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsUncheckedCreateNestedManyWithoutEntitiesInput
    videos?: videosUncheckedCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesCreateOrConnectWithoutContacts_contacts_contact_id_rootToentitiesInput = {
    where: entitiesWhereUniqueInput
    create: XOR<entitiesCreateWithoutContacts_contacts_contact_id_rootToentitiesInput, entitiesUncheckedCreateWithoutContacts_contacts_contact_id_rootToentitiesInput>
  }

  export type entitiesCreateWithoutContacts_contacts_contact_id_targetToentitiesInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    conversations_members?: conversations_membersCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersCreateNestedManyWithoutEntitiesInput
    images?: imagesCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsCreateNestedManyWithoutEntitiesInput
    videos?: videosCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesUncheckedCreateWithoutContacts_contacts_contact_id_targetToentitiesInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsUncheckedCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    conversations_members?: conversations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentUncheckedCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesUncheckedCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersUncheckedCreateNestedManyWithoutEntitiesInput
    images?: imagesUncheckedCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersUncheckedCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsUncheckedCreateNestedManyWithoutEntitiesInput
    videos?: videosUncheckedCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesCreateOrConnectWithoutContacts_contacts_contact_id_targetToentitiesInput = {
    where: entitiesWhereUniqueInput
    create: XOR<entitiesCreateWithoutContacts_contacts_contact_id_targetToentitiesInput, entitiesUncheckedCreateWithoutContacts_contacts_contact_id_targetToentitiesInput>
  }

  export type contacts_picturesCreateWithoutContactsInput = {
    contacts_pictures_id: string
    contact_picture_data: Buffer
    contact_picture_filename: string
  }

  export type contacts_picturesUncheckedCreateWithoutContactsInput = {
    contacts_pictures_id: string
    contact_picture_data: Buffer
    contact_picture_filename: string
  }

  export type contacts_picturesCreateOrConnectWithoutContactsInput = {
    where: contacts_picturesWhereUniqueInput
    create: XOR<contacts_picturesCreateWithoutContactsInput, contacts_picturesUncheckedCreateWithoutContactsInput>
  }

  export type entitiesUpsertWithoutContacts_contacts_contact_id_rootToentitiesInput = {
    update: XOR<entitiesUpdateWithoutContacts_contacts_contact_id_rootToentitiesInput, entitiesUncheckedUpdateWithoutContacts_contacts_contact_id_rootToentitiesInput>
    create: XOR<entitiesCreateWithoutContacts_contacts_contact_id_rootToentitiesInput, entitiesUncheckedCreateWithoutContacts_contacts_contact_id_rootToentitiesInput>
    where?: entitiesWhereInput
  }

  export type entitiesUpdateToOneWithWhereWithoutContacts_contacts_contact_id_rootToentitiesInput = {
    where?: entitiesWhereInput
    data: XOR<entitiesUpdateWithoutContacts_contacts_contact_id_rootToentitiesInput, entitiesUncheckedUpdateWithoutContacts_contacts_contact_id_rootToentitiesInput>
  }

  export type entitiesUpdateWithoutContacts_contacts_contact_id_rootToentitiesInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUpdateManyWithoutEntitiesNestedInput
    images?: imagesUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUpdateManyWithoutEntitiesNestedInput
    videos?: videosUpdateManyWithoutEntitiesNestedInput
  }

  export type entitiesUncheckedUpdateWithoutContacts_contacts_contact_id_rootToentitiesInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUncheckedUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUncheckedUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    images?: imagesUncheckedUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUncheckedUpdateManyWithoutEntitiesNestedInput
    videos?: videosUncheckedUpdateManyWithoutEntitiesNestedInput
  }

  export type entitiesUpsertWithoutContacts_contacts_contact_id_targetToentitiesInput = {
    update: XOR<entitiesUpdateWithoutContacts_contacts_contact_id_targetToentitiesInput, entitiesUncheckedUpdateWithoutContacts_contacts_contact_id_targetToentitiesInput>
    create: XOR<entitiesCreateWithoutContacts_contacts_contact_id_targetToentitiesInput, entitiesUncheckedCreateWithoutContacts_contacts_contact_id_targetToentitiesInput>
    where?: entitiesWhereInput
  }

  export type entitiesUpdateToOneWithWhereWithoutContacts_contacts_contact_id_targetToentitiesInput = {
    where?: entitiesWhereInput
    data: XOR<entitiesUpdateWithoutContacts_contacts_contact_id_targetToentitiesInput, entitiesUncheckedUpdateWithoutContacts_contacts_contact_id_targetToentitiesInput>
  }

  export type entitiesUpdateWithoutContacts_contacts_contact_id_targetToentitiesInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    conversations_members?: conversations_membersUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUpdateManyWithoutEntitiesNestedInput
    images?: imagesUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUpdateManyWithoutEntitiesNestedInput
    videos?: videosUpdateManyWithoutEntitiesNestedInput
  }

  export type entitiesUncheckedUpdateWithoutContacts_contacts_contact_id_targetToentitiesInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUncheckedUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    conversations_members?: conversations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUncheckedUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    images?: imagesUncheckedUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUncheckedUpdateManyWithoutEntitiesNestedInput
    videos?: videosUncheckedUpdateManyWithoutEntitiesNestedInput
  }

  export type contacts_picturesUpsertWithoutContactsInput = {
    update: XOR<contacts_picturesUpdateWithoutContactsInput, contacts_picturesUncheckedUpdateWithoutContactsInput>
    create: XOR<contacts_picturesCreateWithoutContactsInput, contacts_picturesUncheckedCreateWithoutContactsInput>
    where?: contacts_picturesWhereInput
  }

  export type contacts_picturesUpdateToOneWithWhereWithoutContactsInput = {
    where?: contacts_picturesWhereInput
    data: XOR<contacts_picturesUpdateWithoutContactsInput, contacts_picturesUncheckedUpdateWithoutContactsInput>
  }

  export type contacts_picturesUpdateWithoutContactsInput = {
    contacts_pictures_id?: StringFieldUpdateOperationsInput | string
    contact_picture_data?: BytesFieldUpdateOperationsInput | Buffer
    contact_picture_filename?: StringFieldUpdateOperationsInput | string
  }

  export type contacts_picturesUncheckedUpdateWithoutContactsInput = {
    contacts_pictures_id?: StringFieldUpdateOperationsInput | string
    contact_picture_data?: BytesFieldUpdateOperationsInput | Buffer
    contact_picture_filename?: StringFieldUpdateOperationsInput | string
  }

  export type contactsCreateWithoutContacts_picturesInput = {
    contact_id: string
    conversation_id: string
    contact_creation_date: Date | string
    last_message?: string | null
    last_contact_date?: Date | string | null
    entities_contacts_contact_id_rootToentities: entitiesCreateNestedOneWithoutContacts_contacts_contact_id_rootToentitiesInput
    entities_contacts_contact_id_targetToentities: entitiesCreateNestedOneWithoutContacts_contacts_contact_id_targetToentitiesInput
  }

  export type contactsUncheckedCreateWithoutContacts_picturesInput = {
    contact_id: string
    conversation_id: string
    contact_id_root: string
    contact_id_target: string
    contact_creation_date: Date | string
    last_message?: string | null
    last_contact_date?: Date | string | null
  }

  export type contactsCreateOrConnectWithoutContacts_picturesInput = {
    where: contactsWhereUniqueInput
    create: XOR<contactsCreateWithoutContacts_picturesInput, contactsUncheckedCreateWithoutContacts_picturesInput>
  }

  export type contactsCreateManyContacts_picturesInputEnvelope = {
    data: contactsCreateManyContacts_picturesInput | contactsCreateManyContacts_picturesInput[]
    skipDuplicates?: boolean
  }

  export type contactsUpsertWithWhereUniqueWithoutContacts_picturesInput = {
    where: contactsWhereUniqueInput
    update: XOR<contactsUpdateWithoutContacts_picturesInput, contactsUncheckedUpdateWithoutContacts_picturesInput>
    create: XOR<contactsCreateWithoutContacts_picturesInput, contactsUncheckedCreateWithoutContacts_picturesInput>
  }

  export type contactsUpdateWithWhereUniqueWithoutContacts_picturesInput = {
    where: contactsWhereUniqueInput
    data: XOR<contactsUpdateWithoutContacts_picturesInput, contactsUncheckedUpdateWithoutContacts_picturesInput>
  }

  export type contactsUpdateManyWithWhereWithoutContacts_picturesInput = {
    where: contactsScalarWhereInput
    data: XOR<contactsUpdateManyMutationInput, contactsUncheckedUpdateManyWithoutContacts_picturesInput>
  }

  export type contactsScalarWhereInput = {
    AND?: contactsScalarWhereInput | contactsScalarWhereInput[]
    OR?: contactsScalarWhereInput[]
    NOT?: contactsScalarWhereInput | contactsScalarWhereInput[]
    contact_id?: StringFilter<"contacts"> | string
    conversation_id?: StringFilter<"contacts"> | string
    contact_id_root?: StringFilter<"contacts"> | string
    contact_id_target?: StringFilter<"contacts"> | string
    contact_creation_date?: DateTimeFilter<"contacts"> | Date | string
    last_message?: StringNullableFilter<"contacts"> | string | null
    last_contact_date?: DateTimeNullableFilter<"contacts"> | Date | string | null
    contacts_pictures_id?: StringNullableFilter<"contacts"> | string | null
  }

  export type collections_contentCreateWithoutContentInput = {
    collections_content_id: string
    date_added: Date | string
    pinned: boolean
    date_pinned?: Date | string | null
    collections: collectionsCreateNestedOneWithoutCollections_contentInput
  }

  export type collections_contentUncheckedCreateWithoutContentInput = {
    collections_content_id: string
    collection_id: string
    date_added: Date | string
    pinned: boolean
    date_pinned?: Date | string | null
  }

  export type collections_contentCreateOrConnectWithoutContentInput = {
    where: collections_contentWhereUniqueInput
    create: XOR<collections_contentCreateWithoutContentInput, collections_contentUncheckedCreateWithoutContentInput>
  }

  export type collections_contentCreateManyContentInputEnvelope = {
    data: collections_contentCreateManyContentInput | collections_contentCreateManyContentInput[]
    skipDuplicates?: boolean
  }

  export type entities_contentCreateWithoutContentInput = {
    entities_content_id: string
    date_added: Date | string
    pinned: boolean
    date_pinned?: Date | string | null
    entities: entitiesCreateNestedOneWithoutEntities_contentInput
  }

  export type entities_contentUncheckedCreateWithoutContentInput = {
    entities_content_id: string
    entity_id: string
    date_added: Date | string
    pinned: boolean
    date_pinned?: Date | string | null
  }

  export type entities_contentCreateOrConnectWithoutContentInput = {
    where: entities_contentWhereUniqueInput
    create: XOR<entities_contentCreateWithoutContentInput, entities_contentUncheckedCreateWithoutContentInput>
  }

  export type entities_contentCreateManyContentInputEnvelope = {
    data: entities_contentCreateManyContentInput | entities_contentCreateManyContentInput[]
    skipDuplicates?: boolean
  }

  export type entities_dislikesCreateWithoutContentInput = {
    dislike_id: string
    entities: entitiesCreateNestedOneWithoutEntities_dislikesInput
  }

  export type entities_dislikesUncheckedCreateWithoutContentInput = {
    dislike_id: string
    entity_id: string
  }

  export type entities_dislikesCreateOrConnectWithoutContentInput = {
    where: entities_dislikesWhereUniqueInput
    create: XOR<entities_dislikesCreateWithoutContentInput, entities_dislikesUncheckedCreateWithoutContentInput>
  }

  export type entities_dislikesCreateManyContentInputEnvelope = {
    data: entities_dislikesCreateManyContentInput | entities_dislikesCreateManyContentInput[]
    skipDuplicates?: boolean
  }

  export type entities_likesCreateWithoutContentInput = {
    like_id: string
    entities: entitiesCreateNestedOneWithoutEntities_likesInput
  }

  export type entities_likesUncheckedCreateWithoutContentInput = {
    like_id: string
    entity_id: string
  }

  export type entities_likesCreateOrConnectWithoutContentInput = {
    where: entities_likesWhereUniqueInput
    create: XOR<entities_likesCreateWithoutContentInput, entities_likesUncheckedCreateWithoutContentInput>
  }

  export type entities_likesCreateManyContentInputEnvelope = {
    data: entities_likesCreateManyContentInput | entities_likesCreateManyContentInput[]
    skipDuplicates?: boolean
  }

  export type collections_contentUpsertWithWhereUniqueWithoutContentInput = {
    where: collections_contentWhereUniqueInput
    update: XOR<collections_contentUpdateWithoutContentInput, collections_contentUncheckedUpdateWithoutContentInput>
    create: XOR<collections_contentCreateWithoutContentInput, collections_contentUncheckedCreateWithoutContentInput>
  }

  export type collections_contentUpdateWithWhereUniqueWithoutContentInput = {
    where: collections_contentWhereUniqueInput
    data: XOR<collections_contentUpdateWithoutContentInput, collections_contentUncheckedUpdateWithoutContentInput>
  }

  export type collections_contentUpdateManyWithWhereWithoutContentInput = {
    where: collections_contentScalarWhereInput
    data: XOR<collections_contentUpdateManyMutationInput, collections_contentUncheckedUpdateManyWithoutContentInput>
  }

  export type entities_contentUpsertWithWhereUniqueWithoutContentInput = {
    where: entities_contentWhereUniqueInput
    update: XOR<entities_contentUpdateWithoutContentInput, entities_contentUncheckedUpdateWithoutContentInput>
    create: XOR<entities_contentCreateWithoutContentInput, entities_contentUncheckedCreateWithoutContentInput>
  }

  export type entities_contentUpdateWithWhereUniqueWithoutContentInput = {
    where: entities_contentWhereUniqueInput
    data: XOR<entities_contentUpdateWithoutContentInput, entities_contentUncheckedUpdateWithoutContentInput>
  }

  export type entities_contentUpdateManyWithWhereWithoutContentInput = {
    where: entities_contentScalarWhereInput
    data: XOR<entities_contentUpdateManyMutationInput, entities_contentUncheckedUpdateManyWithoutContentInput>
  }

  export type entities_contentScalarWhereInput = {
    AND?: entities_contentScalarWhereInput | entities_contentScalarWhereInput[]
    OR?: entities_contentScalarWhereInput[]
    NOT?: entities_contentScalarWhereInput | entities_contentScalarWhereInput[]
    entities_content_id?: StringFilter<"entities_content"> | string
    entity_id?: StringFilter<"entities_content"> | string
    content_id?: StringFilter<"entities_content"> | string
    date_added?: DateTimeFilter<"entities_content"> | Date | string
    pinned?: BoolFilter<"entities_content"> | boolean
    date_pinned?: DateTimeNullableFilter<"entities_content"> | Date | string | null
  }

  export type entities_dislikesUpsertWithWhereUniqueWithoutContentInput = {
    where: entities_dislikesWhereUniqueInput
    update: XOR<entities_dislikesUpdateWithoutContentInput, entities_dislikesUncheckedUpdateWithoutContentInput>
    create: XOR<entities_dislikesCreateWithoutContentInput, entities_dislikesUncheckedCreateWithoutContentInput>
  }

  export type entities_dislikesUpdateWithWhereUniqueWithoutContentInput = {
    where: entities_dislikesWhereUniqueInput
    data: XOR<entities_dislikesUpdateWithoutContentInput, entities_dislikesUncheckedUpdateWithoutContentInput>
  }

  export type entities_dislikesUpdateManyWithWhereWithoutContentInput = {
    where: entities_dislikesScalarWhereInput
    data: XOR<entities_dislikesUpdateManyMutationInput, entities_dislikesUncheckedUpdateManyWithoutContentInput>
  }

  export type entities_dislikesScalarWhereInput = {
    AND?: entities_dislikesScalarWhereInput | entities_dislikesScalarWhereInput[]
    OR?: entities_dislikesScalarWhereInput[]
    NOT?: entities_dislikesScalarWhereInput | entities_dislikesScalarWhereInput[]
    dislike_id?: StringFilter<"entities_dislikes"> | string
    entity_id?: StringFilter<"entities_dislikes"> | string
    content_id?: StringFilter<"entities_dislikes"> | string
  }

  export type entities_likesUpsertWithWhereUniqueWithoutContentInput = {
    where: entities_likesWhereUniqueInput
    update: XOR<entities_likesUpdateWithoutContentInput, entities_likesUncheckedUpdateWithoutContentInput>
    create: XOR<entities_likesCreateWithoutContentInput, entities_likesUncheckedCreateWithoutContentInput>
  }

  export type entities_likesUpdateWithWhereUniqueWithoutContentInput = {
    where: entities_likesWhereUniqueInput
    data: XOR<entities_likesUpdateWithoutContentInput, entities_likesUncheckedUpdateWithoutContentInput>
  }

  export type entities_likesUpdateManyWithWhereWithoutContentInput = {
    where: entities_likesScalarWhereInput
    data: XOR<entities_likesUpdateManyMutationInput, entities_likesUncheckedUpdateManyWithoutContentInput>
  }

  export type entities_likesScalarWhereInput = {
    AND?: entities_likesScalarWhereInput | entities_likesScalarWhereInput[]
    OR?: entities_likesScalarWhereInput[]
    NOT?: entities_likesScalarWhereInput | entities_likesScalarWhereInput[]
    like_id?: StringFilter<"entities_likes"> | string
    entity_id?: StringFilter<"entities_likes"> | string
    content_id?: StringFilter<"entities_likes"> | string
  }

  export type conversations_picturesCreateWithoutConversationsInput = {
    conversations_pictures_id: string
    conversation_picture_data: Buffer
    conversation_picture_filename: string
  }

  export type conversations_picturesUncheckedCreateWithoutConversationsInput = {
    conversations_pictures_id: string
    conversation_picture_data: Buffer
    conversation_picture_filename: string
  }

  export type conversations_picturesCreateOrConnectWithoutConversationsInput = {
    where: conversations_picturesWhereUniqueInput
    create: XOR<conversations_picturesCreateWithoutConversationsInput, conversations_picturesUncheckedCreateWithoutConversationsInput>
  }

  export type conversations_membersCreateWithoutConversationsInput = {
    conversations_members_id: string
    entities: entitiesCreateNestedOneWithoutConversations_membersInput
  }

  export type conversations_membersUncheckedCreateWithoutConversationsInput = {
    conversations_members_id: string
    member_id: string
  }

  export type conversations_membersCreateOrConnectWithoutConversationsInput = {
    where: conversations_membersWhereUniqueInput
    create: XOR<conversations_membersCreateWithoutConversationsInput, conversations_membersUncheckedCreateWithoutConversationsInput>
  }

  export type conversations_membersCreateManyConversationsInputEnvelope = {
    data: conversations_membersCreateManyConversationsInput | conversations_membersCreateManyConversationsInput[]
    skipDuplicates?: boolean
  }

  export type conversations_messages_logsCreateWithoutConversationsInput = {
    conversations_messages_logs_id: string
    message: string
    message_date: Date | string
    entities: entitiesCreateNestedOneWithoutConversations_messages_logsInput
  }

  export type conversations_messages_logsUncheckedCreateWithoutConversationsInput = {
    conversations_messages_logs_id: string
    entity_id: string
    message: string
    message_date: Date | string
  }

  export type conversations_messages_logsCreateOrConnectWithoutConversationsInput = {
    where: conversations_messages_logsWhereUniqueInput
    create: XOR<conversations_messages_logsCreateWithoutConversationsInput, conversations_messages_logsUncheckedCreateWithoutConversationsInput>
  }

  export type conversations_messages_logsCreateManyConversationsInputEnvelope = {
    data: conversations_messages_logsCreateManyConversationsInput | conversations_messages_logsCreateManyConversationsInput[]
    skipDuplicates?: boolean
  }

  export type conversations_picturesUpsertWithoutConversationsInput = {
    update: XOR<conversations_picturesUpdateWithoutConversationsInput, conversations_picturesUncheckedUpdateWithoutConversationsInput>
    create: XOR<conversations_picturesCreateWithoutConversationsInput, conversations_picturesUncheckedCreateWithoutConversationsInput>
    where?: conversations_picturesWhereInput
  }

  export type conversations_picturesUpdateToOneWithWhereWithoutConversationsInput = {
    where?: conversations_picturesWhereInput
    data: XOR<conversations_picturesUpdateWithoutConversationsInput, conversations_picturesUncheckedUpdateWithoutConversationsInput>
  }

  export type conversations_picturesUpdateWithoutConversationsInput = {
    conversations_pictures_id?: StringFieldUpdateOperationsInput | string
    conversation_picture_data?: BytesFieldUpdateOperationsInput | Buffer
    conversation_picture_filename?: StringFieldUpdateOperationsInput | string
  }

  export type conversations_picturesUncheckedUpdateWithoutConversationsInput = {
    conversations_pictures_id?: StringFieldUpdateOperationsInput | string
    conversation_picture_data?: BytesFieldUpdateOperationsInput | Buffer
    conversation_picture_filename?: StringFieldUpdateOperationsInput | string
  }

  export type conversations_membersUpsertWithWhereUniqueWithoutConversationsInput = {
    where: conversations_membersWhereUniqueInput
    update: XOR<conversations_membersUpdateWithoutConversationsInput, conversations_membersUncheckedUpdateWithoutConversationsInput>
    create: XOR<conversations_membersCreateWithoutConversationsInput, conversations_membersUncheckedCreateWithoutConversationsInput>
  }

  export type conversations_membersUpdateWithWhereUniqueWithoutConversationsInput = {
    where: conversations_membersWhereUniqueInput
    data: XOR<conversations_membersUpdateWithoutConversationsInput, conversations_membersUncheckedUpdateWithoutConversationsInput>
  }

  export type conversations_membersUpdateManyWithWhereWithoutConversationsInput = {
    where: conversations_membersScalarWhereInput
    data: XOR<conversations_membersUpdateManyMutationInput, conversations_membersUncheckedUpdateManyWithoutConversationsInput>
  }

  export type conversations_membersScalarWhereInput = {
    AND?: conversations_membersScalarWhereInput | conversations_membersScalarWhereInput[]
    OR?: conversations_membersScalarWhereInput[]
    NOT?: conversations_membersScalarWhereInput | conversations_membersScalarWhereInput[]
    conversations_members_id?: StringFilter<"conversations_members"> | string
    conversation_id?: StringFilter<"conversations_members"> | string
    member_id?: StringFilter<"conversations_members"> | string
  }

  export type conversations_messages_logsUpsertWithWhereUniqueWithoutConversationsInput = {
    where: conversations_messages_logsWhereUniqueInput
    update: XOR<conversations_messages_logsUpdateWithoutConversationsInput, conversations_messages_logsUncheckedUpdateWithoutConversationsInput>
    create: XOR<conversations_messages_logsCreateWithoutConversationsInput, conversations_messages_logsUncheckedCreateWithoutConversationsInput>
  }

  export type conversations_messages_logsUpdateWithWhereUniqueWithoutConversationsInput = {
    where: conversations_messages_logsWhereUniqueInput
    data: XOR<conversations_messages_logsUpdateWithoutConversationsInput, conversations_messages_logsUncheckedUpdateWithoutConversationsInput>
  }

  export type conversations_messages_logsUpdateManyWithWhereWithoutConversationsInput = {
    where: conversations_messages_logsScalarWhereInput
    data: XOR<conversations_messages_logsUpdateManyMutationInput, conversations_messages_logsUncheckedUpdateManyWithoutConversationsInput>
  }

  export type conversations_messages_logsScalarWhereInput = {
    AND?: conversations_messages_logsScalarWhereInput | conversations_messages_logsScalarWhereInput[]
    OR?: conversations_messages_logsScalarWhereInput[]
    NOT?: conversations_messages_logsScalarWhereInput | conversations_messages_logsScalarWhereInput[]
    conversations_messages_logs_id?: StringFilter<"conversations_messages_logs"> | string
    conversation_id?: StringFilter<"conversations_messages_logs"> | string
    entity_id?: StringFilter<"conversations_messages_logs"> | string
    message?: StringFilter<"conversations_messages_logs"> | string
    message_date?: DateTimeFilter<"conversations_messages_logs"> | Date | string
  }

  export type conversationsCreateWithoutConversations_membersInput = {
    conversation_id: string
    conversation_name?: string | null
    conversation_creation_date: Date | string
    last_message?: string | null
    last_message_date?: Date | string | null
    conversations_pictures?: conversations_picturesCreateNestedOneWithoutConversationsInput
    conversations_messages_logs?: conversations_messages_logsCreateNestedManyWithoutConversationsInput
  }

  export type conversationsUncheckedCreateWithoutConversations_membersInput = {
    conversation_id: string
    conversation_name?: string | null
    conversation_creation_date: Date | string
    last_message?: string | null
    last_message_date?: Date | string | null
    conversations_pictures_id?: string | null
    conversations_messages_logs?: conversations_messages_logsUncheckedCreateNestedManyWithoutConversationsInput
  }

  export type conversationsCreateOrConnectWithoutConversations_membersInput = {
    where: conversationsWhereUniqueInput
    create: XOR<conversationsCreateWithoutConversations_membersInput, conversationsUncheckedCreateWithoutConversations_membersInput>
  }

  export type entitiesCreateWithoutConversations_membersInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_messages_logs?: conversations_messages_logsCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersCreateNestedManyWithoutEntitiesInput
    images?: imagesCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsCreateNestedManyWithoutEntitiesInput
    videos?: videosCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesUncheckedCreateWithoutConversations_membersInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsUncheckedCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_messages_logs?: conversations_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentUncheckedCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesUncheckedCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersUncheckedCreateNestedManyWithoutEntitiesInput
    images?: imagesUncheckedCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersUncheckedCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsUncheckedCreateNestedManyWithoutEntitiesInput
    videos?: videosUncheckedCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesCreateOrConnectWithoutConversations_membersInput = {
    where: entitiesWhereUniqueInput
    create: XOR<entitiesCreateWithoutConversations_membersInput, entitiesUncheckedCreateWithoutConversations_membersInput>
  }

  export type conversationsUpsertWithoutConversations_membersInput = {
    update: XOR<conversationsUpdateWithoutConversations_membersInput, conversationsUncheckedUpdateWithoutConversations_membersInput>
    create: XOR<conversationsCreateWithoutConversations_membersInput, conversationsUncheckedCreateWithoutConversations_membersInput>
    where?: conversationsWhereInput
  }

  export type conversationsUpdateToOneWithWhereWithoutConversations_membersInput = {
    where?: conversationsWhereInput
    data: XOR<conversationsUpdateWithoutConversations_membersInput, conversationsUncheckedUpdateWithoutConversations_membersInput>
  }

  export type conversationsUpdateWithoutConversations_membersInput = {
    conversation_id?: StringFieldUpdateOperationsInput | string
    conversation_name?: NullableStringFieldUpdateOperationsInput | string | null
    conversation_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations_pictures?: conversations_picturesUpdateOneWithoutConversationsNestedInput
    conversations_messages_logs?: conversations_messages_logsUpdateManyWithoutConversationsNestedInput
  }

  export type conversationsUncheckedUpdateWithoutConversations_membersInput = {
    conversation_id?: StringFieldUpdateOperationsInput | string
    conversation_name?: NullableStringFieldUpdateOperationsInput | string | null
    conversation_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations_pictures_id?: NullableStringFieldUpdateOperationsInput | string | null
    conversations_messages_logs?: conversations_messages_logsUncheckedUpdateManyWithoutConversationsNestedInput
  }

  export type entitiesUpsertWithoutConversations_membersInput = {
    update: XOR<entitiesUpdateWithoutConversations_membersInput, entitiesUncheckedUpdateWithoutConversations_membersInput>
    create: XOR<entitiesCreateWithoutConversations_membersInput, entitiesUncheckedCreateWithoutConversations_membersInput>
    where?: entitiesWhereInput
  }

  export type entitiesUpdateToOneWithWhereWithoutConversations_membersInput = {
    where?: entitiesWhereInput
    data: XOR<entitiesUpdateWithoutConversations_membersInput, entitiesUncheckedUpdateWithoutConversations_membersInput>
  }

  export type entitiesUpdateWithoutConversations_membersInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUpdateManyWithoutEntitiesNestedInput
    images?: imagesUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUpdateManyWithoutEntitiesNestedInput
    videos?: videosUpdateManyWithoutEntitiesNestedInput
  }

  export type entitiesUncheckedUpdateWithoutConversations_membersInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUncheckedUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUncheckedUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    images?: imagesUncheckedUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUncheckedUpdateManyWithoutEntitiesNestedInput
    videos?: videosUncheckedUpdateManyWithoutEntitiesNestedInput
  }

  export type conversationsCreateWithoutConversations_messages_logsInput = {
    conversation_id: string
    conversation_name?: string | null
    conversation_creation_date: Date | string
    last_message?: string | null
    last_message_date?: Date | string | null
    conversations_pictures?: conversations_picturesCreateNestedOneWithoutConversationsInput
    conversations_members?: conversations_membersCreateNestedManyWithoutConversationsInput
  }

  export type conversationsUncheckedCreateWithoutConversations_messages_logsInput = {
    conversation_id: string
    conversation_name?: string | null
    conversation_creation_date: Date | string
    last_message?: string | null
    last_message_date?: Date | string | null
    conversations_pictures_id?: string | null
    conversations_members?: conversations_membersUncheckedCreateNestedManyWithoutConversationsInput
  }

  export type conversationsCreateOrConnectWithoutConversations_messages_logsInput = {
    where: conversationsWhereUniqueInput
    create: XOR<conversationsCreateWithoutConversations_messages_logsInput, conversationsUncheckedCreateWithoutConversations_messages_logsInput>
  }

  export type entitiesCreateWithoutConversations_messages_logsInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersCreateNestedManyWithoutEntitiesInput
    images?: imagesCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsCreateNestedManyWithoutEntitiesInput
    videos?: videosCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesUncheckedCreateWithoutConversations_messages_logsInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsUncheckedCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentUncheckedCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesUncheckedCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersUncheckedCreateNestedManyWithoutEntitiesInput
    images?: imagesUncheckedCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersUncheckedCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsUncheckedCreateNestedManyWithoutEntitiesInput
    videos?: videosUncheckedCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesCreateOrConnectWithoutConversations_messages_logsInput = {
    where: entitiesWhereUniqueInput
    create: XOR<entitiesCreateWithoutConversations_messages_logsInput, entitiesUncheckedCreateWithoutConversations_messages_logsInput>
  }

  export type conversationsUpsertWithoutConversations_messages_logsInput = {
    update: XOR<conversationsUpdateWithoutConversations_messages_logsInput, conversationsUncheckedUpdateWithoutConversations_messages_logsInput>
    create: XOR<conversationsCreateWithoutConversations_messages_logsInput, conversationsUncheckedCreateWithoutConversations_messages_logsInput>
    where?: conversationsWhereInput
  }

  export type conversationsUpdateToOneWithWhereWithoutConversations_messages_logsInput = {
    where?: conversationsWhereInput
    data: XOR<conversationsUpdateWithoutConversations_messages_logsInput, conversationsUncheckedUpdateWithoutConversations_messages_logsInput>
  }

  export type conversationsUpdateWithoutConversations_messages_logsInput = {
    conversation_id?: StringFieldUpdateOperationsInput | string
    conversation_name?: NullableStringFieldUpdateOperationsInput | string | null
    conversation_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations_pictures?: conversations_picturesUpdateOneWithoutConversationsNestedInput
    conversations_members?: conversations_membersUpdateManyWithoutConversationsNestedInput
  }

  export type conversationsUncheckedUpdateWithoutConversations_messages_logsInput = {
    conversation_id?: StringFieldUpdateOperationsInput | string
    conversation_name?: NullableStringFieldUpdateOperationsInput | string | null
    conversation_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations_pictures_id?: NullableStringFieldUpdateOperationsInput | string | null
    conversations_members?: conversations_membersUncheckedUpdateManyWithoutConversationsNestedInput
  }

  export type entitiesUpsertWithoutConversations_messages_logsInput = {
    update: XOR<entitiesUpdateWithoutConversations_messages_logsInput, entitiesUncheckedUpdateWithoutConversations_messages_logsInput>
    create: XOR<entitiesCreateWithoutConversations_messages_logsInput, entitiesUncheckedCreateWithoutConversations_messages_logsInput>
    where?: entitiesWhereInput
  }

  export type entitiesUpdateToOneWithWhereWithoutConversations_messages_logsInput = {
    where?: entitiesWhereInput
    data: XOR<entitiesUpdateWithoutConversations_messages_logsInput, entitiesUncheckedUpdateWithoutConversations_messages_logsInput>
  }

  export type entitiesUpdateWithoutConversations_messages_logsInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUpdateManyWithoutEntitiesNestedInput
    images?: imagesUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUpdateManyWithoutEntitiesNestedInput
    videos?: videosUpdateManyWithoutEntitiesNestedInput
  }

  export type entitiesUncheckedUpdateWithoutConversations_messages_logsInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUncheckedUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUncheckedUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    images?: imagesUncheckedUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUncheckedUpdateManyWithoutEntitiesNestedInput
    videos?: videosUncheckedUpdateManyWithoutEntitiesNestedInput
  }

  export type conversationsCreateWithoutConversations_picturesInput = {
    conversation_id: string
    conversation_name?: string | null
    conversation_creation_date: Date | string
    last_message?: string | null
    last_message_date?: Date | string | null
    conversations_members?: conversations_membersCreateNestedManyWithoutConversationsInput
    conversations_messages_logs?: conversations_messages_logsCreateNestedManyWithoutConversationsInput
  }

  export type conversationsUncheckedCreateWithoutConversations_picturesInput = {
    conversation_id: string
    conversation_name?: string | null
    conversation_creation_date: Date | string
    last_message?: string | null
    last_message_date?: Date | string | null
    conversations_members?: conversations_membersUncheckedCreateNestedManyWithoutConversationsInput
    conversations_messages_logs?: conversations_messages_logsUncheckedCreateNestedManyWithoutConversationsInput
  }

  export type conversationsCreateOrConnectWithoutConversations_picturesInput = {
    where: conversationsWhereUniqueInput
    create: XOR<conversationsCreateWithoutConversations_picturesInput, conversationsUncheckedCreateWithoutConversations_picturesInput>
  }

  export type conversationsCreateManyConversations_picturesInputEnvelope = {
    data: conversationsCreateManyConversations_picturesInput | conversationsCreateManyConversations_picturesInput[]
    skipDuplicates?: boolean
  }

  export type conversationsUpsertWithWhereUniqueWithoutConversations_picturesInput = {
    where: conversationsWhereUniqueInput
    update: XOR<conversationsUpdateWithoutConversations_picturesInput, conversationsUncheckedUpdateWithoutConversations_picturesInput>
    create: XOR<conversationsCreateWithoutConversations_picturesInput, conversationsUncheckedCreateWithoutConversations_picturesInput>
  }

  export type conversationsUpdateWithWhereUniqueWithoutConversations_picturesInput = {
    where: conversationsWhereUniqueInput
    data: XOR<conversationsUpdateWithoutConversations_picturesInput, conversationsUncheckedUpdateWithoutConversations_picturesInput>
  }

  export type conversationsUpdateManyWithWhereWithoutConversations_picturesInput = {
    where: conversationsScalarWhereInput
    data: XOR<conversationsUpdateManyMutationInput, conversationsUncheckedUpdateManyWithoutConversations_picturesInput>
  }

  export type conversationsScalarWhereInput = {
    AND?: conversationsScalarWhereInput | conversationsScalarWhereInput[]
    OR?: conversationsScalarWhereInput[]
    NOT?: conversationsScalarWhereInput | conversationsScalarWhereInput[]
    conversation_id?: StringFilter<"conversations"> | string
    conversation_name?: StringNullableFilter<"conversations"> | string | null
    conversation_creation_date?: DateTimeFilter<"conversations"> | Date | string
    last_message?: StringNullableFilter<"conversations"> | string | null
    last_message_date?: DateTimeNullableFilter<"conversations"> | Date | string | null
    conversations_pictures_id?: StringNullableFilter<"conversations"> | string | null
  }

  export type collectionsCreateWithoutEntitiesInput = {
    collection_id: string
    collection_name: string
    collections_content?: collections_contentCreateNestedManyWithoutCollectionsInput
  }

  export type collectionsUncheckedCreateWithoutEntitiesInput = {
    collection_id: string
    collection_name: string
    collections_content?: collections_contentUncheckedCreateNestedManyWithoutCollectionsInput
  }

  export type collectionsCreateOrConnectWithoutEntitiesInput = {
    where: collectionsWhereUniqueInput
    create: XOR<collectionsCreateWithoutEntitiesInput, collectionsUncheckedCreateWithoutEntitiesInput>
  }

  export type collectionsCreateManyEntitiesInputEnvelope = {
    data: collectionsCreateManyEntitiesInput | collectionsCreateManyEntitiesInput[]
    skipDuplicates?: boolean
  }

  export type contactsCreateWithoutEntities_contacts_contact_id_rootToentitiesInput = {
    contact_id: string
    conversation_id: string
    contact_creation_date: Date | string
    last_message?: string | null
    last_contact_date?: Date | string | null
    entities_contacts_contact_id_targetToentities: entitiesCreateNestedOneWithoutContacts_contacts_contact_id_targetToentitiesInput
    contacts_pictures?: contacts_picturesCreateNestedOneWithoutContactsInput
  }

  export type contactsUncheckedCreateWithoutEntities_contacts_contact_id_rootToentitiesInput = {
    contact_id: string
    conversation_id: string
    contact_id_target: string
    contact_creation_date: Date | string
    last_message?: string | null
    last_contact_date?: Date | string | null
    contacts_pictures_id?: string | null
  }

  export type contactsCreateOrConnectWithoutEntities_contacts_contact_id_rootToentitiesInput = {
    where: contactsWhereUniqueInput
    create: XOR<contactsCreateWithoutEntities_contacts_contact_id_rootToentitiesInput, contactsUncheckedCreateWithoutEntities_contacts_contact_id_rootToentitiesInput>
  }

  export type contactsCreateManyEntities_contacts_contact_id_rootToentitiesInputEnvelope = {
    data: contactsCreateManyEntities_contacts_contact_id_rootToentitiesInput | contactsCreateManyEntities_contacts_contact_id_rootToentitiesInput[]
    skipDuplicates?: boolean
  }

  export type contactsCreateWithoutEntities_contacts_contact_id_targetToentitiesInput = {
    contact_id: string
    conversation_id: string
    contact_creation_date: Date | string
    last_message?: string | null
    last_contact_date?: Date | string | null
    entities_contacts_contact_id_rootToentities: entitiesCreateNestedOneWithoutContacts_contacts_contact_id_rootToentitiesInput
    contacts_pictures?: contacts_picturesCreateNestedOneWithoutContactsInput
  }

  export type contactsUncheckedCreateWithoutEntities_contacts_contact_id_targetToentitiesInput = {
    contact_id: string
    conversation_id: string
    contact_id_root: string
    contact_creation_date: Date | string
    last_message?: string | null
    last_contact_date?: Date | string | null
    contacts_pictures_id?: string | null
  }

  export type contactsCreateOrConnectWithoutEntities_contacts_contact_id_targetToentitiesInput = {
    where: contactsWhereUniqueInput
    create: XOR<contactsCreateWithoutEntities_contacts_contact_id_targetToentitiesInput, contactsUncheckedCreateWithoutEntities_contacts_contact_id_targetToentitiesInput>
  }

  export type contactsCreateManyEntities_contacts_contact_id_targetToentitiesInputEnvelope = {
    data: contactsCreateManyEntities_contacts_contact_id_targetToentitiesInput | contactsCreateManyEntities_contacts_contact_id_targetToentitiesInput[]
    skipDuplicates?: boolean
  }

  export type conversations_membersCreateWithoutEntitiesInput = {
    conversations_members_id: string
    conversations: conversationsCreateNestedOneWithoutConversations_membersInput
  }

  export type conversations_membersUncheckedCreateWithoutEntitiesInput = {
    conversations_members_id: string
    conversation_id: string
  }

  export type conversations_membersCreateOrConnectWithoutEntitiesInput = {
    where: conversations_membersWhereUniqueInput
    create: XOR<conversations_membersCreateWithoutEntitiesInput, conversations_membersUncheckedCreateWithoutEntitiesInput>
  }

  export type conversations_membersCreateManyEntitiesInputEnvelope = {
    data: conversations_membersCreateManyEntitiesInput | conversations_membersCreateManyEntitiesInput[]
    skipDuplicates?: boolean
  }

  export type conversations_messages_logsCreateWithoutEntitiesInput = {
    conversations_messages_logs_id: string
    message: string
    message_date: Date | string
    conversations: conversationsCreateNestedOneWithoutConversations_messages_logsInput
  }

  export type conversations_messages_logsUncheckedCreateWithoutEntitiesInput = {
    conversations_messages_logs_id: string
    conversation_id: string
    message: string
    message_date: Date | string
  }

  export type conversations_messages_logsCreateOrConnectWithoutEntitiesInput = {
    where: conversations_messages_logsWhereUniqueInput
    create: XOR<conversations_messages_logsCreateWithoutEntitiesInput, conversations_messages_logsUncheckedCreateWithoutEntitiesInput>
  }

  export type conversations_messages_logsCreateManyEntitiesInputEnvelope = {
    data: conversations_messages_logsCreateManyEntitiesInput | conversations_messages_logsCreateManyEntitiesInput[]
    skipDuplicates?: boolean
  }

  export type entities_contentCreateWithoutEntitiesInput = {
    entities_content_id: string
    date_added: Date | string
    pinned: boolean
    date_pinned?: Date | string | null
    content: contentCreateNestedOneWithoutEntities_contentInput
  }

  export type entities_contentUncheckedCreateWithoutEntitiesInput = {
    entities_content_id: string
    content_id: string
    date_added: Date | string
    pinned: boolean
    date_pinned?: Date | string | null
  }

  export type entities_contentCreateOrConnectWithoutEntitiesInput = {
    where: entities_contentWhereUniqueInput
    create: XOR<entities_contentCreateWithoutEntitiesInput, entities_contentUncheckedCreateWithoutEntitiesInput>
  }

  export type entities_contentCreateManyEntitiesInputEnvelope = {
    data: entities_contentCreateManyEntitiesInput | entities_contentCreateManyEntitiesInput[]
    skipDuplicates?: boolean
  }

  export type entities_dislikesCreateWithoutEntitiesInput = {
    dislike_id: string
    content: contentCreateNestedOneWithoutEntities_dislikesInput
  }

  export type entities_dislikesUncheckedCreateWithoutEntitiesInput = {
    dislike_id: string
    content_id: string
  }

  export type entities_dislikesCreateOrConnectWithoutEntitiesInput = {
    where: entities_dislikesWhereUniqueInput
    create: XOR<entities_dislikesCreateWithoutEntitiesInput, entities_dislikesUncheckedCreateWithoutEntitiesInput>
  }

  export type entities_dislikesCreateManyEntitiesInputEnvelope = {
    data: entities_dislikesCreateManyEntitiesInput | entities_dislikesCreateManyEntitiesInput[]
    skipDuplicates?: boolean
  }

  export type entities_likesCreateWithoutEntitiesInput = {
    like_id: string
    content: contentCreateNestedOneWithoutEntities_likesInput
  }

  export type entities_likesUncheckedCreateWithoutEntitiesInput = {
    like_id: string
    content_id: string
  }

  export type entities_likesCreateOrConnectWithoutEntitiesInput = {
    where: entities_likesWhereUniqueInput
    create: XOR<entities_likesCreateWithoutEntitiesInput, entities_likesUncheckedCreateWithoutEntitiesInput>
  }

  export type entities_likesCreateManyEntitiesInputEnvelope = {
    data: entities_likesCreateManyEntitiesInput | entities_likesCreateManyEntitiesInput[]
    skipDuplicates?: boolean
  }

  export type entities_referencesCreateWithoutEntitiesInput = {
    reference_id: string
    title: string
    author: string
    url: string
  }

  export type entities_referencesUncheckedCreateWithoutEntitiesInput = {
    reference_id: string
    title: string
    author: string
    url: string
  }

  export type entities_referencesCreateOrConnectWithoutEntitiesInput = {
    where: entities_referencesWhereUniqueInput
    create: XOR<entities_referencesCreateWithoutEntitiesInput, entities_referencesUncheckedCreateWithoutEntitiesInput>
  }

  export type entities_referencesCreateManyEntitiesInputEnvelope = {
    data: entities_referencesCreateManyEntitiesInput | entities_referencesCreateManyEntitiesInput[]
    skipDuplicates?: boolean
  }

  export type groups_membersCreateWithoutEntitiesInput = {
    groups_members_id: string
    groups: groupsCreateNestedOneWithoutGroups_membersInput
  }

  export type groups_membersUncheckedCreateWithoutEntitiesInput = {
    groups_members_id: string
    group_id: string
  }

  export type groups_membersCreateOrConnectWithoutEntitiesInput = {
    where: groups_membersWhereUniqueInput
    create: XOR<groups_membersCreateWithoutEntitiesInput, groups_membersUncheckedCreateWithoutEntitiesInput>
  }

  export type groups_membersCreateManyEntitiesInputEnvelope = {
    data: groups_membersCreateManyEntitiesInput | groups_membersCreateManyEntitiesInput[]
    skipDuplicates?: boolean
  }

  export type imagesCreateWithoutEntitiesInput = {
    image_id: string
    image_title: string
    image_description: string
    image_filename: string
    image_likes?: number
    image_dislikes?: number
    image_views?: number
    image_date_posted?: Date | string
    images_data: images_dataCreateNestedOneWithoutImagesInput
  }

  export type imagesUncheckedCreateWithoutEntitiesInput = {
    image_id: string
    image_title: string
    image_description: string
    image_filename: string
    image_data_id: string
    image_likes?: number
    image_dislikes?: number
    image_views?: number
    image_date_posted?: Date | string
  }

  export type imagesCreateOrConnectWithoutEntitiesInput = {
    where: imagesWhereUniqueInput
    create: XOR<imagesCreateWithoutEntitiesInput, imagesUncheckedCreateWithoutEntitiesInput>
  }

  export type imagesCreateManyEntitiesInputEnvelope = {
    data: imagesCreateManyEntitiesInput | imagesCreateManyEntitiesInput[]
    skipDuplicates?: boolean
  }

  export type organizations_membersCreateWithoutEntitiesInput = {
    organizations_members_id: string
    organizations: organizationsCreateNestedOneWithoutOrganizations_membersInput
  }

  export type organizations_membersUncheckedCreateWithoutEntitiesInput = {
    organizations_members_id: string
    organization_id: string
  }

  export type organizations_membersCreateOrConnectWithoutEntitiesInput = {
    where: organizations_membersWhereUniqueInput
    create: XOR<organizations_membersCreateWithoutEntitiesInput, organizations_membersUncheckedCreateWithoutEntitiesInput>
  }

  export type organizations_membersCreateManyEntitiesInputEnvelope = {
    data: organizations_membersCreateManyEntitiesInput | organizations_membersCreateManyEntitiesInput[]
    skipDuplicates?: boolean
  }

  export type sheetsCreateWithoutEntitiesInput = {
    sheet_id: string
    sheet_title: string
    sheet_subject: string
    sheet_filename: string
    sheet_likes?: number
    sheet_dislikes?: number
    sheet_views?: number
    sheet_date_posted?: Date | string
    sheets_data: sheets_dataCreateNestedOneWithoutSheetsInput
    sheets_thumbnails?: sheets_thumbnailsCreateNestedOneWithoutSheetsInput
  }

  export type sheetsUncheckedCreateWithoutEntitiesInput = {
    sheet_id: string
    sheet_title: string
    sheet_subject: string
    sheet_filename: string
    sheet_data_id: string
    sheet_thumbnail_id?: string | null
    sheet_likes?: number
    sheet_dislikes?: number
    sheet_views?: number
    sheet_date_posted?: Date | string
  }

  export type sheetsCreateOrConnectWithoutEntitiesInput = {
    where: sheetsWhereUniqueInput
    create: XOR<sheetsCreateWithoutEntitiesInput, sheetsUncheckedCreateWithoutEntitiesInput>
  }

  export type sheetsCreateManyEntitiesInputEnvelope = {
    data: sheetsCreateManyEntitiesInput | sheetsCreateManyEntitiesInput[]
    skipDuplicates?: boolean
  }

  export type tables_membersCreateWithoutEntitiesInput = {
    tables_members_id: string
    table_position: number
    live?: number
    tables: tablesCreateNestedOneWithoutTables_membersInput
  }

  export type tables_membersUncheckedCreateWithoutEntitiesInput = {
    tables_members_id: string
    table_id: string
    table_position: number
    live?: number
  }

  export type tables_membersCreateOrConnectWithoutEntitiesInput = {
    where: tables_membersWhereUniqueInput
    create: XOR<tables_membersCreateWithoutEntitiesInput, tables_membersUncheckedCreateWithoutEntitiesInput>
  }

  export type tables_membersCreateManyEntitiesInputEnvelope = {
    data: tables_membersCreateManyEntitiesInput | tables_membersCreateManyEntitiesInput[]
    skipDuplicates?: boolean
  }

  export type tables_messages_logsCreateWithoutEntitiesInput = {
    tables_messages_logs_id: string
    message: string
    message_date: Date | string
    tables: tablesCreateNestedOneWithoutTables_messages_logsInput
  }

  export type tables_messages_logsUncheckedCreateWithoutEntitiesInput = {
    tables_messages_logs_id: string
    table_id: string
    message: string
    message_date: Date | string
  }

  export type tables_messages_logsCreateOrConnectWithoutEntitiesInput = {
    where: tables_messages_logsWhereUniqueInput
    create: XOR<tables_messages_logsCreateWithoutEntitiesInput, tables_messages_logsUncheckedCreateWithoutEntitiesInput>
  }

  export type tables_messages_logsCreateManyEntitiesInputEnvelope = {
    data: tables_messages_logsCreateManyEntitiesInput | tables_messages_logsCreateManyEntitiesInput[]
    skipDuplicates?: boolean
  }

  export type tables_tabletopsCreateWithoutEntitiesInput = {
    tables_tabletops_id: string
    type: number
    content_date_posted: Date | string
    content_x_position: number
    content_y_position: number
    content_rotation: number
    content_filename?: string | null
    tables: tablesCreateNestedOneWithoutTables_tabletopsInput
    tables_tabletops_data?: tables_tabletops_dataCreateNestedOneWithoutTables_tabletopsInput
  }

  export type tables_tabletopsUncheckedCreateWithoutEntitiesInput = {
    tables_tabletops_id: string
    table_id: string
    tables_tabletops_data_id?: string | null
    type: number
    content_date_posted: Date | string
    content_x_position: number
    content_y_position: number
    content_rotation: number
    content_filename?: string | null
  }

  export type tables_tabletopsCreateOrConnectWithoutEntitiesInput = {
    where: tables_tabletopsWhereUniqueInput
    create: XOR<tables_tabletopsCreateWithoutEntitiesInput, tables_tabletopsUncheckedCreateWithoutEntitiesInput>
  }

  export type tables_tabletopsCreateManyEntitiesInputEnvelope = {
    data: tables_tabletopsCreateManyEntitiesInput | tables_tabletopsCreateManyEntitiesInput[]
    skipDuplicates?: boolean
  }

  export type videosCreateWithoutEntitiesInput = {
    video_id: string
    video_title: string
    video_description: string
    video_filename: string
    video_likes?: number
    video_dislikes?: number
    video_views?: number
    video_date_posted?: Date | string | null
    videos_data: videos_dataCreateNestedOneWithoutVideosInput
    videos_thumbnails?: videos_thumbnailsCreateNestedOneWithoutVideosInput
  }

  export type videosUncheckedCreateWithoutEntitiesInput = {
    video_id: string
    video_title: string
    video_description: string
    video_filename: string
    video_data_id: string
    video_thumbnail_id?: string | null
    video_likes?: number
    video_dislikes?: number
    video_views?: number
    video_date_posted?: Date | string | null
  }

  export type videosCreateOrConnectWithoutEntitiesInput = {
    where: videosWhereUniqueInput
    create: XOR<videosCreateWithoutEntitiesInput, videosUncheckedCreateWithoutEntitiesInput>
  }

  export type videosCreateManyEntitiesInputEnvelope = {
    data: videosCreateManyEntitiesInput | videosCreateManyEntitiesInput[]
    skipDuplicates?: boolean
  }

  export type collectionsUpsertWithWhereUniqueWithoutEntitiesInput = {
    where: collectionsWhereUniqueInput
    update: XOR<collectionsUpdateWithoutEntitiesInput, collectionsUncheckedUpdateWithoutEntitiesInput>
    create: XOR<collectionsCreateWithoutEntitiesInput, collectionsUncheckedCreateWithoutEntitiesInput>
  }

  export type collectionsUpdateWithWhereUniqueWithoutEntitiesInput = {
    where: collectionsWhereUniqueInput
    data: XOR<collectionsUpdateWithoutEntitiesInput, collectionsUncheckedUpdateWithoutEntitiesInput>
  }

  export type collectionsUpdateManyWithWhereWithoutEntitiesInput = {
    where: collectionsScalarWhereInput
    data: XOR<collectionsUpdateManyMutationInput, collectionsUncheckedUpdateManyWithoutEntitiesInput>
  }

  export type collectionsScalarWhereInput = {
    AND?: collectionsScalarWhereInput | collectionsScalarWhereInput[]
    OR?: collectionsScalarWhereInput[]
    NOT?: collectionsScalarWhereInput | collectionsScalarWhereInput[]
    collection_id?: StringFilter<"collections"> | string
    collection_name?: StringFilter<"collections"> | string
    entity_id?: StringFilter<"collections"> | string
  }

  export type contactsUpsertWithWhereUniqueWithoutEntities_contacts_contact_id_rootToentitiesInput = {
    where: contactsWhereUniqueInput
    update: XOR<contactsUpdateWithoutEntities_contacts_contact_id_rootToentitiesInput, contactsUncheckedUpdateWithoutEntities_contacts_contact_id_rootToentitiesInput>
    create: XOR<contactsCreateWithoutEntities_contacts_contact_id_rootToentitiesInput, contactsUncheckedCreateWithoutEntities_contacts_contact_id_rootToentitiesInput>
  }

  export type contactsUpdateWithWhereUniqueWithoutEntities_contacts_contact_id_rootToentitiesInput = {
    where: contactsWhereUniqueInput
    data: XOR<contactsUpdateWithoutEntities_contacts_contact_id_rootToentitiesInput, contactsUncheckedUpdateWithoutEntities_contacts_contact_id_rootToentitiesInput>
  }

  export type contactsUpdateManyWithWhereWithoutEntities_contacts_contact_id_rootToentitiesInput = {
    where: contactsScalarWhereInput
    data: XOR<contactsUpdateManyMutationInput, contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesInput>
  }

  export type contactsUpsertWithWhereUniqueWithoutEntities_contacts_contact_id_targetToentitiesInput = {
    where: contactsWhereUniqueInput
    update: XOR<contactsUpdateWithoutEntities_contacts_contact_id_targetToentitiesInput, contactsUncheckedUpdateWithoutEntities_contacts_contact_id_targetToentitiesInput>
    create: XOR<contactsCreateWithoutEntities_contacts_contact_id_targetToentitiesInput, contactsUncheckedCreateWithoutEntities_contacts_contact_id_targetToentitiesInput>
  }

  export type contactsUpdateWithWhereUniqueWithoutEntities_contacts_contact_id_targetToentitiesInput = {
    where: contactsWhereUniqueInput
    data: XOR<contactsUpdateWithoutEntities_contacts_contact_id_targetToentitiesInput, contactsUncheckedUpdateWithoutEntities_contacts_contact_id_targetToentitiesInput>
  }

  export type contactsUpdateManyWithWhereWithoutEntities_contacts_contact_id_targetToentitiesInput = {
    where: contactsScalarWhereInput
    data: XOR<contactsUpdateManyMutationInput, contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesInput>
  }

  export type conversations_membersUpsertWithWhereUniqueWithoutEntitiesInput = {
    where: conversations_membersWhereUniqueInput
    update: XOR<conversations_membersUpdateWithoutEntitiesInput, conversations_membersUncheckedUpdateWithoutEntitiesInput>
    create: XOR<conversations_membersCreateWithoutEntitiesInput, conversations_membersUncheckedCreateWithoutEntitiesInput>
  }

  export type conversations_membersUpdateWithWhereUniqueWithoutEntitiesInput = {
    where: conversations_membersWhereUniqueInput
    data: XOR<conversations_membersUpdateWithoutEntitiesInput, conversations_membersUncheckedUpdateWithoutEntitiesInput>
  }

  export type conversations_membersUpdateManyWithWhereWithoutEntitiesInput = {
    where: conversations_membersScalarWhereInput
    data: XOR<conversations_membersUpdateManyMutationInput, conversations_membersUncheckedUpdateManyWithoutEntitiesInput>
  }

  export type conversations_messages_logsUpsertWithWhereUniqueWithoutEntitiesInput = {
    where: conversations_messages_logsWhereUniqueInput
    update: XOR<conversations_messages_logsUpdateWithoutEntitiesInput, conversations_messages_logsUncheckedUpdateWithoutEntitiesInput>
    create: XOR<conversations_messages_logsCreateWithoutEntitiesInput, conversations_messages_logsUncheckedCreateWithoutEntitiesInput>
  }

  export type conversations_messages_logsUpdateWithWhereUniqueWithoutEntitiesInput = {
    where: conversations_messages_logsWhereUniqueInput
    data: XOR<conversations_messages_logsUpdateWithoutEntitiesInput, conversations_messages_logsUncheckedUpdateWithoutEntitiesInput>
  }

  export type conversations_messages_logsUpdateManyWithWhereWithoutEntitiesInput = {
    where: conversations_messages_logsScalarWhereInput
    data: XOR<conversations_messages_logsUpdateManyMutationInput, conversations_messages_logsUncheckedUpdateManyWithoutEntitiesInput>
  }

  export type entities_contentUpsertWithWhereUniqueWithoutEntitiesInput = {
    where: entities_contentWhereUniqueInput
    update: XOR<entities_contentUpdateWithoutEntitiesInput, entities_contentUncheckedUpdateWithoutEntitiesInput>
    create: XOR<entities_contentCreateWithoutEntitiesInput, entities_contentUncheckedCreateWithoutEntitiesInput>
  }

  export type entities_contentUpdateWithWhereUniqueWithoutEntitiesInput = {
    where: entities_contentWhereUniqueInput
    data: XOR<entities_contentUpdateWithoutEntitiesInput, entities_contentUncheckedUpdateWithoutEntitiesInput>
  }

  export type entities_contentUpdateManyWithWhereWithoutEntitiesInput = {
    where: entities_contentScalarWhereInput
    data: XOR<entities_contentUpdateManyMutationInput, entities_contentUncheckedUpdateManyWithoutEntitiesInput>
  }

  export type entities_dislikesUpsertWithWhereUniqueWithoutEntitiesInput = {
    where: entities_dislikesWhereUniqueInput
    update: XOR<entities_dislikesUpdateWithoutEntitiesInput, entities_dislikesUncheckedUpdateWithoutEntitiesInput>
    create: XOR<entities_dislikesCreateWithoutEntitiesInput, entities_dislikesUncheckedCreateWithoutEntitiesInput>
  }

  export type entities_dislikesUpdateWithWhereUniqueWithoutEntitiesInput = {
    where: entities_dislikesWhereUniqueInput
    data: XOR<entities_dislikesUpdateWithoutEntitiesInput, entities_dislikesUncheckedUpdateWithoutEntitiesInput>
  }

  export type entities_dislikesUpdateManyWithWhereWithoutEntitiesInput = {
    where: entities_dislikesScalarWhereInput
    data: XOR<entities_dislikesUpdateManyMutationInput, entities_dislikesUncheckedUpdateManyWithoutEntitiesInput>
  }

  export type entities_likesUpsertWithWhereUniqueWithoutEntitiesInput = {
    where: entities_likesWhereUniqueInput
    update: XOR<entities_likesUpdateWithoutEntitiesInput, entities_likesUncheckedUpdateWithoutEntitiesInput>
    create: XOR<entities_likesCreateWithoutEntitiesInput, entities_likesUncheckedCreateWithoutEntitiesInput>
  }

  export type entities_likesUpdateWithWhereUniqueWithoutEntitiesInput = {
    where: entities_likesWhereUniqueInput
    data: XOR<entities_likesUpdateWithoutEntitiesInput, entities_likesUncheckedUpdateWithoutEntitiesInput>
  }

  export type entities_likesUpdateManyWithWhereWithoutEntitiesInput = {
    where: entities_likesScalarWhereInput
    data: XOR<entities_likesUpdateManyMutationInput, entities_likesUncheckedUpdateManyWithoutEntitiesInput>
  }

  export type entities_referencesUpsertWithWhereUniqueWithoutEntitiesInput = {
    where: entities_referencesWhereUniqueInput
    update: XOR<entities_referencesUpdateWithoutEntitiesInput, entities_referencesUncheckedUpdateWithoutEntitiesInput>
    create: XOR<entities_referencesCreateWithoutEntitiesInput, entities_referencesUncheckedCreateWithoutEntitiesInput>
  }

  export type entities_referencesUpdateWithWhereUniqueWithoutEntitiesInput = {
    where: entities_referencesWhereUniqueInput
    data: XOR<entities_referencesUpdateWithoutEntitiesInput, entities_referencesUncheckedUpdateWithoutEntitiesInput>
  }

  export type entities_referencesUpdateManyWithWhereWithoutEntitiesInput = {
    where: entities_referencesScalarWhereInput
    data: XOR<entities_referencesUpdateManyMutationInput, entities_referencesUncheckedUpdateManyWithoutEntitiesInput>
  }

  export type entities_referencesScalarWhereInput = {
    AND?: entities_referencesScalarWhereInput | entities_referencesScalarWhereInput[]
    OR?: entities_referencesScalarWhereInput[]
    NOT?: entities_referencesScalarWhereInput | entities_referencesScalarWhereInput[]
    reference_id?: StringFilter<"entities_references"> | string
    entity_id?: StringFilter<"entities_references"> | string
    title?: StringFilter<"entities_references"> | string
    author?: StringFilter<"entities_references"> | string
    url?: StringFilter<"entities_references"> | string
  }

  export type groups_membersUpsertWithWhereUniqueWithoutEntitiesInput = {
    where: groups_membersWhereUniqueInput
    update: XOR<groups_membersUpdateWithoutEntitiesInput, groups_membersUncheckedUpdateWithoutEntitiesInput>
    create: XOR<groups_membersCreateWithoutEntitiesInput, groups_membersUncheckedCreateWithoutEntitiesInput>
  }

  export type groups_membersUpdateWithWhereUniqueWithoutEntitiesInput = {
    where: groups_membersWhereUniqueInput
    data: XOR<groups_membersUpdateWithoutEntitiesInput, groups_membersUncheckedUpdateWithoutEntitiesInput>
  }

  export type groups_membersUpdateManyWithWhereWithoutEntitiesInput = {
    where: groups_membersScalarWhereInput
    data: XOR<groups_membersUpdateManyMutationInput, groups_membersUncheckedUpdateManyWithoutEntitiesInput>
  }

  export type groups_membersScalarWhereInput = {
    AND?: groups_membersScalarWhereInput | groups_membersScalarWhereInput[]
    OR?: groups_membersScalarWhereInput[]
    NOT?: groups_membersScalarWhereInput | groups_membersScalarWhereInput[]
    groups_members_id?: StringFilter<"groups_members"> | string
    group_id?: StringFilter<"groups_members"> | string
    entity_id?: StringFilter<"groups_members"> | string
  }

  export type imagesUpsertWithWhereUniqueWithoutEntitiesInput = {
    where: imagesWhereUniqueInput
    update: XOR<imagesUpdateWithoutEntitiesInput, imagesUncheckedUpdateWithoutEntitiesInput>
    create: XOR<imagesCreateWithoutEntitiesInput, imagesUncheckedCreateWithoutEntitiesInput>
  }

  export type imagesUpdateWithWhereUniqueWithoutEntitiesInput = {
    where: imagesWhereUniqueInput
    data: XOR<imagesUpdateWithoutEntitiesInput, imagesUncheckedUpdateWithoutEntitiesInput>
  }

  export type imagesUpdateManyWithWhereWithoutEntitiesInput = {
    where: imagesScalarWhereInput
    data: XOR<imagesUpdateManyMutationInput, imagesUncheckedUpdateManyWithoutEntitiesInput>
  }

  export type imagesScalarWhereInput = {
    AND?: imagesScalarWhereInput | imagesScalarWhereInput[]
    OR?: imagesScalarWhereInput[]
    NOT?: imagesScalarWhereInput | imagesScalarWhereInput[]
    image_id?: StringFilter<"images"> | string
    image_creator_id?: StringFilter<"images"> | string
    image_title?: StringFilter<"images"> | string
    image_description?: StringFilter<"images"> | string
    image_filename?: StringFilter<"images"> | string
    image_data_id?: StringFilter<"images"> | string
    image_likes?: IntFilter<"images"> | number
    image_dislikes?: IntFilter<"images"> | number
    image_views?: IntFilter<"images"> | number
    image_date_posted?: DateTimeFilter<"images"> | Date | string
  }

  export type organizations_membersUpsertWithWhereUniqueWithoutEntitiesInput = {
    where: organizations_membersWhereUniqueInput
    update: XOR<organizations_membersUpdateWithoutEntitiesInput, organizations_membersUncheckedUpdateWithoutEntitiesInput>
    create: XOR<organizations_membersCreateWithoutEntitiesInput, organizations_membersUncheckedCreateWithoutEntitiesInput>
  }

  export type organizations_membersUpdateWithWhereUniqueWithoutEntitiesInput = {
    where: organizations_membersWhereUniqueInput
    data: XOR<organizations_membersUpdateWithoutEntitiesInput, organizations_membersUncheckedUpdateWithoutEntitiesInput>
  }

  export type organizations_membersUpdateManyWithWhereWithoutEntitiesInput = {
    where: organizations_membersScalarWhereInput
    data: XOR<organizations_membersUpdateManyMutationInput, organizations_membersUncheckedUpdateManyWithoutEntitiesInput>
  }

  export type organizations_membersScalarWhereInput = {
    AND?: organizations_membersScalarWhereInput | organizations_membersScalarWhereInput[]
    OR?: organizations_membersScalarWhereInput[]
    NOT?: organizations_membersScalarWhereInput | organizations_membersScalarWhereInput[]
    organizations_members_id?: StringFilter<"organizations_members"> | string
    organization_id?: StringFilter<"organizations_members"> | string
    entity_id?: StringFilter<"organizations_members"> | string
  }

  export type sheetsUpsertWithWhereUniqueWithoutEntitiesInput = {
    where: sheetsWhereUniqueInput
    update: XOR<sheetsUpdateWithoutEntitiesInput, sheetsUncheckedUpdateWithoutEntitiesInput>
    create: XOR<sheetsCreateWithoutEntitiesInput, sheetsUncheckedCreateWithoutEntitiesInput>
  }

  export type sheetsUpdateWithWhereUniqueWithoutEntitiesInput = {
    where: sheetsWhereUniqueInput
    data: XOR<sheetsUpdateWithoutEntitiesInput, sheetsUncheckedUpdateWithoutEntitiesInput>
  }

  export type sheetsUpdateManyWithWhereWithoutEntitiesInput = {
    where: sheetsScalarWhereInput
    data: XOR<sheetsUpdateManyMutationInput, sheetsUncheckedUpdateManyWithoutEntitiesInput>
  }

  export type sheetsScalarWhereInput = {
    AND?: sheetsScalarWhereInput | sheetsScalarWhereInput[]
    OR?: sheetsScalarWhereInput[]
    NOT?: sheetsScalarWhereInput | sheetsScalarWhereInput[]
    sheet_id?: StringFilter<"sheets"> | string
    sheet_author_id?: StringFilter<"sheets"> | string
    sheet_title?: StringFilter<"sheets"> | string
    sheet_subject?: StringFilter<"sheets"> | string
    sheet_filename?: StringFilter<"sheets"> | string
    sheet_data_id?: StringFilter<"sheets"> | string
    sheet_thumbnail_id?: StringNullableFilter<"sheets"> | string | null
    sheet_likes?: IntFilter<"sheets"> | number
    sheet_dislikes?: IntFilter<"sheets"> | number
    sheet_views?: IntFilter<"sheets"> | number
    sheet_date_posted?: DateTimeFilter<"sheets"> | Date | string
  }

  export type tables_membersUpsertWithWhereUniqueWithoutEntitiesInput = {
    where: tables_membersWhereUniqueInput
    update: XOR<tables_membersUpdateWithoutEntitiesInput, tables_membersUncheckedUpdateWithoutEntitiesInput>
    create: XOR<tables_membersCreateWithoutEntitiesInput, tables_membersUncheckedCreateWithoutEntitiesInput>
  }

  export type tables_membersUpdateWithWhereUniqueWithoutEntitiesInput = {
    where: tables_membersWhereUniqueInput
    data: XOR<tables_membersUpdateWithoutEntitiesInput, tables_membersUncheckedUpdateWithoutEntitiesInput>
  }

  export type tables_membersUpdateManyWithWhereWithoutEntitiesInput = {
    where: tables_membersScalarWhereInput
    data: XOR<tables_membersUpdateManyMutationInput, tables_membersUncheckedUpdateManyWithoutEntitiesInput>
  }

  export type tables_membersScalarWhereInput = {
    AND?: tables_membersScalarWhereInput | tables_membersScalarWhereInput[]
    OR?: tables_membersScalarWhereInput[]
    NOT?: tables_membersScalarWhereInput | tables_membersScalarWhereInput[]
    tables_members_id?: StringFilter<"tables_members"> | string
    table_id?: StringFilter<"tables_members"> | string
    member_id?: StringFilter<"tables_members"> | string
    table_position?: IntFilter<"tables_members"> | number
    live?: IntFilter<"tables_members"> | number
  }

  export type tables_messages_logsUpsertWithWhereUniqueWithoutEntitiesInput = {
    where: tables_messages_logsWhereUniqueInput
    update: XOR<tables_messages_logsUpdateWithoutEntitiesInput, tables_messages_logsUncheckedUpdateWithoutEntitiesInput>
    create: XOR<tables_messages_logsCreateWithoutEntitiesInput, tables_messages_logsUncheckedCreateWithoutEntitiesInput>
  }

  export type tables_messages_logsUpdateWithWhereUniqueWithoutEntitiesInput = {
    where: tables_messages_logsWhereUniqueInput
    data: XOR<tables_messages_logsUpdateWithoutEntitiesInput, tables_messages_logsUncheckedUpdateWithoutEntitiesInput>
  }

  export type tables_messages_logsUpdateManyWithWhereWithoutEntitiesInput = {
    where: tables_messages_logsScalarWhereInput
    data: XOR<tables_messages_logsUpdateManyMutationInput, tables_messages_logsUncheckedUpdateManyWithoutEntitiesInput>
  }

  export type tables_messages_logsScalarWhereInput = {
    AND?: tables_messages_logsScalarWhereInput | tables_messages_logsScalarWhereInput[]
    OR?: tables_messages_logsScalarWhereInput[]
    NOT?: tables_messages_logsScalarWhereInput | tables_messages_logsScalarWhereInput[]
    tables_messages_logs_id?: StringFilter<"tables_messages_logs"> | string
    table_id?: StringFilter<"tables_messages_logs"> | string
    entity_id?: StringFilter<"tables_messages_logs"> | string
    message?: StringFilter<"tables_messages_logs"> | string
    message_date?: DateTimeFilter<"tables_messages_logs"> | Date | string
  }

  export type tables_tabletopsUpsertWithWhereUniqueWithoutEntitiesInput = {
    where: tables_tabletopsWhereUniqueInput
    update: XOR<tables_tabletopsUpdateWithoutEntitiesInput, tables_tabletopsUncheckedUpdateWithoutEntitiesInput>
    create: XOR<tables_tabletopsCreateWithoutEntitiesInput, tables_tabletopsUncheckedCreateWithoutEntitiesInput>
  }

  export type tables_tabletopsUpdateWithWhereUniqueWithoutEntitiesInput = {
    where: tables_tabletopsWhereUniqueInput
    data: XOR<tables_tabletopsUpdateWithoutEntitiesInput, tables_tabletopsUncheckedUpdateWithoutEntitiesInput>
  }

  export type tables_tabletopsUpdateManyWithWhereWithoutEntitiesInput = {
    where: tables_tabletopsScalarWhereInput
    data: XOR<tables_tabletopsUpdateManyMutationInput, tables_tabletopsUncheckedUpdateManyWithoutEntitiesInput>
  }

  export type tables_tabletopsScalarWhereInput = {
    AND?: tables_tabletopsScalarWhereInput | tables_tabletopsScalarWhereInput[]
    OR?: tables_tabletopsScalarWhereInput[]
    NOT?: tables_tabletopsScalarWhereInput | tables_tabletopsScalarWhereInput[]
    tables_tabletops_id?: StringFilter<"tables_tabletops"> | string
    table_id?: StringFilter<"tables_tabletops"> | string
    creator_id?: StringFilter<"tables_tabletops"> | string
    tables_tabletops_data_id?: StringNullableFilter<"tables_tabletops"> | string | null
    type?: IntFilter<"tables_tabletops"> | number
    content_date_posted?: DateTimeFilter<"tables_tabletops"> | Date | string
    content_x_position?: IntFilter<"tables_tabletops"> | number
    content_y_position?: IntFilter<"tables_tabletops"> | number
    content_rotation?: IntFilter<"tables_tabletops"> | number
    content_filename?: StringNullableFilter<"tables_tabletops"> | string | null
  }

  export type videosUpsertWithWhereUniqueWithoutEntitiesInput = {
    where: videosWhereUniqueInput
    update: XOR<videosUpdateWithoutEntitiesInput, videosUncheckedUpdateWithoutEntitiesInput>
    create: XOR<videosCreateWithoutEntitiesInput, videosUncheckedCreateWithoutEntitiesInput>
  }

  export type videosUpdateWithWhereUniqueWithoutEntitiesInput = {
    where: videosWhereUniqueInput
    data: XOR<videosUpdateWithoutEntitiesInput, videosUncheckedUpdateWithoutEntitiesInput>
  }

  export type videosUpdateManyWithWhereWithoutEntitiesInput = {
    where: videosScalarWhereInput
    data: XOR<videosUpdateManyMutationInput, videosUncheckedUpdateManyWithoutEntitiesInput>
  }

  export type videosScalarWhereInput = {
    AND?: videosScalarWhereInput | videosScalarWhereInput[]
    OR?: videosScalarWhereInput[]
    NOT?: videosScalarWhereInput | videosScalarWhereInput[]
    video_id?: StringFilter<"videos"> | string
    video_creator_id?: StringFilter<"videos"> | string
    video_title?: StringFilter<"videos"> | string
    video_description?: StringFilter<"videos"> | string
    video_filename?: StringFilter<"videos"> | string
    video_data_id?: StringFilter<"videos"> | string
    video_thumbnail_id?: StringNullableFilter<"videos"> | string | null
    video_likes?: IntFilter<"videos"> | number
    video_dislikes?: IntFilter<"videos"> | number
    video_views?: IntFilter<"videos"> | number
    video_date_posted?: DateTimeNullableFilter<"videos"> | Date | string | null
  }

  export type contentCreateWithoutEntities_contentInput = {
    content_id: string
    content_type?: number | null
    collections_content?: collections_contentCreateNestedManyWithoutContentInput
    entities_dislikes?: entities_dislikesCreateNestedManyWithoutContentInput
    entities_likes?: entities_likesCreateNestedManyWithoutContentInput
  }

  export type contentUncheckedCreateWithoutEntities_contentInput = {
    content_id: string
    content_type?: number | null
    collections_content?: collections_contentUncheckedCreateNestedManyWithoutContentInput
    entities_dislikes?: entities_dislikesUncheckedCreateNestedManyWithoutContentInput
    entities_likes?: entities_likesUncheckedCreateNestedManyWithoutContentInput
  }

  export type contentCreateOrConnectWithoutEntities_contentInput = {
    where: contentWhereUniqueInput
    create: XOR<contentCreateWithoutEntities_contentInput, contentUncheckedCreateWithoutEntities_contentInput>
  }

  export type entitiesCreateWithoutEntities_contentInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersCreateNestedManyWithoutEntitiesInput
    images?: imagesCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsCreateNestedManyWithoutEntitiesInput
    videos?: videosCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesUncheckedCreateWithoutEntities_contentInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsUncheckedCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesUncheckedCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersUncheckedCreateNestedManyWithoutEntitiesInput
    images?: imagesUncheckedCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersUncheckedCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsUncheckedCreateNestedManyWithoutEntitiesInput
    videos?: videosUncheckedCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesCreateOrConnectWithoutEntities_contentInput = {
    where: entitiesWhereUniqueInput
    create: XOR<entitiesCreateWithoutEntities_contentInput, entitiesUncheckedCreateWithoutEntities_contentInput>
  }

  export type contentUpsertWithoutEntities_contentInput = {
    update: XOR<contentUpdateWithoutEntities_contentInput, contentUncheckedUpdateWithoutEntities_contentInput>
    create: XOR<contentCreateWithoutEntities_contentInput, contentUncheckedCreateWithoutEntities_contentInput>
    where?: contentWhereInput
  }

  export type contentUpdateToOneWithWhereWithoutEntities_contentInput = {
    where?: contentWhereInput
    data: XOR<contentUpdateWithoutEntities_contentInput, contentUncheckedUpdateWithoutEntities_contentInput>
  }

  export type contentUpdateWithoutEntities_contentInput = {
    content_id?: StringFieldUpdateOperationsInput | string
    content_type?: NullableIntFieldUpdateOperationsInput | number | null
    collections_content?: collections_contentUpdateManyWithoutContentNestedInput
    entities_dislikes?: entities_dislikesUpdateManyWithoutContentNestedInput
    entities_likes?: entities_likesUpdateManyWithoutContentNestedInput
  }

  export type contentUncheckedUpdateWithoutEntities_contentInput = {
    content_id?: StringFieldUpdateOperationsInput | string
    content_type?: NullableIntFieldUpdateOperationsInput | number | null
    collections_content?: collections_contentUncheckedUpdateManyWithoutContentNestedInput
    entities_dislikes?: entities_dislikesUncheckedUpdateManyWithoutContentNestedInput
    entities_likes?: entities_likesUncheckedUpdateManyWithoutContentNestedInput
  }

  export type entitiesUpsertWithoutEntities_contentInput = {
    update: XOR<entitiesUpdateWithoutEntities_contentInput, entitiesUncheckedUpdateWithoutEntities_contentInput>
    create: XOR<entitiesCreateWithoutEntities_contentInput, entitiesUncheckedCreateWithoutEntities_contentInput>
    where?: entitiesWhereInput
  }

  export type entitiesUpdateToOneWithWhereWithoutEntities_contentInput = {
    where?: entitiesWhereInput
    data: XOR<entitiesUpdateWithoutEntities_contentInput, entitiesUncheckedUpdateWithoutEntities_contentInput>
  }

  export type entitiesUpdateWithoutEntities_contentInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUpdateManyWithoutEntitiesNestedInput
    images?: imagesUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUpdateManyWithoutEntitiesNestedInput
    videos?: videosUpdateManyWithoutEntitiesNestedInput
  }

  export type entitiesUncheckedUpdateWithoutEntities_contentInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUncheckedUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUncheckedUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    images?: imagesUncheckedUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUncheckedUpdateManyWithoutEntitiesNestedInput
    videos?: videosUncheckedUpdateManyWithoutEntitiesNestedInput
  }

  export type contentCreateWithoutEntities_dislikesInput = {
    content_id: string
    content_type?: number | null
    collections_content?: collections_contentCreateNestedManyWithoutContentInput
    entities_content?: entities_contentCreateNestedManyWithoutContentInput
    entities_likes?: entities_likesCreateNestedManyWithoutContentInput
  }

  export type contentUncheckedCreateWithoutEntities_dislikesInput = {
    content_id: string
    content_type?: number | null
    collections_content?: collections_contentUncheckedCreateNestedManyWithoutContentInput
    entities_content?: entities_contentUncheckedCreateNestedManyWithoutContentInput
    entities_likes?: entities_likesUncheckedCreateNestedManyWithoutContentInput
  }

  export type contentCreateOrConnectWithoutEntities_dislikesInput = {
    where: contentWhereUniqueInput
    create: XOR<contentCreateWithoutEntities_dislikesInput, contentUncheckedCreateWithoutEntities_dislikesInput>
  }

  export type entitiesCreateWithoutEntities_dislikesInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersCreateNestedManyWithoutEntitiesInput
    images?: imagesCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsCreateNestedManyWithoutEntitiesInput
    videos?: videosCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesUncheckedCreateWithoutEntities_dislikesInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsUncheckedCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentUncheckedCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesUncheckedCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersUncheckedCreateNestedManyWithoutEntitiesInput
    images?: imagesUncheckedCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersUncheckedCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsUncheckedCreateNestedManyWithoutEntitiesInput
    videos?: videosUncheckedCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesCreateOrConnectWithoutEntities_dislikesInput = {
    where: entitiesWhereUniqueInput
    create: XOR<entitiesCreateWithoutEntities_dislikesInput, entitiesUncheckedCreateWithoutEntities_dislikesInput>
  }

  export type contentUpsertWithoutEntities_dislikesInput = {
    update: XOR<contentUpdateWithoutEntities_dislikesInput, contentUncheckedUpdateWithoutEntities_dislikesInput>
    create: XOR<contentCreateWithoutEntities_dislikesInput, contentUncheckedCreateWithoutEntities_dislikesInput>
    where?: contentWhereInput
  }

  export type contentUpdateToOneWithWhereWithoutEntities_dislikesInput = {
    where?: contentWhereInput
    data: XOR<contentUpdateWithoutEntities_dislikesInput, contentUncheckedUpdateWithoutEntities_dislikesInput>
  }

  export type contentUpdateWithoutEntities_dislikesInput = {
    content_id?: StringFieldUpdateOperationsInput | string
    content_type?: NullableIntFieldUpdateOperationsInput | number | null
    collections_content?: collections_contentUpdateManyWithoutContentNestedInput
    entities_content?: entities_contentUpdateManyWithoutContentNestedInput
    entities_likes?: entities_likesUpdateManyWithoutContentNestedInput
  }

  export type contentUncheckedUpdateWithoutEntities_dislikesInput = {
    content_id?: StringFieldUpdateOperationsInput | string
    content_type?: NullableIntFieldUpdateOperationsInput | number | null
    collections_content?: collections_contentUncheckedUpdateManyWithoutContentNestedInput
    entities_content?: entities_contentUncheckedUpdateManyWithoutContentNestedInput
    entities_likes?: entities_likesUncheckedUpdateManyWithoutContentNestedInput
  }

  export type entitiesUpsertWithoutEntities_dislikesInput = {
    update: XOR<entitiesUpdateWithoutEntities_dislikesInput, entitiesUncheckedUpdateWithoutEntities_dislikesInput>
    create: XOR<entitiesCreateWithoutEntities_dislikesInput, entitiesUncheckedCreateWithoutEntities_dislikesInput>
    where?: entitiesWhereInput
  }

  export type entitiesUpdateToOneWithWhereWithoutEntities_dislikesInput = {
    where?: entitiesWhereInput
    data: XOR<entitiesUpdateWithoutEntities_dislikesInput, entitiesUncheckedUpdateWithoutEntities_dislikesInput>
  }

  export type entitiesUpdateWithoutEntities_dislikesInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUpdateManyWithoutEntitiesNestedInput
    images?: imagesUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUpdateManyWithoutEntitiesNestedInput
    videos?: videosUpdateManyWithoutEntitiesNestedInput
  }

  export type entitiesUncheckedUpdateWithoutEntities_dislikesInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUncheckedUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUncheckedUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    images?: imagesUncheckedUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUncheckedUpdateManyWithoutEntitiesNestedInput
    videos?: videosUncheckedUpdateManyWithoutEntitiesNestedInput
  }

  export type contentCreateWithoutEntities_likesInput = {
    content_id: string
    content_type?: number | null
    collections_content?: collections_contentCreateNestedManyWithoutContentInput
    entities_content?: entities_contentCreateNestedManyWithoutContentInput
    entities_dislikes?: entities_dislikesCreateNestedManyWithoutContentInput
  }

  export type contentUncheckedCreateWithoutEntities_likesInput = {
    content_id: string
    content_type?: number | null
    collections_content?: collections_contentUncheckedCreateNestedManyWithoutContentInput
    entities_content?: entities_contentUncheckedCreateNestedManyWithoutContentInput
    entities_dislikes?: entities_dislikesUncheckedCreateNestedManyWithoutContentInput
  }

  export type contentCreateOrConnectWithoutEntities_likesInput = {
    where: contentWhereUniqueInput
    create: XOR<contentCreateWithoutEntities_likesInput, contentUncheckedCreateWithoutEntities_likesInput>
  }

  export type entitiesCreateWithoutEntities_likesInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersCreateNestedManyWithoutEntitiesInput
    images?: imagesCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsCreateNestedManyWithoutEntitiesInput
    videos?: videosCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesUncheckedCreateWithoutEntities_likesInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsUncheckedCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentUncheckedCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesUncheckedCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersUncheckedCreateNestedManyWithoutEntitiesInput
    images?: imagesUncheckedCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersUncheckedCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsUncheckedCreateNestedManyWithoutEntitiesInput
    videos?: videosUncheckedCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesCreateOrConnectWithoutEntities_likesInput = {
    where: entitiesWhereUniqueInput
    create: XOR<entitiesCreateWithoutEntities_likesInput, entitiesUncheckedCreateWithoutEntities_likesInput>
  }

  export type contentUpsertWithoutEntities_likesInput = {
    update: XOR<contentUpdateWithoutEntities_likesInput, contentUncheckedUpdateWithoutEntities_likesInput>
    create: XOR<contentCreateWithoutEntities_likesInput, contentUncheckedCreateWithoutEntities_likesInput>
    where?: contentWhereInput
  }

  export type contentUpdateToOneWithWhereWithoutEntities_likesInput = {
    where?: contentWhereInput
    data: XOR<contentUpdateWithoutEntities_likesInput, contentUncheckedUpdateWithoutEntities_likesInput>
  }

  export type contentUpdateWithoutEntities_likesInput = {
    content_id?: StringFieldUpdateOperationsInput | string
    content_type?: NullableIntFieldUpdateOperationsInput | number | null
    collections_content?: collections_contentUpdateManyWithoutContentNestedInput
    entities_content?: entities_contentUpdateManyWithoutContentNestedInput
    entities_dislikes?: entities_dislikesUpdateManyWithoutContentNestedInput
  }

  export type contentUncheckedUpdateWithoutEntities_likesInput = {
    content_id?: StringFieldUpdateOperationsInput | string
    content_type?: NullableIntFieldUpdateOperationsInput | number | null
    collections_content?: collections_contentUncheckedUpdateManyWithoutContentNestedInput
    entities_content?: entities_contentUncheckedUpdateManyWithoutContentNestedInput
    entities_dislikes?: entities_dislikesUncheckedUpdateManyWithoutContentNestedInput
  }

  export type entitiesUpsertWithoutEntities_likesInput = {
    update: XOR<entitiesUpdateWithoutEntities_likesInput, entitiesUncheckedUpdateWithoutEntities_likesInput>
    create: XOR<entitiesCreateWithoutEntities_likesInput, entitiesUncheckedCreateWithoutEntities_likesInput>
    where?: entitiesWhereInput
  }

  export type entitiesUpdateToOneWithWhereWithoutEntities_likesInput = {
    where?: entitiesWhereInput
    data: XOR<entitiesUpdateWithoutEntities_likesInput, entitiesUncheckedUpdateWithoutEntities_likesInput>
  }

  export type entitiesUpdateWithoutEntities_likesInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUpdateManyWithoutEntitiesNestedInput
    images?: imagesUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUpdateManyWithoutEntitiesNestedInput
    videos?: videosUpdateManyWithoutEntitiesNestedInput
  }

  export type entitiesUncheckedUpdateWithoutEntities_likesInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUncheckedUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUncheckedUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    images?: imagesUncheckedUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUncheckedUpdateManyWithoutEntitiesNestedInput
    videos?: videosUncheckedUpdateManyWithoutEntitiesNestedInput
  }

  export type entitiesCreateWithoutEntities_referencesInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersCreateNestedManyWithoutEntitiesInput
    images?: imagesCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsCreateNestedManyWithoutEntitiesInput
    videos?: videosCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesUncheckedCreateWithoutEntities_referencesInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsUncheckedCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentUncheckedCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesUncheckedCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersUncheckedCreateNestedManyWithoutEntitiesInput
    images?: imagesUncheckedCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersUncheckedCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsUncheckedCreateNestedManyWithoutEntitiesInput
    videos?: videosUncheckedCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesCreateOrConnectWithoutEntities_referencesInput = {
    where: entitiesWhereUniqueInput
    create: XOR<entitiesCreateWithoutEntities_referencesInput, entitiesUncheckedCreateWithoutEntities_referencesInput>
  }

  export type entitiesUpsertWithoutEntities_referencesInput = {
    update: XOR<entitiesUpdateWithoutEntities_referencesInput, entitiesUncheckedUpdateWithoutEntities_referencesInput>
    create: XOR<entitiesCreateWithoutEntities_referencesInput, entitiesUncheckedCreateWithoutEntities_referencesInput>
    where?: entitiesWhereInput
  }

  export type entitiesUpdateToOneWithWhereWithoutEntities_referencesInput = {
    where?: entitiesWhereInput
    data: XOR<entitiesUpdateWithoutEntities_referencesInput, entitiesUncheckedUpdateWithoutEntities_referencesInput>
  }

  export type entitiesUpdateWithoutEntities_referencesInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUpdateManyWithoutEntitiesNestedInput
    images?: imagesUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUpdateManyWithoutEntitiesNestedInput
    videos?: videosUpdateManyWithoutEntitiesNestedInput
  }

  export type entitiesUncheckedUpdateWithoutEntities_referencesInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUncheckedUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUncheckedUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    images?: imagesUncheckedUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUncheckedUpdateManyWithoutEntitiesNestedInput
    videos?: videosUncheckedUpdateManyWithoutEntitiesNestedInput
  }

  export type profile_picturesCreateWithoutGroupsInput = {
    profile_picture_id: string
    profile_picture_data: Buffer
    profile_picture_filename: string
    individuals?: individualsCreateNestedManyWithoutProfile_picturesInput
    organizations?: organizationsCreateNestedManyWithoutProfile_picturesInput
  }

  export type profile_picturesUncheckedCreateWithoutGroupsInput = {
    profile_picture_id: string
    profile_picture_data: Buffer
    profile_picture_filename: string
    individuals?: individualsUncheckedCreateNestedManyWithoutProfile_picturesInput
    organizations?: organizationsUncheckedCreateNestedManyWithoutProfile_picturesInput
  }

  export type profile_picturesCreateOrConnectWithoutGroupsInput = {
    where: profile_picturesWhereUniqueInput
    create: XOR<profile_picturesCreateWithoutGroupsInput, profile_picturesUncheckedCreateWithoutGroupsInput>
  }

  export type groups_membersCreateWithoutGroupsInput = {
    groups_members_id: string
    entities: entitiesCreateNestedOneWithoutGroups_membersInput
  }

  export type groups_membersUncheckedCreateWithoutGroupsInput = {
    groups_members_id: string
    entity_id: string
  }

  export type groups_membersCreateOrConnectWithoutGroupsInput = {
    where: groups_membersWhereUniqueInput
    create: XOR<groups_membersCreateWithoutGroupsInput, groups_membersUncheckedCreateWithoutGroupsInput>
  }

  export type groups_membersCreateManyGroupsInputEnvelope = {
    data: groups_membersCreateManyGroupsInput | groups_membersCreateManyGroupsInput[]
    skipDuplicates?: boolean
  }

  export type profile_picturesUpsertWithoutGroupsInput = {
    update: XOR<profile_picturesUpdateWithoutGroupsInput, profile_picturesUncheckedUpdateWithoutGroupsInput>
    create: XOR<profile_picturesCreateWithoutGroupsInput, profile_picturesUncheckedCreateWithoutGroupsInput>
    where?: profile_picturesWhereInput
  }

  export type profile_picturesUpdateToOneWithWhereWithoutGroupsInput = {
    where?: profile_picturesWhereInput
    data: XOR<profile_picturesUpdateWithoutGroupsInput, profile_picturesUncheckedUpdateWithoutGroupsInput>
  }

  export type profile_picturesUpdateWithoutGroupsInput = {
    profile_picture_id?: StringFieldUpdateOperationsInput | string
    profile_picture_data?: BytesFieldUpdateOperationsInput | Buffer
    profile_picture_filename?: StringFieldUpdateOperationsInput | string
    individuals?: individualsUpdateManyWithoutProfile_picturesNestedInput
    organizations?: organizationsUpdateManyWithoutProfile_picturesNestedInput
  }

  export type profile_picturesUncheckedUpdateWithoutGroupsInput = {
    profile_picture_id?: StringFieldUpdateOperationsInput | string
    profile_picture_data?: BytesFieldUpdateOperationsInput | Buffer
    profile_picture_filename?: StringFieldUpdateOperationsInput | string
    individuals?: individualsUncheckedUpdateManyWithoutProfile_picturesNestedInput
    organizations?: organizationsUncheckedUpdateManyWithoutProfile_picturesNestedInput
  }

  export type groups_membersUpsertWithWhereUniqueWithoutGroupsInput = {
    where: groups_membersWhereUniqueInput
    update: XOR<groups_membersUpdateWithoutGroupsInput, groups_membersUncheckedUpdateWithoutGroupsInput>
    create: XOR<groups_membersCreateWithoutGroupsInput, groups_membersUncheckedCreateWithoutGroupsInput>
  }

  export type groups_membersUpdateWithWhereUniqueWithoutGroupsInput = {
    where: groups_membersWhereUniqueInput
    data: XOR<groups_membersUpdateWithoutGroupsInput, groups_membersUncheckedUpdateWithoutGroupsInput>
  }

  export type groups_membersUpdateManyWithWhereWithoutGroupsInput = {
    where: groups_membersScalarWhereInput
    data: XOR<groups_membersUpdateManyMutationInput, groups_membersUncheckedUpdateManyWithoutGroupsInput>
  }

  export type entitiesCreateWithoutGroups_membersInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesCreateNestedManyWithoutEntitiesInput
    images?: imagesCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsCreateNestedManyWithoutEntitiesInput
    videos?: videosCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesUncheckedCreateWithoutGroups_membersInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsUncheckedCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentUncheckedCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesUncheckedCreateNestedManyWithoutEntitiesInput
    images?: imagesUncheckedCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersUncheckedCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsUncheckedCreateNestedManyWithoutEntitiesInput
    videos?: videosUncheckedCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesCreateOrConnectWithoutGroups_membersInput = {
    where: entitiesWhereUniqueInput
    create: XOR<entitiesCreateWithoutGroups_membersInput, entitiesUncheckedCreateWithoutGroups_membersInput>
  }

  export type groupsCreateWithoutGroups_membersInput = {
    group_id: string
    group_handle: string
    group_name?: string | null
    group_current_issue?: string | null
    group_stances?: string | null
    group_description?: string | null
    profile_pictures?: profile_picturesCreateNestedOneWithoutGroupsInput
  }

  export type groupsUncheckedCreateWithoutGroups_membersInput = {
    group_id: string
    group_handle: string
    group_name?: string | null
    group_current_issue?: string | null
    group_stances?: string | null
    group_description?: string | null
    profile_picture_id?: string | null
  }

  export type groupsCreateOrConnectWithoutGroups_membersInput = {
    where: groupsWhereUniqueInput
    create: XOR<groupsCreateWithoutGroups_membersInput, groupsUncheckedCreateWithoutGroups_membersInput>
  }

  export type entitiesUpsertWithoutGroups_membersInput = {
    update: XOR<entitiesUpdateWithoutGroups_membersInput, entitiesUncheckedUpdateWithoutGroups_membersInput>
    create: XOR<entitiesCreateWithoutGroups_membersInput, entitiesUncheckedCreateWithoutGroups_membersInput>
    where?: entitiesWhereInput
  }

  export type entitiesUpdateToOneWithWhereWithoutGroups_membersInput = {
    where?: entitiesWhereInput
    data: XOR<entitiesUpdateWithoutGroups_membersInput, entitiesUncheckedUpdateWithoutGroups_membersInput>
  }

  export type entitiesUpdateWithoutGroups_membersInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUpdateManyWithoutEntitiesNestedInput
    images?: imagesUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUpdateManyWithoutEntitiesNestedInput
    videos?: videosUpdateManyWithoutEntitiesNestedInput
  }

  export type entitiesUncheckedUpdateWithoutGroups_membersInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUncheckedUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUncheckedUpdateManyWithoutEntitiesNestedInput
    images?: imagesUncheckedUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUncheckedUpdateManyWithoutEntitiesNestedInput
    videos?: videosUncheckedUpdateManyWithoutEntitiesNestedInput
  }

  export type groupsUpsertWithoutGroups_membersInput = {
    update: XOR<groupsUpdateWithoutGroups_membersInput, groupsUncheckedUpdateWithoutGroups_membersInput>
    create: XOR<groupsCreateWithoutGroups_membersInput, groupsUncheckedCreateWithoutGroups_membersInput>
    where?: groupsWhereInput
  }

  export type groupsUpdateToOneWithWhereWithoutGroups_membersInput = {
    where?: groupsWhereInput
    data: XOR<groupsUpdateWithoutGroups_membersInput, groupsUncheckedUpdateWithoutGroups_membersInput>
  }

  export type groupsUpdateWithoutGroups_membersInput = {
    group_id?: StringFieldUpdateOperationsInput | string
    group_handle?: StringFieldUpdateOperationsInput | string
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    group_current_issue?: NullableStringFieldUpdateOperationsInput | string | null
    group_stances?: NullableStringFieldUpdateOperationsInput | string | null
    group_description?: NullableStringFieldUpdateOperationsInput | string | null
    profile_pictures?: profile_picturesUpdateOneWithoutGroupsNestedInput
  }

  export type groupsUncheckedUpdateWithoutGroups_membersInput = {
    group_id?: StringFieldUpdateOperationsInput | string
    group_handle?: StringFieldUpdateOperationsInput | string
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    group_current_issue?: NullableStringFieldUpdateOperationsInput | string | null
    group_stances?: NullableStringFieldUpdateOperationsInput | string | null
    group_description?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type entitiesCreateWithoutImagesInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsCreateNestedManyWithoutEntitiesInput
    videos?: videosCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesUncheckedCreateWithoutImagesInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsUncheckedCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentUncheckedCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesUncheckedCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersUncheckedCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersUncheckedCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsUncheckedCreateNestedManyWithoutEntitiesInput
    videos?: videosUncheckedCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesCreateOrConnectWithoutImagesInput = {
    where: entitiesWhereUniqueInput
    create: XOR<entitiesCreateWithoutImagesInput, entitiesUncheckedCreateWithoutImagesInput>
  }

  export type images_dataCreateWithoutImagesInput = {
    image_data_id: string
    image_data: Buffer
  }

  export type images_dataUncheckedCreateWithoutImagesInput = {
    image_data_id: string
    image_data: Buffer
  }

  export type images_dataCreateOrConnectWithoutImagesInput = {
    where: images_dataWhereUniqueInput
    create: XOR<images_dataCreateWithoutImagesInput, images_dataUncheckedCreateWithoutImagesInput>
  }

  export type entitiesUpsertWithoutImagesInput = {
    update: XOR<entitiesUpdateWithoutImagesInput, entitiesUncheckedUpdateWithoutImagesInput>
    create: XOR<entitiesCreateWithoutImagesInput, entitiesUncheckedCreateWithoutImagesInput>
    where?: entitiesWhereInput
  }

  export type entitiesUpdateToOneWithWhereWithoutImagesInput = {
    where?: entitiesWhereInput
    data: XOR<entitiesUpdateWithoutImagesInput, entitiesUncheckedUpdateWithoutImagesInput>
  }

  export type entitiesUpdateWithoutImagesInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUpdateManyWithoutEntitiesNestedInput
    videos?: videosUpdateManyWithoutEntitiesNestedInput
  }

  export type entitiesUncheckedUpdateWithoutImagesInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUncheckedUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUncheckedUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUncheckedUpdateManyWithoutEntitiesNestedInput
    videos?: videosUncheckedUpdateManyWithoutEntitiesNestedInput
  }

  export type images_dataUpsertWithoutImagesInput = {
    update: XOR<images_dataUpdateWithoutImagesInput, images_dataUncheckedUpdateWithoutImagesInput>
    create: XOR<images_dataCreateWithoutImagesInput, images_dataUncheckedCreateWithoutImagesInput>
    where?: images_dataWhereInput
  }

  export type images_dataUpdateToOneWithWhereWithoutImagesInput = {
    where?: images_dataWhereInput
    data: XOR<images_dataUpdateWithoutImagesInput, images_dataUncheckedUpdateWithoutImagesInput>
  }

  export type images_dataUpdateWithoutImagesInput = {
    image_data_id?: StringFieldUpdateOperationsInput | string
    image_data?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type images_dataUncheckedUpdateWithoutImagesInput = {
    image_data_id?: StringFieldUpdateOperationsInput | string
    image_data?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type imagesCreateWithoutImages_dataInput = {
    image_id: string
    image_title: string
    image_description: string
    image_filename: string
    image_likes?: number
    image_dislikes?: number
    image_views?: number
    image_date_posted?: Date | string
    entities: entitiesCreateNestedOneWithoutImagesInput
  }

  export type imagesUncheckedCreateWithoutImages_dataInput = {
    image_id: string
    image_creator_id: string
    image_title: string
    image_description: string
    image_filename: string
    image_likes?: number
    image_dislikes?: number
    image_views?: number
    image_date_posted?: Date | string
  }

  export type imagesCreateOrConnectWithoutImages_dataInput = {
    where: imagesWhereUniqueInput
    create: XOR<imagesCreateWithoutImages_dataInput, imagesUncheckedCreateWithoutImages_dataInput>
  }

  export type imagesCreateManyImages_dataInputEnvelope = {
    data: imagesCreateManyImages_dataInput | imagesCreateManyImages_dataInput[]
    skipDuplicates?: boolean
  }

  export type imagesUpsertWithWhereUniqueWithoutImages_dataInput = {
    where: imagesWhereUniqueInput
    update: XOR<imagesUpdateWithoutImages_dataInput, imagesUncheckedUpdateWithoutImages_dataInput>
    create: XOR<imagesCreateWithoutImages_dataInput, imagesUncheckedCreateWithoutImages_dataInput>
  }

  export type imagesUpdateWithWhereUniqueWithoutImages_dataInput = {
    where: imagesWhereUniqueInput
    data: XOR<imagesUpdateWithoutImages_dataInput, imagesUncheckedUpdateWithoutImages_dataInput>
  }

  export type imagesUpdateManyWithWhereWithoutImages_dataInput = {
    where: imagesScalarWhereInput
    data: XOR<imagesUpdateManyMutationInput, imagesUncheckedUpdateManyWithoutImages_dataInput>
  }

  export type user_credentialsCreateWithoutIndividualsInput = {
    user_id: string
    username: string
    user_password: string
    user_first_name?: string | null
    user_last_name?: string | null
    user_email?: string | null
    user_phone_number?: string | null
  }

  export type user_credentialsUncheckedCreateWithoutIndividualsInput = {
    user_id: string
    username: string
    user_password: string
    user_first_name?: string | null
    user_last_name?: string | null
    user_email?: string | null
    user_phone_number?: string | null
  }

  export type user_credentialsCreateOrConnectWithoutIndividualsInput = {
    where: user_credentialsWhereUniqueInput
    create: XOR<user_credentialsCreateWithoutIndividualsInput, user_credentialsUncheckedCreateWithoutIndividualsInput>
  }

  export type profile_picturesCreateWithoutIndividualsInput = {
    profile_picture_id: string
    profile_picture_data: Buffer
    profile_picture_filename: string
    groups?: groupsCreateNestedManyWithoutProfile_picturesInput
    organizations?: organizationsCreateNestedManyWithoutProfile_picturesInput
  }

  export type profile_picturesUncheckedCreateWithoutIndividualsInput = {
    profile_picture_id: string
    profile_picture_data: Buffer
    profile_picture_filename: string
    groups?: groupsUncheckedCreateNestedManyWithoutProfile_picturesInput
    organizations?: organizationsUncheckedCreateNestedManyWithoutProfile_picturesInput
  }

  export type profile_picturesCreateOrConnectWithoutIndividualsInput = {
    where: profile_picturesWhereUniqueInput
    create: XOR<profile_picturesCreateWithoutIndividualsInput, profile_picturesUncheckedCreateWithoutIndividualsInput>
  }

  export type user_credentialsUpsertWithoutIndividualsInput = {
    update: XOR<user_credentialsUpdateWithoutIndividualsInput, user_credentialsUncheckedUpdateWithoutIndividualsInput>
    create: XOR<user_credentialsCreateWithoutIndividualsInput, user_credentialsUncheckedCreateWithoutIndividualsInput>
    where?: user_credentialsWhereInput
  }

  export type user_credentialsUpdateToOneWithWhereWithoutIndividualsInput = {
    where?: user_credentialsWhereInput
    data: XOR<user_credentialsUpdateWithoutIndividualsInput, user_credentialsUncheckedUpdateWithoutIndividualsInput>
  }

  export type user_credentialsUpdateWithoutIndividualsInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    user_first_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_last_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_email?: NullableStringFieldUpdateOperationsInput | string | null
    user_phone_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_credentialsUncheckedUpdateWithoutIndividualsInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    user_first_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_last_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_email?: NullableStringFieldUpdateOperationsInput | string | null
    user_phone_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type profile_picturesUpsertWithoutIndividualsInput = {
    update: XOR<profile_picturesUpdateWithoutIndividualsInput, profile_picturesUncheckedUpdateWithoutIndividualsInput>
    create: XOR<profile_picturesCreateWithoutIndividualsInput, profile_picturesUncheckedCreateWithoutIndividualsInput>
    where?: profile_picturesWhereInput
  }

  export type profile_picturesUpdateToOneWithWhereWithoutIndividualsInput = {
    where?: profile_picturesWhereInput
    data: XOR<profile_picturesUpdateWithoutIndividualsInput, profile_picturesUncheckedUpdateWithoutIndividualsInput>
  }

  export type profile_picturesUpdateWithoutIndividualsInput = {
    profile_picture_id?: StringFieldUpdateOperationsInput | string
    profile_picture_data?: BytesFieldUpdateOperationsInput | Buffer
    profile_picture_filename?: StringFieldUpdateOperationsInput | string
    groups?: groupsUpdateManyWithoutProfile_picturesNestedInput
    organizations?: organizationsUpdateManyWithoutProfile_picturesNestedInput
  }

  export type profile_picturesUncheckedUpdateWithoutIndividualsInput = {
    profile_picture_id?: StringFieldUpdateOperationsInput | string
    profile_picture_data?: BytesFieldUpdateOperationsInput | Buffer
    profile_picture_filename?: StringFieldUpdateOperationsInput | string
    groups?: groupsUncheckedUpdateManyWithoutProfile_picturesNestedInput
    organizations?: organizationsUncheckedUpdateManyWithoutProfile_picturesNestedInput
  }

  export type profile_picturesCreateWithoutOrganizationsInput = {
    profile_picture_id: string
    profile_picture_data: Buffer
    profile_picture_filename: string
    groups?: groupsCreateNestedManyWithoutProfile_picturesInput
    individuals?: individualsCreateNestedManyWithoutProfile_picturesInput
  }

  export type profile_picturesUncheckedCreateWithoutOrganizationsInput = {
    profile_picture_id: string
    profile_picture_data: Buffer
    profile_picture_filename: string
    groups?: groupsUncheckedCreateNestedManyWithoutProfile_picturesInput
    individuals?: individualsUncheckedCreateNestedManyWithoutProfile_picturesInput
  }

  export type profile_picturesCreateOrConnectWithoutOrganizationsInput = {
    where: profile_picturesWhereUniqueInput
    create: XOR<profile_picturesCreateWithoutOrganizationsInput, profile_picturesUncheckedCreateWithoutOrganizationsInput>
  }

  export type organizations_membersCreateWithoutOrganizationsInput = {
    organizations_members_id: string
    entities: entitiesCreateNestedOneWithoutOrganizations_membersInput
  }

  export type organizations_membersUncheckedCreateWithoutOrganizationsInput = {
    organizations_members_id: string
    entity_id: string
  }

  export type organizations_membersCreateOrConnectWithoutOrganizationsInput = {
    where: organizations_membersWhereUniqueInput
    create: XOR<organizations_membersCreateWithoutOrganizationsInput, organizations_membersUncheckedCreateWithoutOrganizationsInput>
  }

  export type organizations_membersCreateManyOrganizationsInputEnvelope = {
    data: organizations_membersCreateManyOrganizationsInput | organizations_membersCreateManyOrganizationsInput[]
    skipDuplicates?: boolean
  }

  export type profile_picturesUpsertWithoutOrganizationsInput = {
    update: XOR<profile_picturesUpdateWithoutOrganizationsInput, profile_picturesUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<profile_picturesCreateWithoutOrganizationsInput, profile_picturesUncheckedCreateWithoutOrganizationsInput>
    where?: profile_picturesWhereInput
  }

  export type profile_picturesUpdateToOneWithWhereWithoutOrganizationsInput = {
    where?: profile_picturesWhereInput
    data: XOR<profile_picturesUpdateWithoutOrganizationsInput, profile_picturesUncheckedUpdateWithoutOrganizationsInput>
  }

  export type profile_picturesUpdateWithoutOrganizationsInput = {
    profile_picture_id?: StringFieldUpdateOperationsInput | string
    profile_picture_data?: BytesFieldUpdateOperationsInput | Buffer
    profile_picture_filename?: StringFieldUpdateOperationsInput | string
    groups?: groupsUpdateManyWithoutProfile_picturesNestedInput
    individuals?: individualsUpdateManyWithoutProfile_picturesNestedInput
  }

  export type profile_picturesUncheckedUpdateWithoutOrganizationsInput = {
    profile_picture_id?: StringFieldUpdateOperationsInput | string
    profile_picture_data?: BytesFieldUpdateOperationsInput | Buffer
    profile_picture_filename?: StringFieldUpdateOperationsInput | string
    groups?: groupsUncheckedUpdateManyWithoutProfile_picturesNestedInput
    individuals?: individualsUncheckedUpdateManyWithoutProfile_picturesNestedInput
  }

  export type organizations_membersUpsertWithWhereUniqueWithoutOrganizationsInput = {
    where: organizations_membersWhereUniqueInput
    update: XOR<organizations_membersUpdateWithoutOrganizationsInput, organizations_membersUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<organizations_membersCreateWithoutOrganizationsInput, organizations_membersUncheckedCreateWithoutOrganizationsInput>
  }

  export type organizations_membersUpdateWithWhereUniqueWithoutOrganizationsInput = {
    where: organizations_membersWhereUniqueInput
    data: XOR<organizations_membersUpdateWithoutOrganizationsInput, organizations_membersUncheckedUpdateWithoutOrganizationsInput>
  }

  export type organizations_membersUpdateManyWithWhereWithoutOrganizationsInput = {
    where: organizations_membersScalarWhereInput
    data: XOR<organizations_membersUpdateManyMutationInput, organizations_membersUncheckedUpdateManyWithoutOrganizationsInput>
  }

  export type entitiesCreateWithoutOrganizations_membersInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersCreateNestedManyWithoutEntitiesInput
    images?: imagesCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsCreateNestedManyWithoutEntitiesInput
    videos?: videosCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesUncheckedCreateWithoutOrganizations_membersInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsUncheckedCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentUncheckedCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesUncheckedCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersUncheckedCreateNestedManyWithoutEntitiesInput
    images?: imagesUncheckedCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersUncheckedCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsUncheckedCreateNestedManyWithoutEntitiesInput
    videos?: videosUncheckedCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesCreateOrConnectWithoutOrganizations_membersInput = {
    where: entitiesWhereUniqueInput
    create: XOR<entitiesCreateWithoutOrganizations_membersInput, entitiesUncheckedCreateWithoutOrganizations_membersInput>
  }

  export type organizationsCreateWithoutOrganizations_membersInput = {
    organization_id: string
    organization_handle: string
    organization_name?: string | null
    organization_current_issue?: string | null
    organization_stances?: string | null
    organization_description?: string | null
    profile_pictures?: profile_picturesCreateNestedOneWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateWithoutOrganizations_membersInput = {
    organization_id: string
    organization_handle: string
    organization_name?: string | null
    organization_current_issue?: string | null
    organization_stances?: string | null
    organization_description?: string | null
    profile_picture_id?: string | null
  }

  export type organizationsCreateOrConnectWithoutOrganizations_membersInput = {
    where: organizationsWhereUniqueInput
    create: XOR<organizationsCreateWithoutOrganizations_membersInput, organizationsUncheckedCreateWithoutOrganizations_membersInput>
  }

  export type entitiesUpsertWithoutOrganizations_membersInput = {
    update: XOR<entitiesUpdateWithoutOrganizations_membersInput, entitiesUncheckedUpdateWithoutOrganizations_membersInput>
    create: XOR<entitiesCreateWithoutOrganizations_membersInput, entitiesUncheckedCreateWithoutOrganizations_membersInput>
    where?: entitiesWhereInput
  }

  export type entitiesUpdateToOneWithWhereWithoutOrganizations_membersInput = {
    where?: entitiesWhereInput
    data: XOR<entitiesUpdateWithoutOrganizations_membersInput, entitiesUncheckedUpdateWithoutOrganizations_membersInput>
  }

  export type entitiesUpdateWithoutOrganizations_membersInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUpdateManyWithoutEntitiesNestedInput
    images?: imagesUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUpdateManyWithoutEntitiesNestedInput
    videos?: videosUpdateManyWithoutEntitiesNestedInput
  }

  export type entitiesUncheckedUpdateWithoutOrganizations_membersInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUncheckedUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUncheckedUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    images?: imagesUncheckedUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUncheckedUpdateManyWithoutEntitiesNestedInput
    videos?: videosUncheckedUpdateManyWithoutEntitiesNestedInput
  }

  export type organizationsUpsertWithoutOrganizations_membersInput = {
    update: XOR<organizationsUpdateWithoutOrganizations_membersInput, organizationsUncheckedUpdateWithoutOrganizations_membersInput>
    create: XOR<organizationsCreateWithoutOrganizations_membersInput, organizationsUncheckedCreateWithoutOrganizations_membersInput>
    where?: organizationsWhereInput
  }

  export type organizationsUpdateToOneWithWhereWithoutOrganizations_membersInput = {
    where?: organizationsWhereInput
    data: XOR<organizationsUpdateWithoutOrganizations_membersInput, organizationsUncheckedUpdateWithoutOrganizations_membersInput>
  }

  export type organizationsUpdateWithoutOrganizations_membersInput = {
    organization_id?: StringFieldUpdateOperationsInput | string
    organization_handle?: StringFieldUpdateOperationsInput | string
    organization_name?: NullableStringFieldUpdateOperationsInput | string | null
    organization_current_issue?: NullableStringFieldUpdateOperationsInput | string | null
    organization_stances?: NullableStringFieldUpdateOperationsInput | string | null
    organization_description?: NullableStringFieldUpdateOperationsInput | string | null
    profile_pictures?: profile_picturesUpdateOneWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateWithoutOrganizations_membersInput = {
    organization_id?: StringFieldUpdateOperationsInput | string
    organization_handle?: StringFieldUpdateOperationsInput | string
    organization_name?: NullableStringFieldUpdateOperationsInput | string | null
    organization_current_issue?: NullableStringFieldUpdateOperationsInput | string | null
    organization_stances?: NullableStringFieldUpdateOperationsInput | string | null
    organization_description?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type groupsCreateWithoutProfile_picturesInput = {
    group_id: string
    group_handle: string
    group_name?: string | null
    group_current_issue?: string | null
    group_stances?: string | null
    group_description?: string | null
    groups_members?: groups_membersCreateNestedManyWithoutGroupsInput
  }

  export type groupsUncheckedCreateWithoutProfile_picturesInput = {
    group_id: string
    group_handle: string
    group_name?: string | null
    group_current_issue?: string | null
    group_stances?: string | null
    group_description?: string | null
    groups_members?: groups_membersUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type groupsCreateOrConnectWithoutProfile_picturesInput = {
    where: groupsWhereUniqueInput
    create: XOR<groupsCreateWithoutProfile_picturesInput, groupsUncheckedCreateWithoutProfile_picturesInput>
  }

  export type groupsCreateManyProfile_picturesInputEnvelope = {
    data: groupsCreateManyProfile_picturesInput | groupsCreateManyProfile_picturesInput[]
    skipDuplicates?: boolean
  }

  export type individualsCreateWithoutProfile_picturesInput = {
    individual_username: string
    individual_name?: string | null
    individual_current_issue?: string | null
    individual_roles?: string | null
    individual_description?: string | null
    user_credentials: user_credentialsCreateNestedOneWithoutIndividualsInput
  }

  export type individualsUncheckedCreateWithoutProfile_picturesInput = {
    individual_id: string
    individual_username: string
    individual_name?: string | null
    individual_current_issue?: string | null
    individual_roles?: string | null
    individual_description?: string | null
  }

  export type individualsCreateOrConnectWithoutProfile_picturesInput = {
    where: individualsWhereUniqueInput
    create: XOR<individualsCreateWithoutProfile_picturesInput, individualsUncheckedCreateWithoutProfile_picturesInput>
  }

  export type individualsCreateManyProfile_picturesInputEnvelope = {
    data: individualsCreateManyProfile_picturesInput | individualsCreateManyProfile_picturesInput[]
    skipDuplicates?: boolean
  }

  export type organizationsCreateWithoutProfile_picturesInput = {
    organization_id: string
    organization_handle: string
    organization_name?: string | null
    organization_current_issue?: string | null
    organization_stances?: string | null
    organization_description?: string | null
    organizations_members?: organizations_membersCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateWithoutProfile_picturesInput = {
    organization_id: string
    organization_handle: string
    organization_name?: string | null
    organization_current_issue?: string | null
    organization_stances?: string | null
    organization_description?: string | null
    organizations_members?: organizations_membersUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsCreateOrConnectWithoutProfile_picturesInput = {
    where: organizationsWhereUniqueInput
    create: XOR<organizationsCreateWithoutProfile_picturesInput, organizationsUncheckedCreateWithoutProfile_picturesInput>
  }

  export type organizationsCreateManyProfile_picturesInputEnvelope = {
    data: organizationsCreateManyProfile_picturesInput | organizationsCreateManyProfile_picturesInput[]
    skipDuplicates?: boolean
  }

  export type groupsUpsertWithWhereUniqueWithoutProfile_picturesInput = {
    where: groupsWhereUniqueInput
    update: XOR<groupsUpdateWithoutProfile_picturesInput, groupsUncheckedUpdateWithoutProfile_picturesInput>
    create: XOR<groupsCreateWithoutProfile_picturesInput, groupsUncheckedCreateWithoutProfile_picturesInput>
  }

  export type groupsUpdateWithWhereUniqueWithoutProfile_picturesInput = {
    where: groupsWhereUniqueInput
    data: XOR<groupsUpdateWithoutProfile_picturesInput, groupsUncheckedUpdateWithoutProfile_picturesInput>
  }

  export type groupsUpdateManyWithWhereWithoutProfile_picturesInput = {
    where: groupsScalarWhereInput
    data: XOR<groupsUpdateManyMutationInput, groupsUncheckedUpdateManyWithoutProfile_picturesInput>
  }

  export type groupsScalarWhereInput = {
    AND?: groupsScalarWhereInput | groupsScalarWhereInput[]
    OR?: groupsScalarWhereInput[]
    NOT?: groupsScalarWhereInput | groupsScalarWhereInput[]
    group_id?: StringFilter<"groups"> | string
    group_handle?: StringFilter<"groups"> | string
    group_name?: StringNullableFilter<"groups"> | string | null
    group_current_issue?: StringNullableFilter<"groups"> | string | null
    group_stances?: StringNullableFilter<"groups"> | string | null
    group_description?: StringNullableFilter<"groups"> | string | null
    profile_picture_id?: StringNullableFilter<"groups"> | string | null
  }

  export type individualsUpsertWithWhereUniqueWithoutProfile_picturesInput = {
    where: individualsWhereUniqueInput
    update: XOR<individualsUpdateWithoutProfile_picturesInput, individualsUncheckedUpdateWithoutProfile_picturesInput>
    create: XOR<individualsCreateWithoutProfile_picturesInput, individualsUncheckedCreateWithoutProfile_picturesInput>
  }

  export type individualsUpdateWithWhereUniqueWithoutProfile_picturesInput = {
    where: individualsWhereUniqueInput
    data: XOR<individualsUpdateWithoutProfile_picturesInput, individualsUncheckedUpdateWithoutProfile_picturesInput>
  }

  export type individualsUpdateManyWithWhereWithoutProfile_picturesInput = {
    where: individualsScalarWhereInput
    data: XOR<individualsUpdateManyMutationInput, individualsUncheckedUpdateManyWithoutProfile_picturesInput>
  }

  export type individualsScalarWhereInput = {
    AND?: individualsScalarWhereInput | individualsScalarWhereInput[]
    OR?: individualsScalarWhereInput[]
    NOT?: individualsScalarWhereInput | individualsScalarWhereInput[]
    individual_id?: StringFilter<"individuals"> | string
    individual_username?: StringFilter<"individuals"> | string
    individual_name?: StringNullableFilter<"individuals"> | string | null
    individual_current_issue?: StringNullableFilter<"individuals"> | string | null
    individual_roles?: StringNullableFilter<"individuals"> | string | null
    individual_description?: StringNullableFilter<"individuals"> | string | null
    profile_picture_id?: StringNullableFilter<"individuals"> | string | null
  }

  export type organizationsUpsertWithWhereUniqueWithoutProfile_picturesInput = {
    where: organizationsWhereUniqueInput
    update: XOR<organizationsUpdateWithoutProfile_picturesInput, organizationsUncheckedUpdateWithoutProfile_picturesInput>
    create: XOR<organizationsCreateWithoutProfile_picturesInput, organizationsUncheckedCreateWithoutProfile_picturesInput>
  }

  export type organizationsUpdateWithWhereUniqueWithoutProfile_picturesInput = {
    where: organizationsWhereUniqueInput
    data: XOR<organizationsUpdateWithoutProfile_picturesInput, organizationsUncheckedUpdateWithoutProfile_picturesInput>
  }

  export type organizationsUpdateManyWithWhereWithoutProfile_picturesInput = {
    where: organizationsScalarWhereInput
    data: XOR<organizationsUpdateManyMutationInput, organizationsUncheckedUpdateManyWithoutProfile_picturesInput>
  }

  export type organizationsScalarWhereInput = {
    AND?: organizationsScalarWhereInput | organizationsScalarWhereInput[]
    OR?: organizationsScalarWhereInput[]
    NOT?: organizationsScalarWhereInput | organizationsScalarWhereInput[]
    organization_id?: StringFilter<"organizations"> | string
    organization_handle?: StringFilter<"organizations"> | string
    organization_name?: StringNullableFilter<"organizations"> | string | null
    organization_current_issue?: StringNullableFilter<"organizations"> | string | null
    organization_stances?: StringNullableFilter<"organizations"> | string | null
    organization_description?: StringNullableFilter<"organizations"> | string | null
    profile_picture_id?: StringNullableFilter<"organizations"> | string | null
  }

  export type entitiesCreateWithoutSheetsInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersCreateNestedManyWithoutEntitiesInput
    images?: imagesCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsCreateNestedManyWithoutEntitiesInput
    videos?: videosCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesUncheckedCreateWithoutSheetsInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsUncheckedCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentUncheckedCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesUncheckedCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersUncheckedCreateNestedManyWithoutEntitiesInput
    images?: imagesUncheckedCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersUncheckedCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsUncheckedCreateNestedManyWithoutEntitiesInput
    videos?: videosUncheckedCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesCreateOrConnectWithoutSheetsInput = {
    where: entitiesWhereUniqueInput
    create: XOR<entitiesCreateWithoutSheetsInput, entitiesUncheckedCreateWithoutSheetsInput>
  }

  export type sheets_dataCreateWithoutSheetsInput = {
    sheet_data_id: string
    sheet_data: Buffer
  }

  export type sheets_dataUncheckedCreateWithoutSheetsInput = {
    sheet_data_id: string
    sheet_data: Buffer
  }

  export type sheets_dataCreateOrConnectWithoutSheetsInput = {
    where: sheets_dataWhereUniqueInput
    create: XOR<sheets_dataCreateWithoutSheetsInput, sheets_dataUncheckedCreateWithoutSheetsInput>
  }

  export type sheets_thumbnailsCreateWithoutSheetsInput = {
    sheet_thumbnail_id: string
    sheet_thumbnail_data: Buffer
    sheet_thumbnail_filename: string
    sheet_thumbnail_description?: string | null
  }

  export type sheets_thumbnailsUncheckedCreateWithoutSheetsInput = {
    sheet_thumbnail_id: string
    sheet_thumbnail_data: Buffer
    sheet_thumbnail_filename: string
    sheet_thumbnail_description?: string | null
  }

  export type sheets_thumbnailsCreateOrConnectWithoutSheetsInput = {
    where: sheets_thumbnailsWhereUniqueInput
    create: XOR<sheets_thumbnailsCreateWithoutSheetsInput, sheets_thumbnailsUncheckedCreateWithoutSheetsInput>
  }

  export type entitiesUpsertWithoutSheetsInput = {
    update: XOR<entitiesUpdateWithoutSheetsInput, entitiesUncheckedUpdateWithoutSheetsInput>
    create: XOR<entitiesCreateWithoutSheetsInput, entitiesUncheckedCreateWithoutSheetsInput>
    where?: entitiesWhereInput
  }

  export type entitiesUpdateToOneWithWhereWithoutSheetsInput = {
    where?: entitiesWhereInput
    data: XOR<entitiesUpdateWithoutSheetsInput, entitiesUncheckedUpdateWithoutSheetsInput>
  }

  export type entitiesUpdateWithoutSheetsInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUpdateManyWithoutEntitiesNestedInput
    images?: imagesUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUpdateManyWithoutEntitiesNestedInput
    videos?: videosUpdateManyWithoutEntitiesNestedInput
  }

  export type entitiesUncheckedUpdateWithoutSheetsInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUncheckedUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUncheckedUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    images?: imagesUncheckedUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUncheckedUpdateManyWithoutEntitiesNestedInput
    videos?: videosUncheckedUpdateManyWithoutEntitiesNestedInput
  }

  export type sheets_dataUpsertWithoutSheetsInput = {
    update: XOR<sheets_dataUpdateWithoutSheetsInput, sheets_dataUncheckedUpdateWithoutSheetsInput>
    create: XOR<sheets_dataCreateWithoutSheetsInput, sheets_dataUncheckedCreateWithoutSheetsInput>
    where?: sheets_dataWhereInput
  }

  export type sheets_dataUpdateToOneWithWhereWithoutSheetsInput = {
    where?: sheets_dataWhereInput
    data: XOR<sheets_dataUpdateWithoutSheetsInput, sheets_dataUncheckedUpdateWithoutSheetsInput>
  }

  export type sheets_dataUpdateWithoutSheetsInput = {
    sheet_data_id?: StringFieldUpdateOperationsInput | string
    sheet_data?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type sheets_dataUncheckedUpdateWithoutSheetsInput = {
    sheet_data_id?: StringFieldUpdateOperationsInput | string
    sheet_data?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type sheets_thumbnailsUpsertWithoutSheetsInput = {
    update: XOR<sheets_thumbnailsUpdateWithoutSheetsInput, sheets_thumbnailsUncheckedUpdateWithoutSheetsInput>
    create: XOR<sheets_thumbnailsCreateWithoutSheetsInput, sheets_thumbnailsUncheckedCreateWithoutSheetsInput>
    where?: sheets_thumbnailsWhereInput
  }

  export type sheets_thumbnailsUpdateToOneWithWhereWithoutSheetsInput = {
    where?: sheets_thumbnailsWhereInput
    data: XOR<sheets_thumbnailsUpdateWithoutSheetsInput, sheets_thumbnailsUncheckedUpdateWithoutSheetsInput>
  }

  export type sheets_thumbnailsUpdateWithoutSheetsInput = {
    sheet_thumbnail_id?: StringFieldUpdateOperationsInput | string
    sheet_thumbnail_data?: BytesFieldUpdateOperationsInput | Buffer
    sheet_thumbnail_filename?: StringFieldUpdateOperationsInput | string
    sheet_thumbnail_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sheets_thumbnailsUncheckedUpdateWithoutSheetsInput = {
    sheet_thumbnail_id?: StringFieldUpdateOperationsInput | string
    sheet_thumbnail_data?: BytesFieldUpdateOperationsInput | Buffer
    sheet_thumbnail_filename?: StringFieldUpdateOperationsInput | string
    sheet_thumbnail_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sheetsCreateWithoutSheets_dataInput = {
    sheet_id: string
    sheet_title: string
    sheet_subject: string
    sheet_filename: string
    sheet_likes?: number
    sheet_dislikes?: number
    sheet_views?: number
    sheet_date_posted?: Date | string
    entities: entitiesCreateNestedOneWithoutSheetsInput
    sheets_thumbnails?: sheets_thumbnailsCreateNestedOneWithoutSheetsInput
  }

  export type sheetsUncheckedCreateWithoutSheets_dataInput = {
    sheet_id: string
    sheet_author_id: string
    sheet_title: string
    sheet_subject: string
    sheet_filename: string
    sheet_thumbnail_id?: string | null
    sheet_likes?: number
    sheet_dislikes?: number
    sheet_views?: number
    sheet_date_posted?: Date | string
  }

  export type sheetsCreateOrConnectWithoutSheets_dataInput = {
    where: sheetsWhereUniqueInput
    create: XOR<sheetsCreateWithoutSheets_dataInput, sheetsUncheckedCreateWithoutSheets_dataInput>
  }

  export type sheetsCreateManySheets_dataInputEnvelope = {
    data: sheetsCreateManySheets_dataInput | sheetsCreateManySheets_dataInput[]
    skipDuplicates?: boolean
  }

  export type sheetsUpsertWithWhereUniqueWithoutSheets_dataInput = {
    where: sheetsWhereUniqueInput
    update: XOR<sheetsUpdateWithoutSheets_dataInput, sheetsUncheckedUpdateWithoutSheets_dataInput>
    create: XOR<sheetsCreateWithoutSheets_dataInput, sheetsUncheckedCreateWithoutSheets_dataInput>
  }

  export type sheetsUpdateWithWhereUniqueWithoutSheets_dataInput = {
    where: sheetsWhereUniqueInput
    data: XOR<sheetsUpdateWithoutSheets_dataInput, sheetsUncheckedUpdateWithoutSheets_dataInput>
  }

  export type sheetsUpdateManyWithWhereWithoutSheets_dataInput = {
    where: sheetsScalarWhereInput
    data: XOR<sheetsUpdateManyMutationInput, sheetsUncheckedUpdateManyWithoutSheets_dataInput>
  }

  export type sheetsCreateWithoutSheets_thumbnailsInput = {
    sheet_id: string
    sheet_title: string
    sheet_subject: string
    sheet_filename: string
    sheet_likes?: number
    sheet_dislikes?: number
    sheet_views?: number
    sheet_date_posted?: Date | string
    entities: entitiesCreateNestedOneWithoutSheetsInput
    sheets_data: sheets_dataCreateNestedOneWithoutSheetsInput
  }

  export type sheetsUncheckedCreateWithoutSheets_thumbnailsInput = {
    sheet_id: string
    sheet_author_id: string
    sheet_title: string
    sheet_subject: string
    sheet_filename: string
    sheet_data_id: string
    sheet_likes?: number
    sheet_dislikes?: number
    sheet_views?: number
    sheet_date_posted?: Date | string
  }

  export type sheetsCreateOrConnectWithoutSheets_thumbnailsInput = {
    where: sheetsWhereUniqueInput
    create: XOR<sheetsCreateWithoutSheets_thumbnailsInput, sheetsUncheckedCreateWithoutSheets_thumbnailsInput>
  }

  export type sheetsCreateManySheets_thumbnailsInputEnvelope = {
    data: sheetsCreateManySheets_thumbnailsInput | sheetsCreateManySheets_thumbnailsInput[]
    skipDuplicates?: boolean
  }

  export type sheetsUpsertWithWhereUniqueWithoutSheets_thumbnailsInput = {
    where: sheetsWhereUniqueInput
    update: XOR<sheetsUpdateWithoutSheets_thumbnailsInput, sheetsUncheckedUpdateWithoutSheets_thumbnailsInput>
    create: XOR<sheetsCreateWithoutSheets_thumbnailsInput, sheetsUncheckedCreateWithoutSheets_thumbnailsInput>
  }

  export type sheetsUpdateWithWhereUniqueWithoutSheets_thumbnailsInput = {
    where: sheetsWhereUniqueInput
    data: XOR<sheetsUpdateWithoutSheets_thumbnailsInput, sheetsUncheckedUpdateWithoutSheets_thumbnailsInput>
  }

  export type sheetsUpdateManyWithWhereWithoutSheets_thumbnailsInput = {
    where: sheetsScalarWhereInput
    data: XOR<sheetsUpdateManyMutationInput, sheetsUncheckedUpdateManyWithoutSheets_thumbnailsInput>
  }

  export type tables_picturesCreateWithoutTablesInput = {
    tables_pictures_id: string
    table_picture_data: Buffer
    table_picture_filename: string
  }

  export type tables_picturesUncheckedCreateWithoutTablesInput = {
    tables_pictures_id: string
    table_picture_data: Buffer
    table_picture_filename: string
  }

  export type tables_picturesCreateOrConnectWithoutTablesInput = {
    where: tables_picturesWhereUniqueInput
    create: XOR<tables_picturesCreateWithoutTablesInput, tables_picturesUncheckedCreateWithoutTablesInput>
  }

  export type tables_membersCreateWithoutTablesInput = {
    tables_members_id: string
    table_position: number
    live?: number
    entities: entitiesCreateNestedOneWithoutTables_membersInput
  }

  export type tables_membersUncheckedCreateWithoutTablesInput = {
    tables_members_id: string
    member_id: string
    table_position: number
    live?: number
  }

  export type tables_membersCreateOrConnectWithoutTablesInput = {
    where: tables_membersWhereUniqueInput
    create: XOR<tables_membersCreateWithoutTablesInput, tables_membersUncheckedCreateWithoutTablesInput>
  }

  export type tables_membersCreateManyTablesInputEnvelope = {
    data: tables_membersCreateManyTablesInput | tables_membersCreateManyTablesInput[]
    skipDuplicates?: boolean
  }

  export type tables_messages_logsCreateWithoutTablesInput = {
    tables_messages_logs_id: string
    message: string
    message_date: Date | string
    entities: entitiesCreateNestedOneWithoutTables_messages_logsInput
  }

  export type tables_messages_logsUncheckedCreateWithoutTablesInput = {
    tables_messages_logs_id: string
    entity_id: string
    message: string
    message_date: Date | string
  }

  export type tables_messages_logsCreateOrConnectWithoutTablesInput = {
    where: tables_messages_logsWhereUniqueInput
    create: XOR<tables_messages_logsCreateWithoutTablesInput, tables_messages_logsUncheckedCreateWithoutTablesInput>
  }

  export type tables_messages_logsCreateManyTablesInputEnvelope = {
    data: tables_messages_logsCreateManyTablesInput | tables_messages_logsCreateManyTablesInput[]
    skipDuplicates?: boolean
  }

  export type tables_tabletopsCreateWithoutTablesInput = {
    tables_tabletops_id: string
    type: number
    content_date_posted: Date | string
    content_x_position: number
    content_y_position: number
    content_rotation: number
    content_filename?: string | null
    entities: entitiesCreateNestedOneWithoutTables_tabletopsInput
    tables_tabletops_data?: tables_tabletops_dataCreateNestedOneWithoutTables_tabletopsInput
  }

  export type tables_tabletopsUncheckedCreateWithoutTablesInput = {
    tables_tabletops_id: string
    creator_id: string
    tables_tabletops_data_id?: string | null
    type: number
    content_date_posted: Date | string
    content_x_position: number
    content_y_position: number
    content_rotation: number
    content_filename?: string | null
  }

  export type tables_tabletopsCreateOrConnectWithoutTablesInput = {
    where: tables_tabletopsWhereUniqueInput
    create: XOR<tables_tabletopsCreateWithoutTablesInput, tables_tabletopsUncheckedCreateWithoutTablesInput>
  }

  export type tables_tabletopsCreateManyTablesInputEnvelope = {
    data: tables_tabletopsCreateManyTablesInput | tables_tabletopsCreateManyTablesInput[]
    skipDuplicates?: boolean
  }

  export type tables_picturesUpsertWithoutTablesInput = {
    update: XOR<tables_picturesUpdateWithoutTablesInput, tables_picturesUncheckedUpdateWithoutTablesInput>
    create: XOR<tables_picturesCreateWithoutTablesInput, tables_picturesUncheckedCreateWithoutTablesInput>
    where?: tables_picturesWhereInput
  }

  export type tables_picturesUpdateToOneWithWhereWithoutTablesInput = {
    where?: tables_picturesWhereInput
    data: XOR<tables_picturesUpdateWithoutTablesInput, tables_picturesUncheckedUpdateWithoutTablesInput>
  }

  export type tables_picturesUpdateWithoutTablesInput = {
    tables_pictures_id?: StringFieldUpdateOperationsInput | string
    table_picture_data?: BytesFieldUpdateOperationsInput | Buffer
    table_picture_filename?: StringFieldUpdateOperationsInput | string
  }

  export type tables_picturesUncheckedUpdateWithoutTablesInput = {
    tables_pictures_id?: StringFieldUpdateOperationsInput | string
    table_picture_data?: BytesFieldUpdateOperationsInput | Buffer
    table_picture_filename?: StringFieldUpdateOperationsInput | string
  }

  export type tables_membersUpsertWithWhereUniqueWithoutTablesInput = {
    where: tables_membersWhereUniqueInput
    update: XOR<tables_membersUpdateWithoutTablesInput, tables_membersUncheckedUpdateWithoutTablesInput>
    create: XOR<tables_membersCreateWithoutTablesInput, tables_membersUncheckedCreateWithoutTablesInput>
  }

  export type tables_membersUpdateWithWhereUniqueWithoutTablesInput = {
    where: tables_membersWhereUniqueInput
    data: XOR<tables_membersUpdateWithoutTablesInput, tables_membersUncheckedUpdateWithoutTablesInput>
  }

  export type tables_membersUpdateManyWithWhereWithoutTablesInput = {
    where: tables_membersScalarWhereInput
    data: XOR<tables_membersUpdateManyMutationInput, tables_membersUncheckedUpdateManyWithoutTablesInput>
  }

  export type tables_messages_logsUpsertWithWhereUniqueWithoutTablesInput = {
    where: tables_messages_logsWhereUniqueInput
    update: XOR<tables_messages_logsUpdateWithoutTablesInput, tables_messages_logsUncheckedUpdateWithoutTablesInput>
    create: XOR<tables_messages_logsCreateWithoutTablesInput, tables_messages_logsUncheckedCreateWithoutTablesInput>
  }

  export type tables_messages_logsUpdateWithWhereUniqueWithoutTablesInput = {
    where: tables_messages_logsWhereUniqueInput
    data: XOR<tables_messages_logsUpdateWithoutTablesInput, tables_messages_logsUncheckedUpdateWithoutTablesInput>
  }

  export type tables_messages_logsUpdateManyWithWhereWithoutTablesInput = {
    where: tables_messages_logsScalarWhereInput
    data: XOR<tables_messages_logsUpdateManyMutationInput, tables_messages_logsUncheckedUpdateManyWithoutTablesInput>
  }

  export type tables_tabletopsUpsertWithWhereUniqueWithoutTablesInput = {
    where: tables_tabletopsWhereUniqueInput
    update: XOR<tables_tabletopsUpdateWithoutTablesInput, tables_tabletopsUncheckedUpdateWithoutTablesInput>
    create: XOR<tables_tabletopsCreateWithoutTablesInput, tables_tabletopsUncheckedCreateWithoutTablesInput>
  }

  export type tables_tabletopsUpdateWithWhereUniqueWithoutTablesInput = {
    where: tables_tabletopsWhereUniqueInput
    data: XOR<tables_tabletopsUpdateWithoutTablesInput, tables_tabletopsUncheckedUpdateWithoutTablesInput>
  }

  export type tables_tabletopsUpdateManyWithWhereWithoutTablesInput = {
    where: tables_tabletopsScalarWhereInput
    data: XOR<tables_tabletopsUpdateManyMutationInput, tables_tabletopsUncheckedUpdateManyWithoutTablesInput>
  }

  export type entitiesCreateWithoutTables_membersInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersCreateNestedManyWithoutEntitiesInput
    images?: imagesCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsCreateNestedManyWithoutEntitiesInput
    videos?: videosCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesUncheckedCreateWithoutTables_membersInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsUncheckedCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentUncheckedCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesUncheckedCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersUncheckedCreateNestedManyWithoutEntitiesInput
    images?: imagesUncheckedCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsUncheckedCreateNestedManyWithoutEntitiesInput
    videos?: videosUncheckedCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesCreateOrConnectWithoutTables_membersInput = {
    where: entitiesWhereUniqueInput
    create: XOR<entitiesCreateWithoutTables_membersInput, entitiesUncheckedCreateWithoutTables_membersInput>
  }

  export type tablesCreateWithoutTables_membersInput = {
    table_id: string
    table_name?: string | null
    table_creation_date: Date | string
    last_message?: string | null
    last_message_date?: Date | string | null
    tables_pictures?: tables_picturesCreateNestedOneWithoutTablesInput
    tables_messages_logs?: tables_messages_logsCreateNestedManyWithoutTablesInput
    tables_tabletops?: tables_tabletopsCreateNestedManyWithoutTablesInput
  }

  export type tablesUncheckedCreateWithoutTables_membersInput = {
    table_id: string
    table_name?: string | null
    table_creation_date: Date | string
    last_message?: string | null
    last_message_date?: Date | string | null
    tables_pictures_id?: string | null
    tables_messages_logs?: tables_messages_logsUncheckedCreateNestedManyWithoutTablesInput
    tables_tabletops?: tables_tabletopsUncheckedCreateNestedManyWithoutTablesInput
  }

  export type tablesCreateOrConnectWithoutTables_membersInput = {
    where: tablesWhereUniqueInput
    create: XOR<tablesCreateWithoutTables_membersInput, tablesUncheckedCreateWithoutTables_membersInput>
  }

  export type entitiesUpsertWithoutTables_membersInput = {
    update: XOR<entitiesUpdateWithoutTables_membersInput, entitiesUncheckedUpdateWithoutTables_membersInput>
    create: XOR<entitiesCreateWithoutTables_membersInput, entitiesUncheckedCreateWithoutTables_membersInput>
    where?: entitiesWhereInput
  }

  export type entitiesUpdateToOneWithWhereWithoutTables_membersInput = {
    where?: entitiesWhereInput
    data: XOR<entitiesUpdateWithoutTables_membersInput, entitiesUncheckedUpdateWithoutTables_membersInput>
  }

  export type entitiesUpdateWithoutTables_membersInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUpdateManyWithoutEntitiesNestedInput
    images?: imagesUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUpdateManyWithoutEntitiesNestedInput
    videos?: videosUpdateManyWithoutEntitiesNestedInput
  }

  export type entitiesUncheckedUpdateWithoutTables_membersInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUncheckedUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUncheckedUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    images?: imagesUncheckedUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUncheckedUpdateManyWithoutEntitiesNestedInput
    videos?: videosUncheckedUpdateManyWithoutEntitiesNestedInput
  }

  export type tablesUpsertWithoutTables_membersInput = {
    update: XOR<tablesUpdateWithoutTables_membersInput, tablesUncheckedUpdateWithoutTables_membersInput>
    create: XOR<tablesCreateWithoutTables_membersInput, tablesUncheckedCreateWithoutTables_membersInput>
    where?: tablesWhereInput
  }

  export type tablesUpdateToOneWithWhereWithoutTables_membersInput = {
    where?: tablesWhereInput
    data: XOR<tablesUpdateWithoutTables_membersInput, tablesUncheckedUpdateWithoutTables_membersInput>
  }

  export type tablesUpdateWithoutTables_membersInput = {
    table_id?: StringFieldUpdateOperationsInput | string
    table_name?: NullableStringFieldUpdateOperationsInput | string | null
    table_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tables_pictures?: tables_picturesUpdateOneWithoutTablesNestedInput
    tables_messages_logs?: tables_messages_logsUpdateManyWithoutTablesNestedInput
    tables_tabletops?: tables_tabletopsUpdateManyWithoutTablesNestedInput
  }

  export type tablesUncheckedUpdateWithoutTables_membersInput = {
    table_id?: StringFieldUpdateOperationsInput | string
    table_name?: NullableStringFieldUpdateOperationsInput | string | null
    table_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tables_pictures_id?: NullableStringFieldUpdateOperationsInput | string | null
    tables_messages_logs?: tables_messages_logsUncheckedUpdateManyWithoutTablesNestedInput
    tables_tabletops?: tables_tabletopsUncheckedUpdateManyWithoutTablesNestedInput
  }

  export type entitiesCreateWithoutTables_messages_logsInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersCreateNestedManyWithoutEntitiesInput
    images?: imagesCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsCreateNestedManyWithoutEntitiesInput
    videos?: videosCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesUncheckedCreateWithoutTables_messages_logsInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsUncheckedCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentUncheckedCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesUncheckedCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersUncheckedCreateNestedManyWithoutEntitiesInput
    images?: imagesUncheckedCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersUncheckedCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsUncheckedCreateNestedManyWithoutEntitiesInput
    videos?: videosUncheckedCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesCreateOrConnectWithoutTables_messages_logsInput = {
    where: entitiesWhereUniqueInput
    create: XOR<entitiesCreateWithoutTables_messages_logsInput, entitiesUncheckedCreateWithoutTables_messages_logsInput>
  }

  export type tablesCreateWithoutTables_messages_logsInput = {
    table_id: string
    table_name?: string | null
    table_creation_date: Date | string
    last_message?: string | null
    last_message_date?: Date | string | null
    tables_pictures?: tables_picturesCreateNestedOneWithoutTablesInput
    tables_members?: tables_membersCreateNestedManyWithoutTablesInput
    tables_tabletops?: tables_tabletopsCreateNestedManyWithoutTablesInput
  }

  export type tablesUncheckedCreateWithoutTables_messages_logsInput = {
    table_id: string
    table_name?: string | null
    table_creation_date: Date | string
    last_message?: string | null
    last_message_date?: Date | string | null
    tables_pictures_id?: string | null
    tables_members?: tables_membersUncheckedCreateNestedManyWithoutTablesInput
    tables_tabletops?: tables_tabletopsUncheckedCreateNestedManyWithoutTablesInput
  }

  export type tablesCreateOrConnectWithoutTables_messages_logsInput = {
    where: tablesWhereUniqueInput
    create: XOR<tablesCreateWithoutTables_messages_logsInput, tablesUncheckedCreateWithoutTables_messages_logsInput>
  }

  export type entitiesUpsertWithoutTables_messages_logsInput = {
    update: XOR<entitiesUpdateWithoutTables_messages_logsInput, entitiesUncheckedUpdateWithoutTables_messages_logsInput>
    create: XOR<entitiesCreateWithoutTables_messages_logsInput, entitiesUncheckedCreateWithoutTables_messages_logsInput>
    where?: entitiesWhereInput
  }

  export type entitiesUpdateToOneWithWhereWithoutTables_messages_logsInput = {
    where?: entitiesWhereInput
    data: XOR<entitiesUpdateWithoutTables_messages_logsInput, entitiesUncheckedUpdateWithoutTables_messages_logsInput>
  }

  export type entitiesUpdateWithoutTables_messages_logsInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUpdateManyWithoutEntitiesNestedInput
    images?: imagesUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUpdateManyWithoutEntitiesNestedInput
    videos?: videosUpdateManyWithoutEntitiesNestedInput
  }

  export type entitiesUncheckedUpdateWithoutTables_messages_logsInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUncheckedUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUncheckedUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    images?: imagesUncheckedUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUncheckedUpdateManyWithoutEntitiesNestedInput
    videos?: videosUncheckedUpdateManyWithoutEntitiesNestedInput
  }

  export type tablesUpsertWithoutTables_messages_logsInput = {
    update: XOR<tablesUpdateWithoutTables_messages_logsInput, tablesUncheckedUpdateWithoutTables_messages_logsInput>
    create: XOR<tablesCreateWithoutTables_messages_logsInput, tablesUncheckedCreateWithoutTables_messages_logsInput>
    where?: tablesWhereInput
  }

  export type tablesUpdateToOneWithWhereWithoutTables_messages_logsInput = {
    where?: tablesWhereInput
    data: XOR<tablesUpdateWithoutTables_messages_logsInput, tablesUncheckedUpdateWithoutTables_messages_logsInput>
  }

  export type tablesUpdateWithoutTables_messages_logsInput = {
    table_id?: StringFieldUpdateOperationsInput | string
    table_name?: NullableStringFieldUpdateOperationsInput | string | null
    table_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tables_pictures?: tables_picturesUpdateOneWithoutTablesNestedInput
    tables_members?: tables_membersUpdateManyWithoutTablesNestedInput
    tables_tabletops?: tables_tabletopsUpdateManyWithoutTablesNestedInput
  }

  export type tablesUncheckedUpdateWithoutTables_messages_logsInput = {
    table_id?: StringFieldUpdateOperationsInput | string
    table_name?: NullableStringFieldUpdateOperationsInput | string | null
    table_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tables_pictures_id?: NullableStringFieldUpdateOperationsInput | string | null
    tables_members?: tables_membersUncheckedUpdateManyWithoutTablesNestedInput
    tables_tabletops?: tables_tabletopsUncheckedUpdateManyWithoutTablesNestedInput
  }

  export type tablesCreateWithoutTables_picturesInput = {
    table_id: string
    table_name?: string | null
    table_creation_date: Date | string
    last_message?: string | null
    last_message_date?: Date | string | null
    tables_members?: tables_membersCreateNestedManyWithoutTablesInput
    tables_messages_logs?: tables_messages_logsCreateNestedManyWithoutTablesInput
    tables_tabletops?: tables_tabletopsCreateNestedManyWithoutTablesInput
  }

  export type tablesUncheckedCreateWithoutTables_picturesInput = {
    table_id: string
    table_name?: string | null
    table_creation_date: Date | string
    last_message?: string | null
    last_message_date?: Date | string | null
    tables_members?: tables_membersUncheckedCreateNestedManyWithoutTablesInput
    tables_messages_logs?: tables_messages_logsUncheckedCreateNestedManyWithoutTablesInput
    tables_tabletops?: tables_tabletopsUncheckedCreateNestedManyWithoutTablesInput
  }

  export type tablesCreateOrConnectWithoutTables_picturesInput = {
    where: tablesWhereUniqueInput
    create: XOR<tablesCreateWithoutTables_picturesInput, tablesUncheckedCreateWithoutTables_picturesInput>
  }

  export type tablesCreateManyTables_picturesInputEnvelope = {
    data: tablesCreateManyTables_picturesInput | tablesCreateManyTables_picturesInput[]
    skipDuplicates?: boolean
  }

  export type tablesUpsertWithWhereUniqueWithoutTables_picturesInput = {
    where: tablesWhereUniqueInput
    update: XOR<tablesUpdateWithoutTables_picturesInput, tablesUncheckedUpdateWithoutTables_picturesInput>
    create: XOR<tablesCreateWithoutTables_picturesInput, tablesUncheckedCreateWithoutTables_picturesInput>
  }

  export type tablesUpdateWithWhereUniqueWithoutTables_picturesInput = {
    where: tablesWhereUniqueInput
    data: XOR<tablesUpdateWithoutTables_picturesInput, tablesUncheckedUpdateWithoutTables_picturesInput>
  }

  export type tablesUpdateManyWithWhereWithoutTables_picturesInput = {
    where: tablesScalarWhereInput
    data: XOR<tablesUpdateManyMutationInput, tablesUncheckedUpdateManyWithoutTables_picturesInput>
  }

  export type tablesScalarWhereInput = {
    AND?: tablesScalarWhereInput | tablesScalarWhereInput[]
    OR?: tablesScalarWhereInput[]
    NOT?: tablesScalarWhereInput | tablesScalarWhereInput[]
    table_id?: StringFilter<"tables"> | string
    table_name?: StringNullableFilter<"tables"> | string | null
    table_creation_date?: DateTimeFilter<"tables"> | Date | string
    last_message?: StringNullableFilter<"tables"> | string | null
    last_message_date?: DateTimeNullableFilter<"tables"> | Date | string | null
    tables_pictures_id?: StringNullableFilter<"tables"> | string | null
  }

  export type entitiesCreateWithoutTables_tabletopsInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersCreateNestedManyWithoutEntitiesInput
    images?: imagesCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsCreateNestedManyWithoutEntitiesInput
    videos?: videosCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesUncheckedCreateWithoutTables_tabletopsInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsUncheckedCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentUncheckedCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesUncheckedCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersUncheckedCreateNestedManyWithoutEntitiesInput
    images?: imagesUncheckedCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersUncheckedCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    videos?: videosUncheckedCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesCreateOrConnectWithoutTables_tabletopsInput = {
    where: entitiesWhereUniqueInput
    create: XOR<entitiesCreateWithoutTables_tabletopsInput, entitiesUncheckedCreateWithoutTables_tabletopsInput>
  }

  export type tablesCreateWithoutTables_tabletopsInput = {
    table_id: string
    table_name?: string | null
    table_creation_date: Date | string
    last_message?: string | null
    last_message_date?: Date | string | null
    tables_pictures?: tables_picturesCreateNestedOneWithoutTablesInput
    tables_members?: tables_membersCreateNestedManyWithoutTablesInput
    tables_messages_logs?: tables_messages_logsCreateNestedManyWithoutTablesInput
  }

  export type tablesUncheckedCreateWithoutTables_tabletopsInput = {
    table_id: string
    table_name?: string | null
    table_creation_date: Date | string
    last_message?: string | null
    last_message_date?: Date | string | null
    tables_pictures_id?: string | null
    tables_members?: tables_membersUncheckedCreateNestedManyWithoutTablesInput
    tables_messages_logs?: tables_messages_logsUncheckedCreateNestedManyWithoutTablesInput
  }

  export type tablesCreateOrConnectWithoutTables_tabletopsInput = {
    where: tablesWhereUniqueInput
    create: XOR<tablesCreateWithoutTables_tabletopsInput, tablesUncheckedCreateWithoutTables_tabletopsInput>
  }

  export type tables_tabletops_dataCreateWithoutTables_tabletopsInput = {
    tables_tabletops_data_id: string
    tables_tabletops_data: Buffer
  }

  export type tables_tabletops_dataUncheckedCreateWithoutTables_tabletopsInput = {
    tables_tabletops_data_id: string
    tables_tabletops_data: Buffer
  }

  export type tables_tabletops_dataCreateOrConnectWithoutTables_tabletopsInput = {
    where: tables_tabletops_dataWhereUniqueInput
    create: XOR<tables_tabletops_dataCreateWithoutTables_tabletopsInput, tables_tabletops_dataUncheckedCreateWithoutTables_tabletopsInput>
  }

  export type entitiesUpsertWithoutTables_tabletopsInput = {
    update: XOR<entitiesUpdateWithoutTables_tabletopsInput, entitiesUncheckedUpdateWithoutTables_tabletopsInput>
    create: XOR<entitiesCreateWithoutTables_tabletopsInput, entitiesUncheckedCreateWithoutTables_tabletopsInput>
    where?: entitiesWhereInput
  }

  export type entitiesUpdateToOneWithWhereWithoutTables_tabletopsInput = {
    where?: entitiesWhereInput
    data: XOR<entitiesUpdateWithoutTables_tabletopsInput, entitiesUncheckedUpdateWithoutTables_tabletopsInput>
  }

  export type entitiesUpdateWithoutTables_tabletopsInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUpdateManyWithoutEntitiesNestedInput
    images?: imagesUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUpdateManyWithoutEntitiesNestedInput
    videos?: videosUpdateManyWithoutEntitiesNestedInput
  }

  export type entitiesUncheckedUpdateWithoutTables_tabletopsInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUncheckedUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUncheckedUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    images?: imagesUncheckedUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    videos?: videosUncheckedUpdateManyWithoutEntitiesNestedInput
  }

  export type tablesUpsertWithoutTables_tabletopsInput = {
    update: XOR<tablesUpdateWithoutTables_tabletopsInput, tablesUncheckedUpdateWithoutTables_tabletopsInput>
    create: XOR<tablesCreateWithoutTables_tabletopsInput, tablesUncheckedCreateWithoutTables_tabletopsInput>
    where?: tablesWhereInput
  }

  export type tablesUpdateToOneWithWhereWithoutTables_tabletopsInput = {
    where?: tablesWhereInput
    data: XOR<tablesUpdateWithoutTables_tabletopsInput, tablesUncheckedUpdateWithoutTables_tabletopsInput>
  }

  export type tablesUpdateWithoutTables_tabletopsInput = {
    table_id?: StringFieldUpdateOperationsInput | string
    table_name?: NullableStringFieldUpdateOperationsInput | string | null
    table_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tables_pictures?: tables_picturesUpdateOneWithoutTablesNestedInput
    tables_members?: tables_membersUpdateManyWithoutTablesNestedInput
    tables_messages_logs?: tables_messages_logsUpdateManyWithoutTablesNestedInput
  }

  export type tablesUncheckedUpdateWithoutTables_tabletopsInput = {
    table_id?: StringFieldUpdateOperationsInput | string
    table_name?: NullableStringFieldUpdateOperationsInput | string | null
    table_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tables_pictures_id?: NullableStringFieldUpdateOperationsInput | string | null
    tables_members?: tables_membersUncheckedUpdateManyWithoutTablesNestedInput
    tables_messages_logs?: tables_messages_logsUncheckedUpdateManyWithoutTablesNestedInput
  }

  export type tables_tabletops_dataUpsertWithoutTables_tabletopsInput = {
    update: XOR<tables_tabletops_dataUpdateWithoutTables_tabletopsInput, tables_tabletops_dataUncheckedUpdateWithoutTables_tabletopsInput>
    create: XOR<tables_tabletops_dataCreateWithoutTables_tabletopsInput, tables_tabletops_dataUncheckedCreateWithoutTables_tabletopsInput>
    where?: tables_tabletops_dataWhereInput
  }

  export type tables_tabletops_dataUpdateToOneWithWhereWithoutTables_tabletopsInput = {
    where?: tables_tabletops_dataWhereInput
    data: XOR<tables_tabletops_dataUpdateWithoutTables_tabletopsInput, tables_tabletops_dataUncheckedUpdateWithoutTables_tabletopsInput>
  }

  export type tables_tabletops_dataUpdateWithoutTables_tabletopsInput = {
    tables_tabletops_data_id?: StringFieldUpdateOperationsInput | string
    tables_tabletops_data?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type tables_tabletops_dataUncheckedUpdateWithoutTables_tabletopsInput = {
    tables_tabletops_data_id?: StringFieldUpdateOperationsInput | string
    tables_tabletops_data?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type tables_tabletopsCreateWithoutTables_tabletops_dataInput = {
    tables_tabletops_id: string
    type: number
    content_date_posted: Date | string
    content_x_position: number
    content_y_position: number
    content_rotation: number
    content_filename?: string | null
    entities: entitiesCreateNestedOneWithoutTables_tabletopsInput
    tables: tablesCreateNestedOneWithoutTables_tabletopsInput
  }

  export type tables_tabletopsUncheckedCreateWithoutTables_tabletops_dataInput = {
    tables_tabletops_id: string
    table_id: string
    creator_id: string
    type: number
    content_date_posted: Date | string
    content_x_position: number
    content_y_position: number
    content_rotation: number
    content_filename?: string | null
  }

  export type tables_tabletopsCreateOrConnectWithoutTables_tabletops_dataInput = {
    where: tables_tabletopsWhereUniqueInput
    create: XOR<tables_tabletopsCreateWithoutTables_tabletops_dataInput, tables_tabletopsUncheckedCreateWithoutTables_tabletops_dataInput>
  }

  export type tables_tabletopsCreateManyTables_tabletops_dataInputEnvelope = {
    data: tables_tabletopsCreateManyTables_tabletops_dataInput | tables_tabletopsCreateManyTables_tabletops_dataInput[]
    skipDuplicates?: boolean
  }

  export type tables_tabletopsUpsertWithWhereUniqueWithoutTables_tabletops_dataInput = {
    where: tables_tabletopsWhereUniqueInput
    update: XOR<tables_tabletopsUpdateWithoutTables_tabletops_dataInput, tables_tabletopsUncheckedUpdateWithoutTables_tabletops_dataInput>
    create: XOR<tables_tabletopsCreateWithoutTables_tabletops_dataInput, tables_tabletopsUncheckedCreateWithoutTables_tabletops_dataInput>
  }

  export type tables_tabletopsUpdateWithWhereUniqueWithoutTables_tabletops_dataInput = {
    where: tables_tabletopsWhereUniqueInput
    data: XOR<tables_tabletopsUpdateWithoutTables_tabletops_dataInput, tables_tabletopsUncheckedUpdateWithoutTables_tabletops_dataInput>
  }

  export type tables_tabletopsUpdateManyWithWhereWithoutTables_tabletops_dataInput = {
    where: tables_tabletopsScalarWhereInput
    data: XOR<tables_tabletopsUpdateManyMutationInput, tables_tabletopsUncheckedUpdateManyWithoutTables_tabletops_dataInput>
  }

  export type individualsCreateWithoutUser_credentialsInput = {
    individual_username: string
    individual_name?: string | null
    individual_current_issue?: string | null
    individual_roles?: string | null
    individual_description?: string | null
    profile_pictures?: profile_picturesCreateNestedOneWithoutIndividualsInput
  }

  export type individualsUncheckedCreateWithoutUser_credentialsInput = {
    individual_username: string
    individual_name?: string | null
    individual_current_issue?: string | null
    individual_roles?: string | null
    individual_description?: string | null
    profile_picture_id?: string | null
  }

  export type individualsCreateOrConnectWithoutUser_credentialsInput = {
    where: individualsWhereUniqueInput
    create: XOR<individualsCreateWithoutUser_credentialsInput, individualsUncheckedCreateWithoutUser_credentialsInput>
  }

  export type individualsUpsertWithoutUser_credentialsInput = {
    update: XOR<individualsUpdateWithoutUser_credentialsInput, individualsUncheckedUpdateWithoutUser_credentialsInput>
    create: XOR<individualsCreateWithoutUser_credentialsInput, individualsUncheckedCreateWithoutUser_credentialsInput>
    where?: individualsWhereInput
  }

  export type individualsUpdateToOneWithWhereWithoutUser_credentialsInput = {
    where?: individualsWhereInput
    data: XOR<individualsUpdateWithoutUser_credentialsInput, individualsUncheckedUpdateWithoutUser_credentialsInput>
  }

  export type individualsUpdateWithoutUser_credentialsInput = {
    individual_username?: StringFieldUpdateOperationsInput | string
    individual_name?: NullableStringFieldUpdateOperationsInput | string | null
    individual_current_issue?: NullableStringFieldUpdateOperationsInput | string | null
    individual_roles?: NullableStringFieldUpdateOperationsInput | string | null
    individual_description?: NullableStringFieldUpdateOperationsInput | string | null
    profile_pictures?: profile_picturesUpdateOneWithoutIndividualsNestedInput
  }

  export type individualsUncheckedUpdateWithoutUser_credentialsInput = {
    individual_username?: StringFieldUpdateOperationsInput | string
    individual_name?: NullableStringFieldUpdateOperationsInput | string | null
    individual_current_issue?: NullableStringFieldUpdateOperationsInput | string | null
    individual_roles?: NullableStringFieldUpdateOperationsInput | string | null
    individual_description?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type entitiesCreateWithoutVideosInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersCreateNestedManyWithoutEntitiesInput
    images?: imagesCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesUncheckedCreateWithoutVideosInput = {
    entity_id: string
    entity_username: string
    entity_type?: number
    collections?: collectionsUncheckedCreateNestedManyWithoutEntitiesInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_rootToentitiesInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedCreateNestedManyWithoutEntities_contacts_contact_id_targetToentitiesInput
    conversations_members?: conversations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    conversations_messages_logs?: conversations_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    entities_content?: entities_contentUncheckedCreateNestedManyWithoutEntitiesInput
    entities_dislikes?: entities_dislikesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_likes?: entities_likesUncheckedCreateNestedManyWithoutEntitiesInput
    entities_references?: entities_referencesUncheckedCreateNestedManyWithoutEntitiesInput
    groups_members?: groups_membersUncheckedCreateNestedManyWithoutEntitiesInput
    images?: imagesUncheckedCreateNestedManyWithoutEntitiesInput
    organizations_members?: organizations_membersUncheckedCreateNestedManyWithoutEntitiesInput
    sheets?: sheetsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_members?: tables_membersUncheckedCreateNestedManyWithoutEntitiesInput
    tables_messages_logs?: tables_messages_logsUncheckedCreateNestedManyWithoutEntitiesInput
    tables_tabletops?: tables_tabletopsUncheckedCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesCreateOrConnectWithoutVideosInput = {
    where: entitiesWhereUniqueInput
    create: XOR<entitiesCreateWithoutVideosInput, entitiesUncheckedCreateWithoutVideosInput>
  }

  export type videos_dataCreateWithoutVideosInput = {
    video_data_id: string
    video_data: Buffer
  }

  export type videos_dataUncheckedCreateWithoutVideosInput = {
    video_data_id: string
    video_data: Buffer
  }

  export type videos_dataCreateOrConnectWithoutVideosInput = {
    where: videos_dataWhereUniqueInput
    create: XOR<videos_dataCreateWithoutVideosInput, videos_dataUncheckedCreateWithoutVideosInput>
  }

  export type videos_thumbnailsCreateWithoutVideosInput = {
    video_thumbnail_id: string
    video_thumbnail_data: Buffer
    video_thumbnail_filename: string
    video_thumbnail_description?: string | null
  }

  export type videos_thumbnailsUncheckedCreateWithoutVideosInput = {
    video_thumbnail_id: string
    video_thumbnail_data: Buffer
    video_thumbnail_filename: string
    video_thumbnail_description?: string | null
  }

  export type videos_thumbnailsCreateOrConnectWithoutVideosInput = {
    where: videos_thumbnailsWhereUniqueInput
    create: XOR<videos_thumbnailsCreateWithoutVideosInput, videos_thumbnailsUncheckedCreateWithoutVideosInput>
  }

  export type entitiesUpsertWithoutVideosInput = {
    update: XOR<entitiesUpdateWithoutVideosInput, entitiesUncheckedUpdateWithoutVideosInput>
    create: XOR<entitiesCreateWithoutVideosInput, entitiesUncheckedCreateWithoutVideosInput>
    where?: entitiesWhereInput
  }

  export type entitiesUpdateToOneWithWhereWithoutVideosInput = {
    where?: entitiesWhereInput
    data: XOR<entitiesUpdateWithoutVideosInput, entitiesUncheckedUpdateWithoutVideosInput>
  }

  export type entitiesUpdateWithoutVideosInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUpdateManyWithoutEntitiesNestedInput
    images?: imagesUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUpdateManyWithoutEntitiesNestedInput
  }

  export type entitiesUncheckedUpdateWithoutVideosInput = {
    entity_id?: StringFieldUpdateOperationsInput | string
    entity_username?: StringFieldUpdateOperationsInput | string
    entity_type?: IntFieldUpdateOperationsInput | number
    collections?: collectionsUncheckedUpdateManyWithoutEntitiesNestedInput
    contacts_contacts_contact_id_rootToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesNestedInput
    contacts_contacts_contact_id_targetToentities?: contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesNestedInput
    conversations_members?: conversations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    conversations_messages_logs?: conversations_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_content?: entities_contentUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_dislikes?: entities_dislikesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_likes?: entities_likesUncheckedUpdateManyWithoutEntitiesNestedInput
    entities_references?: entities_referencesUncheckedUpdateManyWithoutEntitiesNestedInput
    groups_members?: groups_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    images?: imagesUncheckedUpdateManyWithoutEntitiesNestedInput
    organizations_members?: organizations_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    sheets?: sheetsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_members?: tables_membersUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_messages_logs?: tables_messages_logsUncheckedUpdateManyWithoutEntitiesNestedInput
    tables_tabletops?: tables_tabletopsUncheckedUpdateManyWithoutEntitiesNestedInput
  }

  export type videos_dataUpsertWithoutVideosInput = {
    update: XOR<videos_dataUpdateWithoutVideosInput, videos_dataUncheckedUpdateWithoutVideosInput>
    create: XOR<videos_dataCreateWithoutVideosInput, videos_dataUncheckedCreateWithoutVideosInput>
    where?: videos_dataWhereInput
  }

  export type videos_dataUpdateToOneWithWhereWithoutVideosInput = {
    where?: videos_dataWhereInput
    data: XOR<videos_dataUpdateWithoutVideosInput, videos_dataUncheckedUpdateWithoutVideosInput>
  }

  export type videos_dataUpdateWithoutVideosInput = {
    video_data_id?: StringFieldUpdateOperationsInput | string
    video_data?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type videos_dataUncheckedUpdateWithoutVideosInput = {
    video_data_id?: StringFieldUpdateOperationsInput | string
    video_data?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type videos_thumbnailsUpsertWithoutVideosInput = {
    update: XOR<videos_thumbnailsUpdateWithoutVideosInput, videos_thumbnailsUncheckedUpdateWithoutVideosInput>
    create: XOR<videos_thumbnailsCreateWithoutVideosInput, videos_thumbnailsUncheckedCreateWithoutVideosInput>
    where?: videos_thumbnailsWhereInput
  }

  export type videos_thumbnailsUpdateToOneWithWhereWithoutVideosInput = {
    where?: videos_thumbnailsWhereInput
    data: XOR<videos_thumbnailsUpdateWithoutVideosInput, videos_thumbnailsUncheckedUpdateWithoutVideosInput>
  }

  export type videos_thumbnailsUpdateWithoutVideosInput = {
    video_thumbnail_id?: StringFieldUpdateOperationsInput | string
    video_thumbnail_data?: BytesFieldUpdateOperationsInput | Buffer
    video_thumbnail_filename?: StringFieldUpdateOperationsInput | string
    video_thumbnail_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type videos_thumbnailsUncheckedUpdateWithoutVideosInput = {
    video_thumbnail_id?: StringFieldUpdateOperationsInput | string
    video_thumbnail_data?: BytesFieldUpdateOperationsInput | Buffer
    video_thumbnail_filename?: StringFieldUpdateOperationsInput | string
    video_thumbnail_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type videosCreateWithoutVideos_dataInput = {
    video_id: string
    video_title: string
    video_description: string
    video_filename: string
    video_likes?: number
    video_dislikes?: number
    video_views?: number
    video_date_posted?: Date | string | null
    entities: entitiesCreateNestedOneWithoutVideosInput
    videos_thumbnails?: videos_thumbnailsCreateNestedOneWithoutVideosInput
  }

  export type videosUncheckedCreateWithoutVideos_dataInput = {
    video_id: string
    video_creator_id: string
    video_title: string
    video_description: string
    video_filename: string
    video_thumbnail_id?: string | null
    video_likes?: number
    video_dislikes?: number
    video_views?: number
    video_date_posted?: Date | string | null
  }

  export type videosCreateOrConnectWithoutVideos_dataInput = {
    where: videosWhereUniqueInput
    create: XOR<videosCreateWithoutVideos_dataInput, videosUncheckedCreateWithoutVideos_dataInput>
  }

  export type videosCreateManyVideos_dataInputEnvelope = {
    data: videosCreateManyVideos_dataInput | videosCreateManyVideos_dataInput[]
    skipDuplicates?: boolean
  }

  export type videosUpsertWithWhereUniqueWithoutVideos_dataInput = {
    where: videosWhereUniqueInput
    update: XOR<videosUpdateWithoutVideos_dataInput, videosUncheckedUpdateWithoutVideos_dataInput>
    create: XOR<videosCreateWithoutVideos_dataInput, videosUncheckedCreateWithoutVideos_dataInput>
  }

  export type videosUpdateWithWhereUniqueWithoutVideos_dataInput = {
    where: videosWhereUniqueInput
    data: XOR<videosUpdateWithoutVideos_dataInput, videosUncheckedUpdateWithoutVideos_dataInput>
  }

  export type videosUpdateManyWithWhereWithoutVideos_dataInput = {
    where: videosScalarWhereInput
    data: XOR<videosUpdateManyMutationInput, videosUncheckedUpdateManyWithoutVideos_dataInput>
  }

  export type videosCreateWithoutVideos_thumbnailsInput = {
    video_id: string
    video_title: string
    video_description: string
    video_filename: string
    video_likes?: number
    video_dislikes?: number
    video_views?: number
    video_date_posted?: Date | string | null
    entities: entitiesCreateNestedOneWithoutVideosInput
    videos_data: videos_dataCreateNestedOneWithoutVideosInput
  }

  export type videosUncheckedCreateWithoutVideos_thumbnailsInput = {
    video_id: string
    video_creator_id: string
    video_title: string
    video_description: string
    video_filename: string
    video_data_id: string
    video_likes?: number
    video_dislikes?: number
    video_views?: number
    video_date_posted?: Date | string | null
  }

  export type videosCreateOrConnectWithoutVideos_thumbnailsInput = {
    where: videosWhereUniqueInput
    create: XOR<videosCreateWithoutVideos_thumbnailsInput, videosUncheckedCreateWithoutVideos_thumbnailsInput>
  }

  export type videosCreateManyVideos_thumbnailsInputEnvelope = {
    data: videosCreateManyVideos_thumbnailsInput | videosCreateManyVideos_thumbnailsInput[]
    skipDuplicates?: boolean
  }

  export type videosUpsertWithWhereUniqueWithoutVideos_thumbnailsInput = {
    where: videosWhereUniqueInput
    update: XOR<videosUpdateWithoutVideos_thumbnailsInput, videosUncheckedUpdateWithoutVideos_thumbnailsInput>
    create: XOR<videosCreateWithoutVideos_thumbnailsInput, videosUncheckedCreateWithoutVideos_thumbnailsInput>
  }

  export type videosUpdateWithWhereUniqueWithoutVideos_thumbnailsInput = {
    where: videosWhereUniqueInput
    data: XOR<videosUpdateWithoutVideos_thumbnailsInput, videosUncheckedUpdateWithoutVideos_thumbnailsInput>
  }

  export type videosUpdateManyWithWhereWithoutVideos_thumbnailsInput = {
    where: videosScalarWhereInput
    data: XOR<videosUpdateManyMutationInput, videosUncheckedUpdateManyWithoutVideos_thumbnailsInput>
  }

  export type collections_contentCreateManyCollectionsInput = {
    collections_content_id: string
    content_id: string
    date_added: Date | string
    pinned: boolean
    date_pinned?: Date | string | null
  }

  export type collections_contentUpdateWithoutCollectionsInput = {
    collections_content_id?: StringFieldUpdateOperationsInput | string
    date_added?: DateTimeFieldUpdateOperationsInput | Date | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    date_pinned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: contentUpdateOneRequiredWithoutCollections_contentNestedInput
  }

  export type collections_contentUncheckedUpdateWithoutCollectionsInput = {
    collections_content_id?: StringFieldUpdateOperationsInput | string
    content_id?: StringFieldUpdateOperationsInput | string
    date_added?: DateTimeFieldUpdateOperationsInput | Date | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    date_pinned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type collections_contentUncheckedUpdateManyWithoutCollectionsInput = {
    collections_content_id?: StringFieldUpdateOperationsInput | string
    content_id?: StringFieldUpdateOperationsInput | string
    date_added?: DateTimeFieldUpdateOperationsInput | Date | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    date_pinned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contactsCreateManyContacts_picturesInput = {
    contact_id: string
    conversation_id: string
    contact_id_root: string
    contact_id_target: string
    contact_creation_date: Date | string
    last_message?: string | null
    last_contact_date?: Date | string | null
  }

  export type contactsUpdateWithoutContacts_picturesInput = {
    contact_id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
    contact_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_contact_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entities_contacts_contact_id_rootToentities?: entitiesUpdateOneRequiredWithoutContacts_contacts_contact_id_rootToentitiesNestedInput
    entities_contacts_contact_id_targetToentities?: entitiesUpdateOneRequiredWithoutContacts_contacts_contact_id_targetToentitiesNestedInput
  }

  export type contactsUncheckedUpdateWithoutContacts_picturesInput = {
    contact_id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
    contact_id_root?: StringFieldUpdateOperationsInput | string
    contact_id_target?: StringFieldUpdateOperationsInput | string
    contact_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_contact_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contactsUncheckedUpdateManyWithoutContacts_picturesInput = {
    contact_id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
    contact_id_root?: StringFieldUpdateOperationsInput | string
    contact_id_target?: StringFieldUpdateOperationsInput | string
    contact_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_contact_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type collections_contentCreateManyContentInput = {
    collections_content_id: string
    collection_id: string
    date_added: Date | string
    pinned: boolean
    date_pinned?: Date | string | null
  }

  export type entities_contentCreateManyContentInput = {
    entities_content_id: string
    entity_id: string
    date_added: Date | string
    pinned: boolean
    date_pinned?: Date | string | null
  }

  export type entities_dislikesCreateManyContentInput = {
    dislike_id: string
    entity_id: string
  }

  export type entities_likesCreateManyContentInput = {
    like_id: string
    entity_id: string
  }

  export type collections_contentUpdateWithoutContentInput = {
    collections_content_id?: StringFieldUpdateOperationsInput | string
    date_added?: DateTimeFieldUpdateOperationsInput | Date | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    date_pinned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collections?: collectionsUpdateOneRequiredWithoutCollections_contentNestedInput
  }

  export type collections_contentUncheckedUpdateWithoutContentInput = {
    collections_content_id?: StringFieldUpdateOperationsInput | string
    collection_id?: StringFieldUpdateOperationsInput | string
    date_added?: DateTimeFieldUpdateOperationsInput | Date | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    date_pinned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type collections_contentUncheckedUpdateManyWithoutContentInput = {
    collections_content_id?: StringFieldUpdateOperationsInput | string
    collection_id?: StringFieldUpdateOperationsInput | string
    date_added?: DateTimeFieldUpdateOperationsInput | Date | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    date_pinned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type entities_contentUpdateWithoutContentInput = {
    entities_content_id?: StringFieldUpdateOperationsInput | string
    date_added?: DateTimeFieldUpdateOperationsInput | Date | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    date_pinned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entities?: entitiesUpdateOneRequiredWithoutEntities_contentNestedInput
  }

  export type entities_contentUncheckedUpdateWithoutContentInput = {
    entities_content_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    date_added?: DateTimeFieldUpdateOperationsInput | Date | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    date_pinned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type entities_contentUncheckedUpdateManyWithoutContentInput = {
    entities_content_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    date_added?: DateTimeFieldUpdateOperationsInput | Date | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    date_pinned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type entities_dislikesUpdateWithoutContentInput = {
    dislike_id?: StringFieldUpdateOperationsInput | string
    entities?: entitiesUpdateOneRequiredWithoutEntities_dislikesNestedInput
  }

  export type entities_dislikesUncheckedUpdateWithoutContentInput = {
    dislike_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
  }

  export type entities_dislikesUncheckedUpdateManyWithoutContentInput = {
    dislike_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
  }

  export type entities_likesUpdateWithoutContentInput = {
    like_id?: StringFieldUpdateOperationsInput | string
    entities?: entitiesUpdateOneRequiredWithoutEntities_likesNestedInput
  }

  export type entities_likesUncheckedUpdateWithoutContentInput = {
    like_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
  }

  export type entities_likesUncheckedUpdateManyWithoutContentInput = {
    like_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
  }

  export type conversations_membersCreateManyConversationsInput = {
    conversations_members_id: string
    member_id: string
  }

  export type conversations_messages_logsCreateManyConversationsInput = {
    conversations_messages_logs_id: string
    entity_id: string
    message: string
    message_date: Date | string
  }

  export type conversations_membersUpdateWithoutConversationsInput = {
    conversations_members_id?: StringFieldUpdateOperationsInput | string
    entities?: entitiesUpdateOneRequiredWithoutConversations_membersNestedInput
  }

  export type conversations_membersUncheckedUpdateWithoutConversationsInput = {
    conversations_members_id?: StringFieldUpdateOperationsInput | string
    member_id?: StringFieldUpdateOperationsInput | string
  }

  export type conversations_membersUncheckedUpdateManyWithoutConversationsInput = {
    conversations_members_id?: StringFieldUpdateOperationsInput | string
    member_id?: StringFieldUpdateOperationsInput | string
  }

  export type conversations_messages_logsUpdateWithoutConversationsInput = {
    conversations_messages_logs_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    message_date?: DateTimeFieldUpdateOperationsInput | Date | string
    entities?: entitiesUpdateOneRequiredWithoutConversations_messages_logsNestedInput
  }

  export type conversations_messages_logsUncheckedUpdateWithoutConversationsInput = {
    conversations_messages_logs_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    message_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type conversations_messages_logsUncheckedUpdateManyWithoutConversationsInput = {
    conversations_messages_logs_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    message_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type conversationsCreateManyConversations_picturesInput = {
    conversation_id: string
    conversation_name?: string | null
    conversation_creation_date: Date | string
    last_message?: string | null
    last_message_date?: Date | string | null
  }

  export type conversationsUpdateWithoutConversations_picturesInput = {
    conversation_id?: StringFieldUpdateOperationsInput | string
    conversation_name?: NullableStringFieldUpdateOperationsInput | string | null
    conversation_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations_members?: conversations_membersUpdateManyWithoutConversationsNestedInput
    conversations_messages_logs?: conversations_messages_logsUpdateManyWithoutConversationsNestedInput
  }

  export type conversationsUncheckedUpdateWithoutConversations_picturesInput = {
    conversation_id?: StringFieldUpdateOperationsInput | string
    conversation_name?: NullableStringFieldUpdateOperationsInput | string | null
    conversation_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversations_members?: conversations_membersUncheckedUpdateManyWithoutConversationsNestedInput
    conversations_messages_logs?: conversations_messages_logsUncheckedUpdateManyWithoutConversationsNestedInput
  }

  export type conversationsUncheckedUpdateManyWithoutConversations_picturesInput = {
    conversation_id?: StringFieldUpdateOperationsInput | string
    conversation_name?: NullableStringFieldUpdateOperationsInput | string | null
    conversation_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type collectionsCreateManyEntitiesInput = {
    collection_id: string
    collection_name: string
  }

  export type contactsCreateManyEntities_contacts_contact_id_rootToentitiesInput = {
    contact_id: string
    conversation_id: string
    contact_id_target: string
    contact_creation_date: Date | string
    last_message?: string | null
    last_contact_date?: Date | string | null
    contacts_pictures_id?: string | null
  }

  export type contactsCreateManyEntities_contacts_contact_id_targetToentitiesInput = {
    contact_id: string
    conversation_id: string
    contact_id_root: string
    contact_creation_date: Date | string
    last_message?: string | null
    last_contact_date?: Date | string | null
    contacts_pictures_id?: string | null
  }

  export type conversations_membersCreateManyEntitiesInput = {
    conversations_members_id: string
    conversation_id: string
  }

  export type conversations_messages_logsCreateManyEntitiesInput = {
    conversations_messages_logs_id: string
    conversation_id: string
    message: string
    message_date: Date | string
  }

  export type entities_contentCreateManyEntitiesInput = {
    entities_content_id: string
    content_id: string
    date_added: Date | string
    pinned: boolean
    date_pinned?: Date | string | null
  }

  export type entities_dislikesCreateManyEntitiesInput = {
    dislike_id: string
    content_id: string
  }

  export type entities_likesCreateManyEntitiesInput = {
    like_id: string
    content_id: string
  }

  export type entities_referencesCreateManyEntitiesInput = {
    reference_id: string
    title: string
    author: string
    url: string
  }

  export type groups_membersCreateManyEntitiesInput = {
    groups_members_id: string
    group_id: string
  }

  export type imagesCreateManyEntitiesInput = {
    image_id: string
    image_title: string
    image_description: string
    image_filename: string
    image_data_id: string
    image_likes?: number
    image_dislikes?: number
    image_views?: number
    image_date_posted?: Date | string
  }

  export type organizations_membersCreateManyEntitiesInput = {
    organizations_members_id: string
    organization_id: string
  }

  export type sheetsCreateManyEntitiesInput = {
    sheet_id: string
    sheet_title: string
    sheet_subject: string
    sheet_filename: string
    sheet_data_id: string
    sheet_thumbnail_id?: string | null
    sheet_likes?: number
    sheet_dislikes?: number
    sheet_views?: number
    sheet_date_posted?: Date | string
  }

  export type tables_membersCreateManyEntitiesInput = {
    tables_members_id: string
    table_id: string
    table_position: number
    live?: number
  }

  export type tables_messages_logsCreateManyEntitiesInput = {
    tables_messages_logs_id: string
    table_id: string
    message: string
    message_date: Date | string
  }

  export type tables_tabletopsCreateManyEntitiesInput = {
    tables_tabletops_id: string
    table_id: string
    tables_tabletops_data_id?: string | null
    type: number
    content_date_posted: Date | string
    content_x_position: number
    content_y_position: number
    content_rotation: number
    content_filename?: string | null
  }

  export type videosCreateManyEntitiesInput = {
    video_id: string
    video_title: string
    video_description: string
    video_filename: string
    video_data_id: string
    video_thumbnail_id?: string | null
    video_likes?: number
    video_dislikes?: number
    video_views?: number
    video_date_posted?: Date | string | null
  }

  export type collectionsUpdateWithoutEntitiesInput = {
    collection_id?: StringFieldUpdateOperationsInput | string
    collection_name?: StringFieldUpdateOperationsInput | string
    collections_content?: collections_contentUpdateManyWithoutCollectionsNestedInput
  }

  export type collectionsUncheckedUpdateWithoutEntitiesInput = {
    collection_id?: StringFieldUpdateOperationsInput | string
    collection_name?: StringFieldUpdateOperationsInput | string
    collections_content?: collections_contentUncheckedUpdateManyWithoutCollectionsNestedInput
  }

  export type collectionsUncheckedUpdateManyWithoutEntitiesInput = {
    collection_id?: StringFieldUpdateOperationsInput | string
    collection_name?: StringFieldUpdateOperationsInput | string
  }

  export type contactsUpdateWithoutEntities_contacts_contact_id_rootToentitiesInput = {
    contact_id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
    contact_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_contact_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entities_contacts_contact_id_targetToentities?: entitiesUpdateOneRequiredWithoutContacts_contacts_contact_id_targetToentitiesNestedInput
    contacts_pictures?: contacts_picturesUpdateOneWithoutContactsNestedInput
  }

  export type contactsUncheckedUpdateWithoutEntities_contacts_contact_id_rootToentitiesInput = {
    contact_id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
    contact_id_target?: StringFieldUpdateOperationsInput | string
    contact_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_contact_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contacts_pictures_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_rootToentitiesInput = {
    contact_id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
    contact_id_target?: StringFieldUpdateOperationsInput | string
    contact_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_contact_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contacts_pictures_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contactsUpdateWithoutEntities_contacts_contact_id_targetToentitiesInput = {
    contact_id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
    contact_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_contact_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entities_contacts_contact_id_rootToentities?: entitiesUpdateOneRequiredWithoutContacts_contacts_contact_id_rootToentitiesNestedInput
    contacts_pictures?: contacts_picturesUpdateOneWithoutContactsNestedInput
  }

  export type contactsUncheckedUpdateWithoutEntities_contacts_contact_id_targetToentitiesInput = {
    contact_id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
    contact_id_root?: StringFieldUpdateOperationsInput | string
    contact_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_contact_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contacts_pictures_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contactsUncheckedUpdateManyWithoutEntities_contacts_contact_id_targetToentitiesInput = {
    contact_id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
    contact_id_root?: StringFieldUpdateOperationsInput | string
    contact_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_contact_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contacts_pictures_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type conversations_membersUpdateWithoutEntitiesInput = {
    conversations_members_id?: StringFieldUpdateOperationsInput | string
    conversations?: conversationsUpdateOneRequiredWithoutConversations_membersNestedInput
  }

  export type conversations_membersUncheckedUpdateWithoutEntitiesInput = {
    conversations_members_id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
  }

  export type conversations_membersUncheckedUpdateManyWithoutEntitiesInput = {
    conversations_members_id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
  }

  export type conversations_messages_logsUpdateWithoutEntitiesInput = {
    conversations_messages_logs_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    message_date?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: conversationsUpdateOneRequiredWithoutConversations_messages_logsNestedInput
  }

  export type conversations_messages_logsUncheckedUpdateWithoutEntitiesInput = {
    conversations_messages_logs_id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    message_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type conversations_messages_logsUncheckedUpdateManyWithoutEntitiesInput = {
    conversations_messages_logs_id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    message_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type entities_contentUpdateWithoutEntitiesInput = {
    entities_content_id?: StringFieldUpdateOperationsInput | string
    date_added?: DateTimeFieldUpdateOperationsInput | Date | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    date_pinned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: contentUpdateOneRequiredWithoutEntities_contentNestedInput
  }

  export type entities_contentUncheckedUpdateWithoutEntitiesInput = {
    entities_content_id?: StringFieldUpdateOperationsInput | string
    content_id?: StringFieldUpdateOperationsInput | string
    date_added?: DateTimeFieldUpdateOperationsInput | Date | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    date_pinned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type entities_contentUncheckedUpdateManyWithoutEntitiesInput = {
    entities_content_id?: StringFieldUpdateOperationsInput | string
    content_id?: StringFieldUpdateOperationsInput | string
    date_added?: DateTimeFieldUpdateOperationsInput | Date | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    date_pinned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type entities_dislikesUpdateWithoutEntitiesInput = {
    dislike_id?: StringFieldUpdateOperationsInput | string
    content?: contentUpdateOneRequiredWithoutEntities_dislikesNestedInput
  }

  export type entities_dislikesUncheckedUpdateWithoutEntitiesInput = {
    dislike_id?: StringFieldUpdateOperationsInput | string
    content_id?: StringFieldUpdateOperationsInput | string
  }

  export type entities_dislikesUncheckedUpdateManyWithoutEntitiesInput = {
    dislike_id?: StringFieldUpdateOperationsInput | string
    content_id?: StringFieldUpdateOperationsInput | string
  }

  export type entities_likesUpdateWithoutEntitiesInput = {
    like_id?: StringFieldUpdateOperationsInput | string
    content?: contentUpdateOneRequiredWithoutEntities_likesNestedInput
  }

  export type entities_likesUncheckedUpdateWithoutEntitiesInput = {
    like_id?: StringFieldUpdateOperationsInput | string
    content_id?: StringFieldUpdateOperationsInput | string
  }

  export type entities_likesUncheckedUpdateManyWithoutEntitiesInput = {
    like_id?: StringFieldUpdateOperationsInput | string
    content_id?: StringFieldUpdateOperationsInput | string
  }

  export type entities_referencesUpdateWithoutEntitiesInput = {
    reference_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type entities_referencesUncheckedUpdateWithoutEntitiesInput = {
    reference_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type entities_referencesUncheckedUpdateManyWithoutEntitiesInput = {
    reference_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type groups_membersUpdateWithoutEntitiesInput = {
    groups_members_id?: StringFieldUpdateOperationsInput | string
    groups?: groupsUpdateOneRequiredWithoutGroups_membersNestedInput
  }

  export type groups_membersUncheckedUpdateWithoutEntitiesInput = {
    groups_members_id?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
  }

  export type groups_membersUncheckedUpdateManyWithoutEntitiesInput = {
    groups_members_id?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
  }

  export type imagesUpdateWithoutEntitiesInput = {
    image_id?: StringFieldUpdateOperationsInput | string
    image_title?: StringFieldUpdateOperationsInput | string
    image_description?: StringFieldUpdateOperationsInput | string
    image_filename?: StringFieldUpdateOperationsInput | string
    image_likes?: IntFieldUpdateOperationsInput | number
    image_dislikes?: IntFieldUpdateOperationsInput | number
    image_views?: IntFieldUpdateOperationsInput | number
    image_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
    images_data?: images_dataUpdateOneRequiredWithoutImagesNestedInput
  }

  export type imagesUncheckedUpdateWithoutEntitiesInput = {
    image_id?: StringFieldUpdateOperationsInput | string
    image_title?: StringFieldUpdateOperationsInput | string
    image_description?: StringFieldUpdateOperationsInput | string
    image_filename?: StringFieldUpdateOperationsInput | string
    image_data_id?: StringFieldUpdateOperationsInput | string
    image_likes?: IntFieldUpdateOperationsInput | number
    image_dislikes?: IntFieldUpdateOperationsInput | number
    image_views?: IntFieldUpdateOperationsInput | number
    image_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type imagesUncheckedUpdateManyWithoutEntitiesInput = {
    image_id?: StringFieldUpdateOperationsInput | string
    image_title?: StringFieldUpdateOperationsInput | string
    image_description?: StringFieldUpdateOperationsInput | string
    image_filename?: StringFieldUpdateOperationsInput | string
    image_data_id?: StringFieldUpdateOperationsInput | string
    image_likes?: IntFieldUpdateOperationsInput | number
    image_dislikes?: IntFieldUpdateOperationsInput | number
    image_views?: IntFieldUpdateOperationsInput | number
    image_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type organizations_membersUpdateWithoutEntitiesInput = {
    organizations_members_id?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutOrganizations_membersNestedInput
  }

  export type organizations_membersUncheckedUpdateWithoutEntitiesInput = {
    organizations_members_id?: StringFieldUpdateOperationsInput | string
    organization_id?: StringFieldUpdateOperationsInput | string
  }

  export type organizations_membersUncheckedUpdateManyWithoutEntitiesInput = {
    organizations_members_id?: StringFieldUpdateOperationsInput | string
    organization_id?: StringFieldUpdateOperationsInput | string
  }

  export type sheetsUpdateWithoutEntitiesInput = {
    sheet_id?: StringFieldUpdateOperationsInput | string
    sheet_title?: StringFieldUpdateOperationsInput | string
    sheet_subject?: StringFieldUpdateOperationsInput | string
    sheet_filename?: StringFieldUpdateOperationsInput | string
    sheet_likes?: IntFieldUpdateOperationsInput | number
    sheet_dislikes?: IntFieldUpdateOperationsInput | number
    sheet_views?: IntFieldUpdateOperationsInput | number
    sheet_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
    sheets_data?: sheets_dataUpdateOneRequiredWithoutSheetsNestedInput
    sheets_thumbnails?: sheets_thumbnailsUpdateOneWithoutSheetsNestedInput
  }

  export type sheetsUncheckedUpdateWithoutEntitiesInput = {
    sheet_id?: StringFieldUpdateOperationsInput | string
    sheet_title?: StringFieldUpdateOperationsInput | string
    sheet_subject?: StringFieldUpdateOperationsInput | string
    sheet_filename?: StringFieldUpdateOperationsInput | string
    sheet_data_id?: StringFieldUpdateOperationsInput | string
    sheet_thumbnail_id?: NullableStringFieldUpdateOperationsInput | string | null
    sheet_likes?: IntFieldUpdateOperationsInput | number
    sheet_dislikes?: IntFieldUpdateOperationsInput | number
    sheet_views?: IntFieldUpdateOperationsInput | number
    sheet_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sheetsUncheckedUpdateManyWithoutEntitiesInput = {
    sheet_id?: StringFieldUpdateOperationsInput | string
    sheet_title?: StringFieldUpdateOperationsInput | string
    sheet_subject?: StringFieldUpdateOperationsInput | string
    sheet_filename?: StringFieldUpdateOperationsInput | string
    sheet_data_id?: StringFieldUpdateOperationsInput | string
    sheet_thumbnail_id?: NullableStringFieldUpdateOperationsInput | string | null
    sheet_likes?: IntFieldUpdateOperationsInput | number
    sheet_dislikes?: IntFieldUpdateOperationsInput | number
    sheet_views?: IntFieldUpdateOperationsInput | number
    sheet_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tables_membersUpdateWithoutEntitiesInput = {
    tables_members_id?: StringFieldUpdateOperationsInput | string
    table_position?: IntFieldUpdateOperationsInput | number
    live?: IntFieldUpdateOperationsInput | number
    tables?: tablesUpdateOneRequiredWithoutTables_membersNestedInput
  }

  export type tables_membersUncheckedUpdateWithoutEntitiesInput = {
    tables_members_id?: StringFieldUpdateOperationsInput | string
    table_id?: StringFieldUpdateOperationsInput | string
    table_position?: IntFieldUpdateOperationsInput | number
    live?: IntFieldUpdateOperationsInput | number
  }

  export type tables_membersUncheckedUpdateManyWithoutEntitiesInput = {
    tables_members_id?: StringFieldUpdateOperationsInput | string
    table_id?: StringFieldUpdateOperationsInput | string
    table_position?: IntFieldUpdateOperationsInput | number
    live?: IntFieldUpdateOperationsInput | number
  }

  export type tables_messages_logsUpdateWithoutEntitiesInput = {
    tables_messages_logs_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    message_date?: DateTimeFieldUpdateOperationsInput | Date | string
    tables?: tablesUpdateOneRequiredWithoutTables_messages_logsNestedInput
  }

  export type tables_messages_logsUncheckedUpdateWithoutEntitiesInput = {
    tables_messages_logs_id?: StringFieldUpdateOperationsInput | string
    table_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    message_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tables_messages_logsUncheckedUpdateManyWithoutEntitiesInput = {
    tables_messages_logs_id?: StringFieldUpdateOperationsInput | string
    table_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    message_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tables_tabletopsUpdateWithoutEntitiesInput = {
    tables_tabletops_id?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    content_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
    content_x_position?: IntFieldUpdateOperationsInput | number
    content_y_position?: IntFieldUpdateOperationsInput | number
    content_rotation?: IntFieldUpdateOperationsInput | number
    content_filename?: NullableStringFieldUpdateOperationsInput | string | null
    tables?: tablesUpdateOneRequiredWithoutTables_tabletopsNestedInput
    tables_tabletops_data?: tables_tabletops_dataUpdateOneWithoutTables_tabletopsNestedInput
  }

  export type tables_tabletopsUncheckedUpdateWithoutEntitiesInput = {
    tables_tabletops_id?: StringFieldUpdateOperationsInput | string
    table_id?: StringFieldUpdateOperationsInput | string
    tables_tabletops_data_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    content_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
    content_x_position?: IntFieldUpdateOperationsInput | number
    content_y_position?: IntFieldUpdateOperationsInput | number
    content_rotation?: IntFieldUpdateOperationsInput | number
    content_filename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tables_tabletopsUncheckedUpdateManyWithoutEntitiesInput = {
    tables_tabletops_id?: StringFieldUpdateOperationsInput | string
    table_id?: StringFieldUpdateOperationsInput | string
    tables_tabletops_data_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    content_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
    content_x_position?: IntFieldUpdateOperationsInput | number
    content_y_position?: IntFieldUpdateOperationsInput | number
    content_rotation?: IntFieldUpdateOperationsInput | number
    content_filename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type videosUpdateWithoutEntitiesInput = {
    video_id?: StringFieldUpdateOperationsInput | string
    video_title?: StringFieldUpdateOperationsInput | string
    video_description?: StringFieldUpdateOperationsInput | string
    video_filename?: StringFieldUpdateOperationsInput | string
    video_likes?: IntFieldUpdateOperationsInput | number
    video_dislikes?: IntFieldUpdateOperationsInput | number
    video_views?: IntFieldUpdateOperationsInput | number
    video_date_posted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    videos_data?: videos_dataUpdateOneRequiredWithoutVideosNestedInput
    videos_thumbnails?: videos_thumbnailsUpdateOneWithoutVideosNestedInput
  }

  export type videosUncheckedUpdateWithoutEntitiesInput = {
    video_id?: StringFieldUpdateOperationsInput | string
    video_title?: StringFieldUpdateOperationsInput | string
    video_description?: StringFieldUpdateOperationsInput | string
    video_filename?: StringFieldUpdateOperationsInput | string
    video_data_id?: StringFieldUpdateOperationsInput | string
    video_thumbnail_id?: NullableStringFieldUpdateOperationsInput | string | null
    video_likes?: IntFieldUpdateOperationsInput | number
    video_dislikes?: IntFieldUpdateOperationsInput | number
    video_views?: IntFieldUpdateOperationsInput | number
    video_date_posted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type videosUncheckedUpdateManyWithoutEntitiesInput = {
    video_id?: StringFieldUpdateOperationsInput | string
    video_title?: StringFieldUpdateOperationsInput | string
    video_description?: StringFieldUpdateOperationsInput | string
    video_filename?: StringFieldUpdateOperationsInput | string
    video_data_id?: StringFieldUpdateOperationsInput | string
    video_thumbnail_id?: NullableStringFieldUpdateOperationsInput | string | null
    video_likes?: IntFieldUpdateOperationsInput | number
    video_dislikes?: IntFieldUpdateOperationsInput | number
    video_views?: IntFieldUpdateOperationsInput | number
    video_date_posted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type groups_membersCreateManyGroupsInput = {
    groups_members_id: string
    entity_id: string
  }

  export type groups_membersUpdateWithoutGroupsInput = {
    groups_members_id?: StringFieldUpdateOperationsInput | string
    entities?: entitiesUpdateOneRequiredWithoutGroups_membersNestedInput
  }

  export type groups_membersUncheckedUpdateWithoutGroupsInput = {
    groups_members_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
  }

  export type groups_membersUncheckedUpdateManyWithoutGroupsInput = {
    groups_members_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
  }

  export type imagesCreateManyImages_dataInput = {
    image_id: string
    image_creator_id: string
    image_title: string
    image_description: string
    image_filename: string
    image_likes?: number
    image_dislikes?: number
    image_views?: number
    image_date_posted?: Date | string
  }

  export type imagesUpdateWithoutImages_dataInput = {
    image_id?: StringFieldUpdateOperationsInput | string
    image_title?: StringFieldUpdateOperationsInput | string
    image_description?: StringFieldUpdateOperationsInput | string
    image_filename?: StringFieldUpdateOperationsInput | string
    image_likes?: IntFieldUpdateOperationsInput | number
    image_dislikes?: IntFieldUpdateOperationsInput | number
    image_views?: IntFieldUpdateOperationsInput | number
    image_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
    entities?: entitiesUpdateOneRequiredWithoutImagesNestedInput
  }

  export type imagesUncheckedUpdateWithoutImages_dataInput = {
    image_id?: StringFieldUpdateOperationsInput | string
    image_creator_id?: StringFieldUpdateOperationsInput | string
    image_title?: StringFieldUpdateOperationsInput | string
    image_description?: StringFieldUpdateOperationsInput | string
    image_filename?: StringFieldUpdateOperationsInput | string
    image_likes?: IntFieldUpdateOperationsInput | number
    image_dislikes?: IntFieldUpdateOperationsInput | number
    image_views?: IntFieldUpdateOperationsInput | number
    image_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type imagesUncheckedUpdateManyWithoutImages_dataInput = {
    image_id?: StringFieldUpdateOperationsInput | string
    image_creator_id?: StringFieldUpdateOperationsInput | string
    image_title?: StringFieldUpdateOperationsInput | string
    image_description?: StringFieldUpdateOperationsInput | string
    image_filename?: StringFieldUpdateOperationsInput | string
    image_likes?: IntFieldUpdateOperationsInput | number
    image_dislikes?: IntFieldUpdateOperationsInput | number
    image_views?: IntFieldUpdateOperationsInput | number
    image_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type organizations_membersCreateManyOrganizationsInput = {
    organizations_members_id: string
    entity_id: string
  }

  export type organizations_membersUpdateWithoutOrganizationsInput = {
    organizations_members_id?: StringFieldUpdateOperationsInput | string
    entities?: entitiesUpdateOneRequiredWithoutOrganizations_membersNestedInput
  }

  export type organizations_membersUncheckedUpdateWithoutOrganizationsInput = {
    organizations_members_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
  }

  export type organizations_membersUncheckedUpdateManyWithoutOrganizationsInput = {
    organizations_members_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
  }

  export type groupsCreateManyProfile_picturesInput = {
    group_id: string
    group_handle: string
    group_name?: string | null
    group_current_issue?: string | null
    group_stances?: string | null
    group_description?: string | null
  }

  export type individualsCreateManyProfile_picturesInput = {
    individual_id: string
    individual_username: string
    individual_name?: string | null
    individual_current_issue?: string | null
    individual_roles?: string | null
    individual_description?: string | null
  }

  export type organizationsCreateManyProfile_picturesInput = {
    organization_id: string
    organization_handle: string
    organization_name?: string | null
    organization_current_issue?: string | null
    organization_stances?: string | null
    organization_description?: string | null
  }

  export type groupsUpdateWithoutProfile_picturesInput = {
    group_id?: StringFieldUpdateOperationsInput | string
    group_handle?: StringFieldUpdateOperationsInput | string
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    group_current_issue?: NullableStringFieldUpdateOperationsInput | string | null
    group_stances?: NullableStringFieldUpdateOperationsInput | string | null
    group_description?: NullableStringFieldUpdateOperationsInput | string | null
    groups_members?: groups_membersUpdateManyWithoutGroupsNestedInput
  }

  export type groupsUncheckedUpdateWithoutProfile_picturesInput = {
    group_id?: StringFieldUpdateOperationsInput | string
    group_handle?: StringFieldUpdateOperationsInput | string
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    group_current_issue?: NullableStringFieldUpdateOperationsInput | string | null
    group_stances?: NullableStringFieldUpdateOperationsInput | string | null
    group_description?: NullableStringFieldUpdateOperationsInput | string | null
    groups_members?: groups_membersUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type groupsUncheckedUpdateManyWithoutProfile_picturesInput = {
    group_id?: StringFieldUpdateOperationsInput | string
    group_handle?: StringFieldUpdateOperationsInput | string
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    group_current_issue?: NullableStringFieldUpdateOperationsInput | string | null
    group_stances?: NullableStringFieldUpdateOperationsInput | string | null
    group_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type individualsUpdateWithoutProfile_picturesInput = {
    individual_username?: StringFieldUpdateOperationsInput | string
    individual_name?: NullableStringFieldUpdateOperationsInput | string | null
    individual_current_issue?: NullableStringFieldUpdateOperationsInput | string | null
    individual_roles?: NullableStringFieldUpdateOperationsInput | string | null
    individual_description?: NullableStringFieldUpdateOperationsInput | string | null
    user_credentials?: user_credentialsUpdateOneRequiredWithoutIndividualsNestedInput
  }

  export type individualsUncheckedUpdateWithoutProfile_picturesInput = {
    individual_id?: StringFieldUpdateOperationsInput | string
    individual_username?: StringFieldUpdateOperationsInput | string
    individual_name?: NullableStringFieldUpdateOperationsInput | string | null
    individual_current_issue?: NullableStringFieldUpdateOperationsInput | string | null
    individual_roles?: NullableStringFieldUpdateOperationsInput | string | null
    individual_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type individualsUncheckedUpdateManyWithoutProfile_picturesInput = {
    individual_id?: StringFieldUpdateOperationsInput | string
    individual_username?: StringFieldUpdateOperationsInput | string
    individual_name?: NullableStringFieldUpdateOperationsInput | string | null
    individual_current_issue?: NullableStringFieldUpdateOperationsInput | string | null
    individual_roles?: NullableStringFieldUpdateOperationsInput | string | null
    individual_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type organizationsUpdateWithoutProfile_picturesInput = {
    organization_id?: StringFieldUpdateOperationsInput | string
    organization_handle?: StringFieldUpdateOperationsInput | string
    organization_name?: NullableStringFieldUpdateOperationsInput | string | null
    organization_current_issue?: NullableStringFieldUpdateOperationsInput | string | null
    organization_stances?: NullableStringFieldUpdateOperationsInput | string | null
    organization_description?: NullableStringFieldUpdateOperationsInput | string | null
    organizations_members?: organizations_membersUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateWithoutProfile_picturesInput = {
    organization_id?: StringFieldUpdateOperationsInput | string
    organization_handle?: StringFieldUpdateOperationsInput | string
    organization_name?: NullableStringFieldUpdateOperationsInput | string | null
    organization_current_issue?: NullableStringFieldUpdateOperationsInput | string | null
    organization_stances?: NullableStringFieldUpdateOperationsInput | string | null
    organization_description?: NullableStringFieldUpdateOperationsInput | string | null
    organizations_members?: organizations_membersUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateManyWithoutProfile_picturesInput = {
    organization_id?: StringFieldUpdateOperationsInput | string
    organization_handle?: StringFieldUpdateOperationsInput | string
    organization_name?: NullableStringFieldUpdateOperationsInput | string | null
    organization_current_issue?: NullableStringFieldUpdateOperationsInput | string | null
    organization_stances?: NullableStringFieldUpdateOperationsInput | string | null
    organization_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sheetsCreateManySheets_dataInput = {
    sheet_id: string
    sheet_author_id: string
    sheet_title: string
    sheet_subject: string
    sheet_filename: string
    sheet_thumbnail_id?: string | null
    sheet_likes?: number
    sheet_dislikes?: number
    sheet_views?: number
    sheet_date_posted?: Date | string
  }

  export type sheetsUpdateWithoutSheets_dataInput = {
    sheet_id?: StringFieldUpdateOperationsInput | string
    sheet_title?: StringFieldUpdateOperationsInput | string
    sheet_subject?: StringFieldUpdateOperationsInput | string
    sheet_filename?: StringFieldUpdateOperationsInput | string
    sheet_likes?: IntFieldUpdateOperationsInput | number
    sheet_dislikes?: IntFieldUpdateOperationsInput | number
    sheet_views?: IntFieldUpdateOperationsInput | number
    sheet_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
    entities?: entitiesUpdateOneRequiredWithoutSheetsNestedInput
    sheets_thumbnails?: sheets_thumbnailsUpdateOneWithoutSheetsNestedInput
  }

  export type sheetsUncheckedUpdateWithoutSheets_dataInput = {
    sheet_id?: StringFieldUpdateOperationsInput | string
    sheet_author_id?: StringFieldUpdateOperationsInput | string
    sheet_title?: StringFieldUpdateOperationsInput | string
    sheet_subject?: StringFieldUpdateOperationsInput | string
    sheet_filename?: StringFieldUpdateOperationsInput | string
    sheet_thumbnail_id?: NullableStringFieldUpdateOperationsInput | string | null
    sheet_likes?: IntFieldUpdateOperationsInput | number
    sheet_dislikes?: IntFieldUpdateOperationsInput | number
    sheet_views?: IntFieldUpdateOperationsInput | number
    sheet_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sheetsUncheckedUpdateManyWithoutSheets_dataInput = {
    sheet_id?: StringFieldUpdateOperationsInput | string
    sheet_author_id?: StringFieldUpdateOperationsInput | string
    sheet_title?: StringFieldUpdateOperationsInput | string
    sheet_subject?: StringFieldUpdateOperationsInput | string
    sheet_filename?: StringFieldUpdateOperationsInput | string
    sheet_thumbnail_id?: NullableStringFieldUpdateOperationsInput | string | null
    sheet_likes?: IntFieldUpdateOperationsInput | number
    sheet_dislikes?: IntFieldUpdateOperationsInput | number
    sheet_views?: IntFieldUpdateOperationsInput | number
    sheet_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sheetsCreateManySheets_thumbnailsInput = {
    sheet_id: string
    sheet_author_id: string
    sheet_title: string
    sheet_subject: string
    sheet_filename: string
    sheet_data_id: string
    sheet_likes?: number
    sheet_dislikes?: number
    sheet_views?: number
    sheet_date_posted?: Date | string
  }

  export type sheetsUpdateWithoutSheets_thumbnailsInput = {
    sheet_id?: StringFieldUpdateOperationsInput | string
    sheet_title?: StringFieldUpdateOperationsInput | string
    sheet_subject?: StringFieldUpdateOperationsInput | string
    sheet_filename?: StringFieldUpdateOperationsInput | string
    sheet_likes?: IntFieldUpdateOperationsInput | number
    sheet_dislikes?: IntFieldUpdateOperationsInput | number
    sheet_views?: IntFieldUpdateOperationsInput | number
    sheet_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
    entities?: entitiesUpdateOneRequiredWithoutSheetsNestedInput
    sheets_data?: sheets_dataUpdateOneRequiredWithoutSheetsNestedInput
  }

  export type sheetsUncheckedUpdateWithoutSheets_thumbnailsInput = {
    sheet_id?: StringFieldUpdateOperationsInput | string
    sheet_author_id?: StringFieldUpdateOperationsInput | string
    sheet_title?: StringFieldUpdateOperationsInput | string
    sheet_subject?: StringFieldUpdateOperationsInput | string
    sheet_filename?: StringFieldUpdateOperationsInput | string
    sheet_data_id?: StringFieldUpdateOperationsInput | string
    sheet_likes?: IntFieldUpdateOperationsInput | number
    sheet_dislikes?: IntFieldUpdateOperationsInput | number
    sheet_views?: IntFieldUpdateOperationsInput | number
    sheet_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sheetsUncheckedUpdateManyWithoutSheets_thumbnailsInput = {
    sheet_id?: StringFieldUpdateOperationsInput | string
    sheet_author_id?: StringFieldUpdateOperationsInput | string
    sheet_title?: StringFieldUpdateOperationsInput | string
    sheet_subject?: StringFieldUpdateOperationsInput | string
    sheet_filename?: StringFieldUpdateOperationsInput | string
    sheet_data_id?: StringFieldUpdateOperationsInput | string
    sheet_likes?: IntFieldUpdateOperationsInput | number
    sheet_dislikes?: IntFieldUpdateOperationsInput | number
    sheet_views?: IntFieldUpdateOperationsInput | number
    sheet_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tables_membersCreateManyTablesInput = {
    tables_members_id: string
    member_id: string
    table_position: number
    live?: number
  }

  export type tables_messages_logsCreateManyTablesInput = {
    tables_messages_logs_id: string
    entity_id: string
    message: string
    message_date: Date | string
  }

  export type tables_tabletopsCreateManyTablesInput = {
    tables_tabletops_id: string
    creator_id: string
    tables_tabletops_data_id?: string | null
    type: number
    content_date_posted: Date | string
    content_x_position: number
    content_y_position: number
    content_rotation: number
    content_filename?: string | null
  }

  export type tables_membersUpdateWithoutTablesInput = {
    tables_members_id?: StringFieldUpdateOperationsInput | string
    table_position?: IntFieldUpdateOperationsInput | number
    live?: IntFieldUpdateOperationsInput | number
    entities?: entitiesUpdateOneRequiredWithoutTables_membersNestedInput
  }

  export type tables_membersUncheckedUpdateWithoutTablesInput = {
    tables_members_id?: StringFieldUpdateOperationsInput | string
    member_id?: StringFieldUpdateOperationsInput | string
    table_position?: IntFieldUpdateOperationsInput | number
    live?: IntFieldUpdateOperationsInput | number
  }

  export type tables_membersUncheckedUpdateManyWithoutTablesInput = {
    tables_members_id?: StringFieldUpdateOperationsInput | string
    member_id?: StringFieldUpdateOperationsInput | string
    table_position?: IntFieldUpdateOperationsInput | number
    live?: IntFieldUpdateOperationsInput | number
  }

  export type tables_messages_logsUpdateWithoutTablesInput = {
    tables_messages_logs_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    message_date?: DateTimeFieldUpdateOperationsInput | Date | string
    entities?: entitiesUpdateOneRequiredWithoutTables_messages_logsNestedInput
  }

  export type tables_messages_logsUncheckedUpdateWithoutTablesInput = {
    tables_messages_logs_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    message_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tables_messages_logsUncheckedUpdateManyWithoutTablesInput = {
    tables_messages_logs_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    message_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tables_tabletopsUpdateWithoutTablesInput = {
    tables_tabletops_id?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    content_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
    content_x_position?: IntFieldUpdateOperationsInput | number
    content_y_position?: IntFieldUpdateOperationsInput | number
    content_rotation?: IntFieldUpdateOperationsInput | number
    content_filename?: NullableStringFieldUpdateOperationsInput | string | null
    entities?: entitiesUpdateOneRequiredWithoutTables_tabletopsNestedInput
    tables_tabletops_data?: tables_tabletops_dataUpdateOneWithoutTables_tabletopsNestedInput
  }

  export type tables_tabletopsUncheckedUpdateWithoutTablesInput = {
    tables_tabletops_id?: StringFieldUpdateOperationsInput | string
    creator_id?: StringFieldUpdateOperationsInput | string
    tables_tabletops_data_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    content_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
    content_x_position?: IntFieldUpdateOperationsInput | number
    content_y_position?: IntFieldUpdateOperationsInput | number
    content_rotation?: IntFieldUpdateOperationsInput | number
    content_filename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tables_tabletopsUncheckedUpdateManyWithoutTablesInput = {
    tables_tabletops_id?: StringFieldUpdateOperationsInput | string
    creator_id?: StringFieldUpdateOperationsInput | string
    tables_tabletops_data_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    content_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
    content_x_position?: IntFieldUpdateOperationsInput | number
    content_y_position?: IntFieldUpdateOperationsInput | number
    content_rotation?: IntFieldUpdateOperationsInput | number
    content_filename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tablesCreateManyTables_picturesInput = {
    table_id: string
    table_name?: string | null
    table_creation_date: Date | string
    last_message?: string | null
    last_message_date?: Date | string | null
  }

  export type tablesUpdateWithoutTables_picturesInput = {
    table_id?: StringFieldUpdateOperationsInput | string
    table_name?: NullableStringFieldUpdateOperationsInput | string | null
    table_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tables_members?: tables_membersUpdateManyWithoutTablesNestedInput
    tables_messages_logs?: tables_messages_logsUpdateManyWithoutTablesNestedInput
    tables_tabletops?: tables_tabletopsUpdateManyWithoutTablesNestedInput
  }

  export type tablesUncheckedUpdateWithoutTables_picturesInput = {
    table_id?: StringFieldUpdateOperationsInput | string
    table_name?: NullableStringFieldUpdateOperationsInput | string | null
    table_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tables_members?: tables_membersUncheckedUpdateManyWithoutTablesNestedInput
    tables_messages_logs?: tables_messages_logsUncheckedUpdateManyWithoutTablesNestedInput
    tables_tabletops?: tables_tabletopsUncheckedUpdateManyWithoutTablesNestedInput
  }

  export type tablesUncheckedUpdateManyWithoutTables_picturesInput = {
    table_id?: StringFieldUpdateOperationsInput | string
    table_name?: NullableStringFieldUpdateOperationsInput | string | null
    table_creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tables_tabletopsCreateManyTables_tabletops_dataInput = {
    tables_tabletops_id: string
    table_id: string
    creator_id: string
    type: number
    content_date_posted: Date | string
    content_x_position: number
    content_y_position: number
    content_rotation: number
    content_filename?: string | null
  }

  export type tables_tabletopsUpdateWithoutTables_tabletops_dataInput = {
    tables_tabletops_id?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    content_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
    content_x_position?: IntFieldUpdateOperationsInput | number
    content_y_position?: IntFieldUpdateOperationsInput | number
    content_rotation?: IntFieldUpdateOperationsInput | number
    content_filename?: NullableStringFieldUpdateOperationsInput | string | null
    entities?: entitiesUpdateOneRequiredWithoutTables_tabletopsNestedInput
    tables?: tablesUpdateOneRequiredWithoutTables_tabletopsNestedInput
  }

  export type tables_tabletopsUncheckedUpdateWithoutTables_tabletops_dataInput = {
    tables_tabletops_id?: StringFieldUpdateOperationsInput | string
    table_id?: StringFieldUpdateOperationsInput | string
    creator_id?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    content_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
    content_x_position?: IntFieldUpdateOperationsInput | number
    content_y_position?: IntFieldUpdateOperationsInput | number
    content_rotation?: IntFieldUpdateOperationsInput | number
    content_filename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tables_tabletopsUncheckedUpdateManyWithoutTables_tabletops_dataInput = {
    tables_tabletops_id?: StringFieldUpdateOperationsInput | string
    table_id?: StringFieldUpdateOperationsInput | string
    creator_id?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    content_date_posted?: DateTimeFieldUpdateOperationsInput | Date | string
    content_x_position?: IntFieldUpdateOperationsInput | number
    content_y_position?: IntFieldUpdateOperationsInput | number
    content_rotation?: IntFieldUpdateOperationsInput | number
    content_filename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type videosCreateManyVideos_dataInput = {
    video_id: string
    video_creator_id: string
    video_title: string
    video_description: string
    video_filename: string
    video_thumbnail_id?: string | null
    video_likes?: number
    video_dislikes?: number
    video_views?: number
    video_date_posted?: Date | string | null
  }

  export type videosUpdateWithoutVideos_dataInput = {
    video_id?: StringFieldUpdateOperationsInput | string
    video_title?: StringFieldUpdateOperationsInput | string
    video_description?: StringFieldUpdateOperationsInput | string
    video_filename?: StringFieldUpdateOperationsInput | string
    video_likes?: IntFieldUpdateOperationsInput | number
    video_dislikes?: IntFieldUpdateOperationsInput | number
    video_views?: IntFieldUpdateOperationsInput | number
    video_date_posted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entities?: entitiesUpdateOneRequiredWithoutVideosNestedInput
    videos_thumbnails?: videos_thumbnailsUpdateOneWithoutVideosNestedInput
  }

  export type videosUncheckedUpdateWithoutVideos_dataInput = {
    video_id?: StringFieldUpdateOperationsInput | string
    video_creator_id?: StringFieldUpdateOperationsInput | string
    video_title?: StringFieldUpdateOperationsInput | string
    video_description?: StringFieldUpdateOperationsInput | string
    video_filename?: StringFieldUpdateOperationsInput | string
    video_thumbnail_id?: NullableStringFieldUpdateOperationsInput | string | null
    video_likes?: IntFieldUpdateOperationsInput | number
    video_dislikes?: IntFieldUpdateOperationsInput | number
    video_views?: IntFieldUpdateOperationsInput | number
    video_date_posted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type videosUncheckedUpdateManyWithoutVideos_dataInput = {
    video_id?: StringFieldUpdateOperationsInput | string
    video_creator_id?: StringFieldUpdateOperationsInput | string
    video_title?: StringFieldUpdateOperationsInput | string
    video_description?: StringFieldUpdateOperationsInput | string
    video_filename?: StringFieldUpdateOperationsInput | string
    video_thumbnail_id?: NullableStringFieldUpdateOperationsInput | string | null
    video_likes?: IntFieldUpdateOperationsInput | number
    video_dislikes?: IntFieldUpdateOperationsInput | number
    video_views?: IntFieldUpdateOperationsInput | number
    video_date_posted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type videosCreateManyVideos_thumbnailsInput = {
    video_id: string
    video_creator_id: string
    video_title: string
    video_description: string
    video_filename: string
    video_data_id: string
    video_likes?: number
    video_dislikes?: number
    video_views?: number
    video_date_posted?: Date | string | null
  }

  export type videosUpdateWithoutVideos_thumbnailsInput = {
    video_id?: StringFieldUpdateOperationsInput | string
    video_title?: StringFieldUpdateOperationsInput | string
    video_description?: StringFieldUpdateOperationsInput | string
    video_filename?: StringFieldUpdateOperationsInput | string
    video_likes?: IntFieldUpdateOperationsInput | number
    video_dislikes?: IntFieldUpdateOperationsInput | number
    video_views?: IntFieldUpdateOperationsInput | number
    video_date_posted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entities?: entitiesUpdateOneRequiredWithoutVideosNestedInput
    videos_data?: videos_dataUpdateOneRequiredWithoutVideosNestedInput
  }

  export type videosUncheckedUpdateWithoutVideos_thumbnailsInput = {
    video_id?: StringFieldUpdateOperationsInput | string
    video_creator_id?: StringFieldUpdateOperationsInput | string
    video_title?: StringFieldUpdateOperationsInput | string
    video_description?: StringFieldUpdateOperationsInput | string
    video_filename?: StringFieldUpdateOperationsInput | string
    video_data_id?: StringFieldUpdateOperationsInput | string
    video_likes?: IntFieldUpdateOperationsInput | number
    video_dislikes?: IntFieldUpdateOperationsInput | number
    video_views?: IntFieldUpdateOperationsInput | number
    video_date_posted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type videosUncheckedUpdateManyWithoutVideos_thumbnailsInput = {
    video_id?: StringFieldUpdateOperationsInput | string
    video_creator_id?: StringFieldUpdateOperationsInput | string
    video_title?: StringFieldUpdateOperationsInput | string
    video_description?: StringFieldUpdateOperationsInput | string
    video_filename?: StringFieldUpdateOperationsInput | string
    video_data_id?: StringFieldUpdateOperationsInput | string
    video_likes?: IntFieldUpdateOperationsInput | number
    video_dislikes?: IntFieldUpdateOperationsInput | number
    video_views?: IntFieldUpdateOperationsInput | number
    video_date_posted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CollectionsCountOutputTypeDefaultArgs instead
     */
    export type CollectionsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CollectionsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Contacts_picturesCountOutputTypeDefaultArgs instead
     */
    export type Contacts_picturesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Contacts_picturesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContentCountOutputTypeDefaultArgs instead
     */
    export type ContentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationsCountOutputTypeDefaultArgs instead
     */
    export type ConversationsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Conversations_picturesCountOutputTypeDefaultArgs instead
     */
    export type Conversations_picturesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Conversations_picturesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EntitiesCountOutputTypeDefaultArgs instead
     */
    export type EntitiesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EntitiesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupsCountOutputTypeDefaultArgs instead
     */
    export type GroupsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Images_dataCountOutputTypeDefaultArgs instead
     */
    export type Images_dataCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Images_dataCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationsCountOutputTypeDefaultArgs instead
     */
    export type OrganizationsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Profile_picturesCountOutputTypeDefaultArgs instead
     */
    export type Profile_picturesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Profile_picturesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Sheets_dataCountOutputTypeDefaultArgs instead
     */
    export type Sheets_dataCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Sheets_dataCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Sheets_thumbnailsCountOutputTypeDefaultArgs instead
     */
    export type Sheets_thumbnailsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Sheets_thumbnailsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TablesCountOutputTypeDefaultArgs instead
     */
    export type TablesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TablesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Tables_picturesCountOutputTypeDefaultArgs instead
     */
    export type Tables_picturesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tables_picturesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Tables_tabletops_dataCountOutputTypeDefaultArgs instead
     */
    export type Tables_tabletops_dataCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tables_tabletops_dataCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Videos_dataCountOutputTypeDefaultArgs instead
     */
    export type Videos_dataCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Videos_dataCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Videos_thumbnailsCountOutputTypeDefaultArgs instead
     */
    export type Videos_thumbnailsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Videos_thumbnailsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use affiliates_relationsDefaultArgs instead
     */
    export type affiliates_relationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = affiliates_relationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use collectionsDefaultArgs instead
     */
    export type collectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = collectionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use collections_contentDefaultArgs instead
     */
    export type collections_contentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = collections_contentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use contactsDefaultArgs instead
     */
    export type contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = contactsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use contacts_picturesDefaultArgs instead
     */
    export type contacts_picturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = contacts_picturesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use contentDefaultArgs instead
     */
    export type contentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = contentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use conversationsDefaultArgs instead
     */
    export type conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = conversationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use conversations_membersDefaultArgs instead
     */
    export type conversations_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = conversations_membersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use conversations_messages_logsDefaultArgs instead
     */
    export type conversations_messages_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = conversations_messages_logsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use conversations_picturesDefaultArgs instead
     */
    export type conversations_picturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = conversations_picturesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use entitiesDefaultArgs instead
     */
    export type entitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = entitiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use entities_contentDefaultArgs instead
     */
    export type entities_contentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = entities_contentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use entities_dislikesDefaultArgs instead
     */
    export type entities_dislikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = entities_dislikesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use entities_likesDefaultArgs instead
     */
    export type entities_likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = entities_likesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use entities_referencesDefaultArgs instead
     */
    export type entities_referencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = entities_referencesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use groupsDefaultArgs instead
     */
    export type groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = groupsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use groups_membersDefaultArgs instead
     */
    export type groups_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = groups_membersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use imagesDefaultArgs instead
     */
    export type imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = imagesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use images_dataDefaultArgs instead
     */
    export type images_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = images_dataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use individualsDefaultArgs instead
     */
    export type individualsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = individualsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use organizationsDefaultArgs instead
     */
    export type organizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = organizationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use organizations_membersDefaultArgs instead
     */
    export type organizations_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = organizations_membersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use profile_picturesDefaultArgs instead
     */
    export type profile_picturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = profile_picturesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use sheetsDefaultArgs instead
     */
    export type sheetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = sheetsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use sheets_dataDefaultArgs instead
     */
    export type sheets_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = sheets_dataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use sheets_thumbnailsDefaultArgs instead
     */
    export type sheets_thumbnailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = sheets_thumbnailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tablesDefaultArgs instead
     */
    export type tablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tablesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tables_membersDefaultArgs instead
     */
    export type tables_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tables_membersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tables_messages_logsDefaultArgs instead
     */
    export type tables_messages_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tables_messages_logsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tables_picturesDefaultArgs instead
     */
    export type tables_picturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tables_picturesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tables_tabletopsDefaultArgs instead
     */
    export type tables_tabletopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tables_tabletopsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tables_tabletops_dataDefaultArgs instead
     */
    export type tables_tabletops_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tables_tabletops_dataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use user_credentialsDefaultArgs instead
     */
    export type user_credentialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = user_credentialsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use videosDefaultArgs instead
     */
    export type videosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = videosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use videos_dataDefaultArgs instead
     */
    export type videos_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = videos_dataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use videos_thumbnailsDefaultArgs instead
     */
    export type videos_thumbnailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = videos_thumbnailsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}